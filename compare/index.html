<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="tooling.report 权威性的参考 是一个开源的项目，它期望给开发者在选择构建工具时一些权威性的参考。
这些参考在开发者进行一些构建工具相关的决策时非常有用，比如：
 在开始下一个项目时该如何选择构建工具？ 用来抉择是否从一个构建工具迁移到另外一个构建工具？ 在使用构建工具时如何得到最佳实践？  各个不同的构建工具有不同的专注领域，因此会满足不同的需求，这也就意味着我们在选择和配置 building tools 时需要进行 tradeoffs。而如果有一个网站能够最新的和你解释这些 tradeoffs，并且告诉你该如何一步步来达到最佳实践，是不是听起来很棒？
为什么选择合适的构建工具对于我们如此的重要呢？
在开发一个现代 web 项目时，我们会先从讨论项目的基础设施开发，比如宿主环境(host environment)如何？选用什么框架？选用什么构建工具？"><meta property="og:title" content><meta property="og:description" content="tooling.report 权威性的参考 是一个开源的项目，它期望给开发者在选择构建工具时一些权威性的参考。
这些参考在开发者进行一些构建工具相关的决策时非常有用，比如：
 在开始下一个项目时该如何选择构建工具？ 用来抉择是否从一个构建工具迁移到另外一个构建工具？ 在使用构建工具时如何得到最佳实践？  各个不同的构建工具有不同的专注领域，因此会满足不同的需求，这也就意味着我们在选择和配置 building tools 时需要进行 tradeoffs。而如果有一个网站能够最新的和你解释这些 tradeoffs，并且告诉你该如何一步步来达到最佳实践，是不是听起来很棒？
为什么选择合适的构建工具对于我们如此的重要呢？
在开发一个现代 web 项目时，我们会先从讨论项目的基础设施开发，比如宿主环境(host environment)如何？选用什么框架？选用什么构建工具？"><meta property="og:type" content="website"><meta property="og:image" content="https://jieye-ericx.github.io/icon.png"><meta property="og:url" content="https://jieye-ericx.github.io/compare/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="tooling.report 权威性的参考 是一个开源的项目，它期望给开发者在选择构建工具时一些权威性的参考。
这些参考在开发者进行一些构建工具相关的决策时非常有用，比如：
 在开始下一个项目时该如何选择构建工具？ 用来抉择是否从一个构建工具迁移到另外一个构建工具？ 在使用构建工具时如何得到最佳实践？  各个不同的构建工具有不同的专注领域，因此会满足不同的需求，这也就意味着我们在选择和配置 building tools 时需要进行 tradeoffs。而如果有一个网站能够最新的和你解释这些 tradeoffs，并且告诉你该如何一步步来达到最佳实践，是不是听起来很棒？
为什么选择合适的构建工具对于我们如此的重要呢？
在开发一个现代 web 项目时，我们会先从讨论项目的基础设施开发，比如宿主环境(host environment)如何？选用什么框架？选用什么构建工具？"><meta name=twitter:image content="https://jieye-ericx.github.io/icon.png"><title>ericx 's 数字花园</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://jieye-ericx.github.io//icon.png><link href=https://jieye-ericx.github.io/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://jieye-ericx.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://jieye-ericx.github.io/js/darkmode.48459b7116d092b4e98d2cab704cad80.min.js></script>
<script src=https://jieye-ericx.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://jieye-ericx.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://jieye-ericx.github.io/",fetchData=Promise.all([fetch("https://jieye-ericx.github.io/indices/linkIndex.498f8802e86f71aa2af4d45d6c4096d6.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://jieye-ericx.github.io/indices/contentIndex.5368a39ad15318a851f2d088b43f3a36.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://jieye-ericx.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://jieye-ericx.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/jieye-ericx.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=jieye-ericx.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://jieye-ericx.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://jieye-ericx.github.io/>ericx 's 数字花园</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown
<a href=https://github.com/jackyzha0/quartz/tree/hugo/content/compare.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><ol><li><a href=#toolingreport-权威性的参考><strong>tooling.report</strong> 权威性的参考</a></li><li><a href=#code-splitting>code splitting</a></li><li><a href=#image-20200719201112461compareassetsimage-20200719201112461pngimporting-modules><img src=compare.assets/image-20200719201112461.png alt=image-20200719201112461>importing Modules</a></li><li><a href=#output-modules-format>output Modules format</a></li><li><a href=#image-20200719201213894compareassetsimage-20200719201213894pngnon-javascript-resources><img src=compare.assets/image-20200719201213894.png alt=image-20200719201213894>Non-JavaScript Resources</a></li><li><a href=#hashing>Hashing</a></li><li><a href=#transformations>transformations</a></li><li><a href=#image-20200719201410089compareassetsimage-20200719201410089png总结><img src=compare.assets/image-20200719201410089.png alt=image-20200719201410089>总结</a></li></ol></li></ol></nav></details></aside><a href=#toolingreport-权威性的参考><h3 id=toolingreport-权威性的参考><span class=hanchor arialabel=Anchor># </span><strong>tooling.report</strong> 权威性的参考</h3></a><p>是一个开源的项目，它期望给开发者在选择构建工具时一些权威性的参考。</p><p>这些参考在开发者进行一些构建工具相关的决策时非常有用，比如：</p><ul><li>在开始下一个项目时该如何选择构建工具？</li><li>用来抉择是否从一个构建工具迁移到另外一个构建工具？</li><li>在使用构建工具时如何得到最佳实践？</li></ul><p>各个不同的构建工具有不同的专注领域，因此会满足不同的需求，这也就意味着我们在选择和配置 building tools 时需要进行 tradeoffs。而如果有一个网站能够最新的和你解释这些 tradeoffs，并且告诉你该如何一步步来达到最佳实践，是不是听起来很棒？</p><p><strong>为什么选择合适的构建工具对于我们如此的重要呢？</strong></p><p>在开发一个现代 web 项目时，我们会先从讨论项目的基础设施开发，比如宿主环境(host environment)如何？选用什么框架？选用什么构建工具？</p><p>随着项目的进展，这些基础设施可能会被更新，比如需要添加新的、定制的 plugin 来满足框架或技术的需求。而往往会忽略的一点是，我们组织代码的方式可能会因为构建工具的不同而发生对应的变化（为了让构建工具能够更好地理解我们正在做什么）。在整个开发的过程中，我们经常会发现，构建工具会成为项目的障碍。</p><p>对于专注于给用户提供最佳浏览体验的团队来讲，会经常微调前端资源的组合和分发的方式。举个例子，如果一个主线程脚本（main thread script）和一个 web worker script 有共同依赖的资源，我们会更加期望该依赖资源只会被下载一次，而不是在两个 script 都分别打包一次。一些构建工具对于上述的需求支持开箱即用，有些需要进行特殊的定制化来覆盖默认的行为，而有些则是完全不支持。</p><p><strong>这种体验或者需求会促使我们去研究各种构建工具能做什么？不能做什么？如果此时有一个 features checklist，我们选择时候是不是会更加简单一些？</strong></p><p><strong>那么该如何在一个地方评估和比较不同的构建工具呢？</strong> 编写 test cases 不失为一个很好的方法。</p><p>Jake 的团队讨论并设计了测试标准，他们更加关注于是否能够提供给用户更加 fast, responsive, smooth 的体验（甲方是老大）。值得注意的是，这些 test case 并没有过多考虑开发者的使用体验，目的是为了避免可能产生冲突的结果（因为有些目标本身就是矛盾的）。</p><p>tooling.report 在建立完 test list 之后，会编写构建脚本来检查每个构建工具是否能够满足测试标准。目前 tooling.report 构建工具列表如下：</p><ul><li>webpack v4</li><li>rollup v2</li><li>Parcel v2</li><li>Browserify + Gulp （因为仍然有很多项目在依赖它）</li></ul><p>**在编写完测试用例后，该如何确保测试用例使用构建工具的方式是正确的？又是如何确保尽量在比较的时候公平？**tooling.report 目前是直接和构建工具的作者进行沟通来保证上述的问题，并且通过开源来集合社区的力量。</p><p><strong>此时有同学可能会问，“对于只使用构建工具，而不会进行决策使用哪个的开发人员来讲，tooling.reports 是否仍然有意义？”</strong></p><p>我们知道，在很多团队中，有专门的人员来致力于基础设施的维护，而团队的其他人员只需要直接使用就好。但是在这里我需要强调的是 tooling.reports 对于这列开发者仍然是有意义的。因为对于每一项测试，tooling.reports 都会详细解释为什么这些测试是重要的，各个构建工具该是如何满足这些测试的，并且在 github 提供了这些测试的最佳配置方案。</p><p><strong>听到这里，大家是不是都已经兴奋了起来 ^&lt;>^</strong></p><p>下面我们来看看各大构建工具的测试通过率：</p><p><img src=https://jieye-ericx.github.io//compare.assets/image-20200719200621171.png width=auto alt=image-20200719200621171></p><p><strong>到这里，都是表层的东西。我不禁思考起来，构建工具的哪些特性对于开发者是值得关注的？换种说法，tooling.reports 究竟是怎么选择这些测试特性的？</strong></p><p>目前 tooling.reports 主要测试的特性有 6 大种类：</p><ol><li>code splitting。导出公共的依赖来避免重复打包</li><li>Hashing。给长期缓存(long-term caching) 生成散列 URL</li><li>Importing Modules。是否支持不同的模块格式导入</li><li>Non-JavaScript Resources。是否支持在 JavaScript 中导入 CSS 和其他类型文件</li><li>Output Module Formats。是否支持不同的模块格式导出</li><li>Transformations。是否支持对代码和其他资源的转换，比如<code>.vue</code> 文件的转换处理</li></ol><p>下面我们来一一分析这些特性。</p><a href=#code-splitting><h3 id=code-splitting><span class=hanchor arialabel=Anchor># </span>code splitting</h3></a><p>code splitting 在构建现代高性能 JavaScript 应用非常重要，其可以避免多余的下载。从高维度来讲，code splitting 指的是将代码分割成更小的 bundles，然后这些 bundles 可以被分别单独加载。</p><p>而对于 code splitting，在实际使用过程中又有很多不同的功能分支。在 tooling.reports 中总共提供了 7 种相关的 test case，下面一一介绍：</p><ol><li><strong>Between New Worker Type: can entry bundles be created for other contexts ?（是否能对不同的 JavaScript context 的共用部分单独打包）</strong></li></ol><p>在项目中，我们有很多不同的场景需要给不同的 Javascript context 分别打包一些代码，而 <strong>web workers</strong> 可能是最常见的情况，我们期望构建工具的特性同样对 <strong>service workder</strong>, <strong>module workers</strong> 和 <strong>worklets</strong> 适用。目前很多构建工具只是专门对 web workers 进行了特殊处理，而对新的 worker 变种进行适配仍然需要时间。</p><p>我们在设计测试用例时，期望该测试用例能够检查构建工具是否对新的或自定义的 context 类型进行代码分割。具体测试用例如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// index.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>import</span> <span class=nx>workerURL</span> <span class=nx>from</span> <span class=s1>&#39;get-worker-url-somehow&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=p>{</span> <span class=nx>logCaps</span> <span class=p>}</span> <span class=nx>from</span> <span class=s1>&#39;./utils.js&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>new</span> <span class=nx>InterestingNewWorkerType</span><span class=p>(</span><span class=nx>workerURL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>logCaps</span><span class=p>(</span><span class=s1>&#39;This is index&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// worker.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>import</span> <span class=p>{</span> <span class=nx>logCaps</span> <span class=p>}</span> <span class=nx>from</span> <span class=s1>&#39;./utils.js&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>logCaps</span><span class=p>(</span><span class=s1>&#39;This is worker&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// utils.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>export</span> <span class=kd>function</span> <span class=nx>logCaps</span><span class=p>(</span><span class=nx>msg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>toUpperCase</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>测试用例期望将上面的 modules 能够打包成 2-3 个文件。一个用来存放主线程代码，一个存放 worker thread 代码，更加理想的 utils 中的 logCaps(被另外两个共享的)能够单独打包成一个 shared bundle。</p><p>结论是：</p><p><img src=https://jieye-ericx.github.io//compare.assets/image-20200719200834729.png width=auto alt=image-20200719200834729></p><ol><li><strong>between workers: can bundles be shared between the main thread and workers?(是否能对主线程和 web workers 公用的部分单独打包)</strong></li></ol><p>该测试用例是对测试 1 的特异化，用来查看各大构建工具是否有对 web workers 有支持。</p><p><img src=https://jieye-ericx.github.io//compare.assets/image-20200719200851170.png width=auto alt=image-20200719200851170></p><ol><li><strong>是否支持通过 dynamic import 进行分割代码</strong></li></ol><p>首先，我们得普及专业名词 - <code>split point</code> 的定义。在 code splitting 当中，一个 &ldquo;split point&rdquo; 指的是异步的模块边界，其允许依赖能够从父模块中被分割出来，进行单独地打包和加载。</p><p>建立 split point 让 JavaScript 按需加载应用不同的部分成为可能（这在首屏加载非常有用）。</p><p>最常见的实现 split point 的语法就是 dynamic import。</p><p>测试用例如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// index.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>(</span><span class=kr>async</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>{</span><span class=nx>logCaps</span><span class=p>}</span> <span class=o>=</span> <span class=kr>await</span> <span class=kr>import</span><span class=p>(</span><span class=s1>&#39;./utils.js&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>logCaps</span><span class=p>(</span><span class=s1>&#39;This is index&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>})();</span>
</span></span><span class=line><span class=cl><span class=c1>// utils.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>export</span> <span class=kd>function</span> <span class=nx>logCaps</span><span class=p>(</span><span class=nx>msg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>toUpperCase</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>期望结果是产生两个脚本文件，一个是 <code>index</code> 模块，一个是 <code>utils</code> 模块。并且可以在 utils 模块被加载前执行 index 模块。</p><ol><li><strong><img src=https://jieye-ericx.github.io//compare.assets/image-20200719200912942.png width=auto alt=image-20200719200912942>Multiple Entry Points Per Page: Can multiple entry points be used without duplicating modules?（当一个页面有多个入口时，多个入口是否会重复生成共用的 bundles）</strong></li></ol><p>通常来讲，一个页面只有一个入口，但有些时候会有一个页面多个入口的需求。比如，你期望在主入口旁边有个辅助入口，该入口用来分析。根据构建工具的配置，多个入口依赖的公用模块可以被提取出来，成为多个页面公用的包。另外有时候也会出现另外一种情况，该公用模块只有很少的页面使用，以至于没有太多的理由将其抽取到公用包，而构建工具会将其分别内联到每个入口 bundle 里面。</p><p>但无论是<strong>提取</strong>出来还是<strong>内联</strong>，一个模块都不能被多次实例化。因为 ECMAScript module 和 CommonJS 都指定了一个 module 在每个 JavaScript 上下文只能被实例化一次。这种保证允许将模块的状态共享，很多库都是依赖这种假设来实现重要的跨领域问题(cross-cutting concerns)，比如 memorization， queues 和 plugin 注册。如果打破这个假设，会导致错误和低效。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=o>&lt;!</span><span class=nx>DOCTYPE</span> <span class=nx>html</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>script</span> <span class=nx>src</span><span class=o>=</span><span class=s2>&#34;component-1.js&#34;</span><span class=o>&gt;&lt;</span><span class=err>/script&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>script</span> <span class=nx>src</span><span class=o>=</span><span class=s2>&#34;component-2.js&#34;</span><span class=o>&gt;&lt;</span><span class=err>/script&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>// component-1.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>import</span> <span class=nx>obj</span> <span class=nx>from</span> <span class=s1>&#39;./obj.js&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>obj</span><span class=p>.</span><span class=nx>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;component-1&#39;</span><span class=p>,</span> <span class=nx>obj</span><span class=p>.</span><span class=nx>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// component-2.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>import</span> <span class=nx>obj</span> <span class=nx>from</span> <span class=s1>&#39;./obj.js&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>obj</span><span class=p>.</span><span class=nx>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;component-2&#39;</span><span class=p>,</span> <span class=nx>obj</span><span class=p>.</span><span class=nx>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// obj.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>export</span> <span class=k>default</span> <span class=p>{</span> <span class=nx>count</span><span class=o>:</span> <span class=mi>0</span> <span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>我们期望构建工具构建后的代码能够输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>component-1 1
</span></span><span class=line><span class=cl>component-2 2
</span></span></code></pre></td></tr></table></div></div><p>下面是各大构建工具的测试情况（配置详情和最佳实践去官网查看）：
<img src=https://jieye-ericx.github.io//compare.assets/image-20200719200945964.png width=auto alt=image-20200719200945964></p><ol><li><strong>One Entry Point Per Page: Are common entry denpendencies extracted into a shared bundle?（页面只有单入口时，公共依赖是否会被抽取出来？）</strong></li></ol><p>这个应该算是最通用的需求了。举个例子，现在有两个页面，<code>index</code> 和 <code>profile</code> ，每个页面有各自的入口，但是这两个入口依赖一个共同的第三方库。那么构建工具是否会将这个共用库抽取出来成为 shared bundle, 而不是分别打包一个?</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// index.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>import</span> <span class=p>{</span> <span class=nx>logCaps</span> <span class=p>}</span> <span class=nx>from</span> <span class=s1>&#39;./utils.js&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=p>{</span> <span class=nx>exclaim</span> <span class=p>}</span> <span class=nx>from</span> <span class=s1>&#39;./exclaim.js&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>logCaps</span><span class=p>(</span><span class=nx>exclaim</span><span class=p>(</span><span class=s1>&#39;This is index&#39;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// profile.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>import</span> <span class=p>{</span> <span class=nx>logCaps</span> <span class=p>}</span> <span class=nx>from</span> <span class=s1>&#39;./utils.js&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>logCaps</span><span class=p>(</span><span class=s1>&#39;This is profile&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// utils.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>export</span> <span class=kd>function</span> <span class=nx>logCaps</span><span class=p>(</span><span class=nx>msg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>toUpperCase</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// exclaim.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>export</span> <span class=kd>function</span> <span class=nx>exclaim</span><span class=p>(</span><span class=nx>msg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>msg</span> <span class=o>+</span> <span class=s1>&#39;!&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>我们期望构建工具能生成三个单独的 bundle：</p><ul><li>一个给 <code>index</code> page</li><li>一个在 <code>profile</code> page</li><li>一个包含 <code>logCaps()</code></li></ul><p><img src=https://jieye-ericx.github.io//compare.assets/image-20200719201018008.png width=auto alt=image-20200719201018008>shared References Between Chunks: Are module exports between bundles live bindlings?(ES moudle 的导出是否是 live binding？)</p><p>这里的 living bindings 是 ES Module 的重点之一（也是面试常问的）。举个例子，如果被依赖的 module 中的值发生了变化，那么该变化会映射到所有依赖该值的模块中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// index.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>import</span> <span class=p>{</span> <span class=nx>num</span><span class=p>,</span> <span class=nx>incrementNum</span> <span class=p>}</span> <span class=nx>from</span> <span class=s1>&#39;./num.js&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>incrementNum</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>num</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>import</span><span class=p>(</span><span class=s1>&#39;./lazy.js&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// lazy.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>import</span> <span class=p>{</span> <span class=nx>num</span><span class=p>,</span> <span class=nx>incrementNum</span> <span class=p>}</span> <span class=nx>from</span> <span class=s1>&#39;./num.js&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>incrementNum</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>num</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// num.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>export</span> <span class=kd>let</span> <span class=nx>num</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=kd>function</span> <span class=nx>incrementNum</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>num</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>我们期望输出结果为 <code>1</code> 和 <code>2</code>。</p><h3 id=image-20200719201112461compareassetsimage-20200719201112461pngimporting-modules><img src=https://jieye-ericx.github.io//compare.assets/image-20200719201112461.png width=auto alt=image-20200719201112461>importing Modules</h3><p>这里 <code>importing modules</code> 指的是是否支持各种不同的模块语法。很明显的是，各大构建工具对该特性的支持都不错。这里我们就不像 code split 一样一个个分析了（不然文章太长，写的也很累）：</p><p>tooling.report 提供了 3 个测试用例：</p><ol><li>是否支持 commonJS？</li><li>是否支持 ES module？</li><li>是否支持从 <code>node_modules</code> 导入依赖？
<img src=https://jieye-ericx.github.io//compare.assets/image-20200719201150065.png width=auto alt=image-20200719201150065></li></ol><a href=#output-modules-format><h3 id=output-modules-format><span class=hanchor arialabel=Anchor># </span>output Modules format</h3></a><p>是否支持不同的模块格式的导出。</p><p>很明显，这种功能是非常必要的。首先在 Node 12 之前，Nodejs 只支持 CommonJS；如果你的生产环境是现代浏览器，那么 ES module 肯定是最适合的；但是如果浏览器是老版本的，那么就需要相应的兼容。</p><p>另外还有一些情况，我们需要定制特殊的 module format。比如 web workers 的模块目前只能在 chrome 中使用，还没有浏览器支持 service worker 的模块化使用。</p><h3 id=image-20200719201213894compareassetsimage-20200719201213894pngnon-javascript-resources><img src=https://jieye-ericx.github.io//compare.assets/image-20200719201213894.png width=auto alt=image-20200719201213894>Non-JavaScript Resources</h3><p>构建工具支持我们在 JavaScript 导入其他类型的资源是非常重要的功能。</p><p>**为什么呢？**一个基本的 web 应用，会有如下的资源类型：</p><ul><li>HTML 文档</li><li>CSS 样式表</li><li>JSON 或者 XML</li><li>其他资源，比如图片、字体</li></ul><p><strong>如果我们不能够很好地定义这些资源的关系，那么带来的问题是 - 单独处理这类类型的资源会很困难。比如我们对 URL 进行哈希处理时，各个资源的引用可能会产生不同步。并且资源的上下文处理也非常的困难甚至不可能。</strong></p><p>流行的解决方案是将应用表示成资源图(graph of resources)，这种方式非常类似于 module graph 的概念。资源图可以保存每个资源的信息，包括它所依赖的资源。比如 CSS 样式表依赖于其他通过 <code>@import</code> 引用的样式表；<code>@font-face</code> 引入的字体。更加有用的是，这些信息可以用来修改甚至内联资源的 URLs，或者应用 transformations（比如 namespacing CSS).</p><p>目前来讲，JavaScript 本身不支持在 module graph 中包含非 JS 资源，因此我们需要构建工具进行处理（在这里我们没有考虑最新的 TC39 提案 - <strong>Import Attribute proposal</strong>，支持安全引入 Non-JavaScript 资源）。</p><blockquote><p><img src=https://jieye-ericx.github.io//compare.assets/image-20200719201348106.png width=auto alt=image-20200719201348106>受篇幅限制，更加详细的测试信息去官方查询</p></blockquote><a href=#hashing><h3 id=hashing><span class=hanchor arialabel=Anchor># </span>Hashing</h3></a><p>对于现代的高性能 web 应用来讲，有效的缓存策略非常重要。但是我们该如何实现呢？理想的情况下，脚本和样式之类的资源如果没有被更新的话应该只会下载一次。如果我们的资源文件名称都是没有变化的，那么我们不得不重复请求这些同样的资源（因为我们没法分清楚该资源有没有被更新）或者使用陈旧的旧版本。这甚至会导致新版本的代码和某些陈旧代码意外组合，造成线上的错误（这就很严重了）。</p><p>解决上面问题的最佳方法之一就是将<strong>版本信息包含在资源的 URL 中</strong>。构建工具可以根据资源的内容生成相应的版本标识符，而这个过程就被我们称为 “hashing”（使用摘要算法的缘故）。当文件发生变动时，对应的哈希值也会发生变化，这样就能确保正确的缓存策略了。</p><p>但是这需要构建工具很好的实现，因为各个资源之间可能是相互依赖的，一个资源的变动，意味着会导致关联资源的变动（这个时候资源图就很重要了）。</p><blockquote><p><img src=https://jieye-ericx.github.io//compare.assets/image-20200719201329700.png width=auto alt=image-20200719201329700>受篇幅限制，更加详细的测试信息和最佳实践去官方查询</p></blockquote><a href=#transformations><h3 id=transformations><span class=hanchor arialabel=Anchor># </span>transformations</h3></a><p>我们期望构建工具能够支持对代码或其他资源的某些转换。这些转换有些是通用的优化，比如压缩或者 minify；有些则是关于上下文的，比如内联图片或提取关键的 CSS；有些则是特定应用的直接转换，比如 本地化或者提前编译。</p><p>当应用的所有资源通过依赖图表示的时候，转换可以通过资源类型来区分。</p><h3 id=image-20200719201410089compareassetsimage-20200719201410089png总结><img src=https://jieye-ericx.github.io//compare.assets/image-20200719201410089.png width=auto alt=image-20200719201410089>总结</h3><p>到这里，我们已经定量分析了 4 种主流的构建工具。<strong>值得注意的是，这些测试每天都在完善着，也期望着看文章的你能够到 github 上贡献一份力量。</strong></p><p>下面我们仔细思考另外一个问题，“除了帮助我们做 tradeoffs，定量分析不同的构建工具能够带给我们什么？”</p><p>其实这里面包含着所有学习的一个核心：<strong>“当你如果只在一个东西里面，你永远无法完全理解这个东西”</strong>。这句话可能有点哲学，用另外一个不太恰当的比喻来看，<strong>“如果你是一只井底的蛙，那么你对这个世界的理解就只有井口那么大，你所能够理解的东西都在这个井里面”</strong>。</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://jieye-ericx.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Jieye ericx using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://jieye-ericx.github.io/>Home</a></li><li><a href=https://github.com/jieye-ericx>Github</a></li></ul></footer></div></div></body></html>