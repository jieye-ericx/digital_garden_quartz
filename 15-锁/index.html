<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="事务的隔离性由这章讲述的锁来实现
1 概述 在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对并发操作进行控制 ，因此产生了锁 。同时锁机制 也为实现MySQL的各个隔离级别提供了保证。锁冲突也是影响数据库并发访问性能的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。
2 MySQL并发事务访问相同记录 并发事务访问相同记录的情况大致可以划分为3种：
2.1 读-读情况 读-读情况，即并发事务相继读取相同的记录。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。
2.2 写-写情况 写-写情况，即并发事务相继对相同的记录做出改动。
在这种情况下会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的，如图所示：
当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。比如，事务T1要对这条记录做改动，就需要生成一个锁结构与之关联：
在锁结构里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来：
 trx信息：代表这个锁结构是哪个事务生成的。 is_waiting ：代表当前事务是否在等待。"><meta property="og:title" content="15 锁"><meta property="og:description" content="事务的隔离性由这章讲述的锁来实现
1 概述 在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对并发操作进行控制 ，因此产生了锁 。同时锁机制 也为实现MySQL的各个隔离级别提供了保证。锁冲突也是影响数据库并发访问性能的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。
2 MySQL并发事务访问相同记录 并发事务访问相同记录的情况大致可以划分为3种：
2.1 读-读情况 读-读情况，即并发事务相继读取相同的记录。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。
2.2 写-写情况 写-写情况，即并发事务相继对相同的记录做出改动。
在这种情况下会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的，如图所示：
当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。比如，事务T1要对这条记录做改动，就需要生成一个锁结构与之关联：
在锁结构里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来：
 trx信息：代表这个锁结构是哪个事务生成的。 is_waiting ：代表当前事务是否在等待。"><meta property="og:type" content="website"><meta property="og:image" content="https://jieye-ericx.github.io/icon.png"><meta property="og:url" content="https://jieye-ericx.github.io/15-%E9%94%81/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="15 锁"><meta name=twitter:description content="事务的隔离性由这章讲述的锁来实现
1 概述 在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对并发操作进行控制 ，因此产生了锁 。同时锁机制 也为实现MySQL的各个隔离级别提供了保证。锁冲突也是影响数据库并发访问性能的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。
2 MySQL并发事务访问相同记录 并发事务访问相同记录的情况大致可以划分为3种：
2.1 读-读情况 读-读情况，即并发事务相继读取相同的记录。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。
2.2 写-写情况 写-写情况，即并发事务相继对相同的记录做出改动。
在这种情况下会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的，如图所示：
当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。比如，事务T1要对这条记录做改动，就需要生成一个锁结构与之关联：
在锁结构里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来：
 trx信息：代表这个锁结构是哪个事务生成的。 is_waiting ：代表当前事务是否在等待。"><meta name=twitter:image content="https://jieye-ericx.github.io/icon.png"><title>15 锁</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://jieye-ericx.github.io//icon.png><link href=https://jieye-ericx.github.io/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://jieye-ericx.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://jieye-ericx.github.io/js/darkmode.48459b7116d092b4e98d2cab704cad80.min.js></script>
<script src=https://jieye-ericx.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://jieye-ericx.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://jieye-ericx.github.io/",fetchData=Promise.all([fetch("https://jieye-ericx.github.io/indices/linkIndex.3bebf7f4f7d7d8863c52240522652193.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://jieye-ericx.github.io/indices/contentIndex.85e4c96368e39ac8aa1e7eef8ad2ce80.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://jieye-ericx.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://jieye-ericx.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/jieye-ericx.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=jieye-ericx.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://jieye-ericx.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://jieye-ericx.github.io/>jieye の 数字花园</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>15 锁</h1><p class=meta>Last updated
Nov 18, 2022</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#1-概述>1 概述</a></li><li><a href=#2-mysql并发事务访问相同记录>2 MySQL并发事务访问相同记录</a><ol><li><a href=#21-读-读情况>2.1 读-读情况</a></li><li><a href=#22-写-写情况>2.2 写-写情况</a></li><li><a href=#23-读-写或写-读情况>2.3 读-写或写-读情况</a></li><li><a href=#24-并发问题的解决方案>2.4 并发问题的解决方案</a></li></ol></li><li><a href=#3-锁的不同角度分类>3 锁的不同角度分类</a><ol><li><a href=#31-从数据操作的类型划分读锁写锁>3.1 从数据操作的类型划分：读锁、写锁</a></li><li><a href=#32-从数据操作的粒度划分表级锁页级锁行锁>3.2 从数据操作的粒度划分：表级锁、页级锁、行锁</a></li><li><a href=#33-从对待锁的态度划分乐观锁悲观锁>3.3 从对待锁的态度划分:乐观锁、悲观锁</a></li><li><a href=#34-按加锁的方式划分显式锁隐式锁>3.4 按加锁的方式划分：显式锁、隐式锁</a></li><li><a href=#35-其它锁之全局锁>3.5 其它锁之：全局锁</a></li><li><a href=#占坑-死锁>占坑 死锁</a></li></ol></li><li><a href=#4-锁的内存结构>4 锁的内存结构</a></li><li><a href=#5-锁监控>5 锁监控</a></li></ol></nav></details></aside><p>事务的隔离性由这章讲述的<strong>锁</strong>来实现</p><a href=#1-概述><h2 id=1-概述><span class=hanchor arialabel=Anchor># </span>1 概述</h2></a><p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对并发操作进行控制 ，因此产生了锁 。同时锁机制 也为实现MySQL的各个隔离级别提供了保证。<strong>锁冲突也是影响数据库并发访问性能的一个重要因素</strong>。所以锁对数据库而言显得尤其重要，也更加复杂。</p><a href=#2-mysql并发事务访问相同记录><h2 id=2-mysql并发事务访问相同记录><span class=hanchor arialabel=Anchor># </span>2 MySQL并发事务访问相同记录</h2></a><p>并发事务访问相同记录的情况大致可以划分为3种：</p><a href=#21-读-读情况><h3 id=21-读-读情况><span class=hanchor arialabel=Anchor># </span>2.1 读-读情况</h3></a><p>读-读情况，即并发事务相继读取相同的记录。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p><a href=#22-写-写情况><h3 id=22-写-写情况><span class=hanchor arialabel=Anchor># </span>2.2 写-写情况</h3></a><p>写-写情况，即并发事务相继对相同的记录做出改动。<br>在这种情况下会发生<strong>脏写</strong>的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的，如图所示：<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118132128.png width=auto alt><br>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的<strong>锁结构</strong>，当没有的时候就会在内存中生成一个锁结构与之关联。比如，事务T1要对这条记录做改动，就需要生成一个锁结构与之关联：<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118150029.png width=auto alt><br>在锁结构里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来：</p><ol><li>trx信息：代表这个锁结构是哪个事务生成的。</li><li>is_waiting ：代表当前事务是否在等待。<br>当事务T1改动了这条记录后，就生成了一个锁结构与该记录关联，<strong>因为之前没有别的事务为这条记录加锁，所以is-waiting 属性就是 fa1se，我们把这个场景就称之为获取锁成功，或者 加锁成功，然后就可以继续执行操作了</strong>。<br>在事务T1提交之前，另一个事务T2也想对该记录做改动，那么先看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，<strong>然后也生成了一个锁结构与这条记录关联，不过锁结构的 is_waiting属性值为true</strong>，表示当前事务需要等待，我们把这个场景就称之为 获取锁失败，或者 加锁失败，图示：<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118150153.png width=auto alt><br>在事务丁1提交之后，就会把该事务生成的锁结构释放掉，然后看看还有没有别的事务在等待获取锁，发现了事务T2还在等待获取锁，所以把事务 T2 对应的锁结构的is_waiting 属性设置为false，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了。效果图就是这样：
<img src=https://jieye-ericx.github.io//Pasted%20image%2020221118150230.png width=auto alt></li></ol><p>小结几种说法：</p><ul><li>不加锁<br>意思就是不需要在内存中生成对应的 锁结构 ，可以直接执行操作。</li><li>获取锁成功，或者加锁成功<br>意思就是在内存中生成了对应的锁结构 ，而且锁结构的 is_waiting 属性为 false ，也就是事务可以继续执行操作。</li><li>获取锁失败，或者加锁失败，或者没有获取到锁<br>意思就是在内存中生成了对应的锁结构，不过锁结构的 is_waiting 属性为 true ，也就是事务需要等待，不可以继续执行操作。</li></ul><a href=#23-读-写或写-读情况><h3 id=23-读-写或写-读情况><span class=hanchor arialabel=Anchor># </span>2.3 读-写或写-读情况</h3></a><p>读-写 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生<strong>脏读、不可重复读、 幻读</strong>的问题。<br>各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 REPEATABLE READ 隔离级别上就已经解决了幻读问题。</p><a href=#24-并发问题的解决方案><h3 id=24-并发问题的解决方案><span class=hanchor arialabel=Anchor># </span>2.4 并发问题的解决方案</h3></a><p>怎么解决脏读、不可重复读、幻读这些问题呢？其实有两种可选的解决方案：</p><ol><li><strong>读操作利用多版本并发控制（ MVCC ，下章讲解），写操作进行加锁</strong>。<br>所谓的 MVCC ，就是生成一个ReadView，通过Readview找到符合条件的记录版本（历史版本由 undo日志构建）。查询语句只能读到在生成ReadView之前 已提交事务所做的更改，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而写操作 肯定针对的是 最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，读-写操作并不冲突。<ul><li>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。在 READ COMMITTED 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了 事务不可以读取到未提交的事务所做的更改 ，也就是<strong>避免了脏读现象</strong>； ^5d06c5</li><li>在 REPEATABLE READ 隔离级别下，一个事务在执行过程中只有 第一次执行SELECT操作 才会生成一个ReadView，之后的SELECT操作都 复用 这个ReadView，这样也就<strong>避免了不可重复读和幻读的问题</strong>。</li></ul></li><li><strong>读、写操作都采用加锁的方式</strong>。<br>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样<strong>在读取记录的时候就需要对其进行 加锁操作，这样也就意味着 读操作和 写操作也像写-写 操作那样排队行</strong>。<ul><li>脏读 的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</li><li>不可重复读 的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</li><li>幻读 问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在，所以渎取的时候加锁就有点尴尬（因为你并不知道给谁加锁）。</li></ul></li></ol><p>小结对比发现：</p><ul><li>采用 MVCC 方式的话， 读-写 操作彼此并不冲突，性能更高。</li><li>采用 加锁 方式的话， 读-写 操作彼此需要排队执行，影响性能。<br>一般情况下我们当然愿意采用 MVCC 来解决 读-写 操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用 加锁 的方式执行。下面就讲解下MySQL中不同类别的锁。</li></ul><a href=#3-锁的不同角度分类><h2 id=3-锁的不同角度分类><span class=hanchor arialabel=Anchor># </span>3 锁的不同角度分类</h2></a><p><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118133144.png width=auto alt></p><a href=#31-从数据操作的类型划分读锁写锁><h3 id=31-从数据操作的类型划分读锁写锁><span class=hanchor arialabel=Anchor># </span>3.1 从数据操作的类型划分：读锁、写锁</h3></a><p>对于数据库中并发事务的 读-读情况并不会引起什么问题。对于 写-写、读-写 或写-读这些情况可能会引起一些问题，需要使用 MVCC 或者 加锁的方式来解决它们。在使用加锁的方式解决问题时，由于既要允许 读-读情况不受影响，又要使 写-写、读-写 或写-读情况中的操作 相互阻塞，所以MysQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为 共享锁 (Shared Lock， s Lock）和排他锁 (ExClusive Lpck. x Lock)，<br>也叫 读锁 (readlock）和写锁 (write lock)。</p><p><strong>读锁</strong> ：也称为共享锁、英文用S表示。针对同一份数据，多个事务的读操作可以同时进行而不会<br>互相影响，相互不阻塞的。</p><p><strong>写锁</strong> ：也称为<strong>排他锁</strong>、英文用X表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样<br>就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</p><blockquote><p>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。</p></blockquote><p><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118151341.png width=auto alt><br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118151349.png width=auto alt><br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118151432.png width=auto alt><br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118151841.png width=auto alt><br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118152101.png width=auto alt></p><a href=#32-从数据操作的粒度划分表级锁页级锁行锁><h3 id=32-从数据操作的粒度划分表级锁页级锁行锁><span class=hanchor arialabel=Anchor># </span>3.2 从数据操作的粒度划分：表级锁、页级锁、行锁</h3></a><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，<strong>但是管理锁是很 耗资源的事情（涉及获取、检查、释放锁等动作）。因此数据库系统需要在高并发响应 和 系统性能 两方面进行平衡，这样就产生了“锁粒度 (Lock granularity)”的概念</strong><br>对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细;其实一个事务也可以在 表级别进行加锁，自然就被称之为 表级锁 或者 表锁，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。锁的粒度主要分为表级锁、页级锁和行锁。</p><a href=#表锁table-lock><h4 id=表锁table-lock><span class=hanchor arialabel=Anchor># </span>表锁（Table Lock）</h4></a><a href=#表级别的s锁x锁><h5 id=表级别的s锁x锁><span class=hanchor arialabel=Anchor># </span>表级别的S锁、X锁</h5></a><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的S锁或者X锁的。在对某个表执行一些诸如ALTER TABLE 、DROP TABLE这类的 DDL 语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行DDL语句也会发生阻塞。<strong>这个过程其实是通过在 server层使用一种称之为元数据锁（英文名： Metadata Locks ，简称 MDL ）结构来实现的</strong>。<br>一般情况下，不会使用InnoDB存储引擎提供的表级别的 S锁 和 X锁 。只会在一些特殊情况下，比方说<strong>崩溃恢复</strong>过程中用到。比如，在系统变量 autocommit=0，innodb_table_locks = 1 时， 手动 获取InnoDB存储引擎提供的表t的S锁或者X锁可以这么写：<code>LOCK TABLES t READ</code> ：InnoDB存储引擎会对表 t 加表级别的 S锁 。<code>LOCK TABLES t WRITE</code> ：InnoDB存储引擎会对表t加表级别的X锁 。不过尽量避免在使用InnoDB存储引擎的表上使用 LOCK TABLES 这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的行锁 ，关于InnoDB表级别的S锁和X锁大家了解一下就可以了。<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118152455.png width=auto alt></p><a href=#意向锁-intention-lock><h5 id=意向锁-intention-lock><span class=hanchor arialabel=Anchor># </span>意向锁 （intention lock）</h5></a><p>InnoDB 支持多粒度锁（multiple granularity locking），它允许行级锁与表级锁共存，而<strong>意向锁就是其中的一种表锁</strong>。</p><ul><li>意向锁的存在是为了<strong>协调行锁和表锁的关系</strong>，支持多粒度 （表锁与行锁）的锁并存。</li><li>意向锁是一种 不与行级锁冲突表级锁，这一点非常重要。</li><li>表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</li></ul><p>意向锁分为两种：</p><ol><li>意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁）</li><li>意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁）</li></ol><p>即：<strong>意向锁是由存储引擎自己维护的，用户无法手动操作意向锁</strong>，在为数据行加共享/排他锁之前，InooDB 会先获取该数据行所在数据表的对应意向锁。</p><blockquote><p>意向锁要解决的问题<br>现在有两个事务，分别是T1和72，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁;如果存在意向锁，那么此时就会受到由T1控制的表级别意向锁的阻塞。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。简单来说<strong>就是给更大一级别的空间示意里面是否已经上过锁</strong>。<br>在数据表的场景中，如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表己经有人上过排它锁了，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。<br>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁。<br>如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上添加意向排他锁。<br>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。</p></blockquote><blockquote><p>意向锁的并发性:<br>意向锁不会与行级的共享/排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。（不然我们直接用普通的表锁就行了）</p></blockquote><p>从上面的案例可以得到如下结论：<br>1. InnoDB 支持 多粒度锁 ，特定场景下，行级锁可以与表级锁共存。<br>2. 意向锁之间互不排斥，但<strong>除了IS与S兼容外，意向锁会与共享锁/排他锁互斥</strong>。<br>3. IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。<br>4. 意向锁在保证并发性的前提下，<strong>实现了行锁和表锁共存且满足事务隔离性的要求</strong>。</p><a href=#自增锁auto-inc锁><h5 id=自增锁auto-inc锁><span class=hanchor arialabel=Anchor># </span>自增锁（AUTO-INC锁）</h5></a><p>在使用MySQL过程中，我们可以为表的某个列添加 AUTO_INCREMENT 属性。举例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=w>        </span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>teacher</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=no>NULL</span><span class=w> </span><span class=kp>AUTO_INCREMENT</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>`</span><span class=n>name</span><span class=o>`</span><span class=w> </span><span class=kt>varchar</span><span class=p>(</span><span class=mi>255</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=no>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>)</span><span class=w> </span><span class=kp>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=kp>CHARSET</span><span class=o>=</span><span class=n>utf8mb4</span><span class=w> </span><span class=k>COLLATE</span><span class=o>=</span><span class=n>utf8mb4_0900_ai_ci</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改:<code>INSERT INTO teacher (name) VALUES ('zhangsan'), ('lisi');</code></p><p>上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值.现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是“ Simple inserts ”，“ Bulk inserts ”和“ Mixed-mode inserts ”。</p><ol><li><p>“Simple inserts” （简单插入）<br>可以 预先确定要插入的行数 （当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行INSERT…VALUES() 和 REPLACE 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行数。</p></li><li><p>“Bulk inserts” （批量插入）<br>事先不知道要插入的行数 （和所需自动递增值的数量）的语句。比如 INSERT … SELECT ， REPLACE … SELECT 和 LOAD DATA 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。</p></li><li><p>“Mixed-mode inserts” （混合模式插入）<br>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如 INSERT INTO teacher (id,name) VALUES (1,&lsquo;a&rsquo;), (NULL,&lsquo;b&rsquo;), (5,&lsquo;c&rsquo;), (NULL,&rsquo;d&rsquo;); <strong>只是指定了部分id的值</strong>。另一种类型的“混合模式插入”是 INSERT … ON DUPLICATE KEY UPDATE 。<br><strong>对于上面数据插入的案例，MysQL中采用了自增锁的方式来实现</strong>，AUTO-INC锁是当向使用含有AUTO_INCREMENT列的表中插入数据时需要获取的一种特殊的<strong>表级锁</strong>，在执行插入语句时就在表级别加一个AUTO-NC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分 配递增的值，在该语句执行结束后，再把AUTO-INC锁释放掉。一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞，<strong>可以保证一个语句中分配的递增值是连续的</strong>。也正因为此，其并发性显然并不高，当我们向一个有AUTO_INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争，这样的并发潜力其实是很低下的，所以innodb通过 innodb_autoinc-lock_mode的不同取值来提供不同的锁定机制，来显著提高SQL语句的可伸缩性和性能。</p><p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</p><ol><li>innodb_autoinc_lock_mode = 0(“传统”锁定模式)<br>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会 限制并发 能力。</li><li>innodb_autoinc_lock_mode = 1(“连续”锁定模式)<br>在 MySQL 8.0 之前，连续锁定模式是默认的。在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT … SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。对于“Simple inserts”（要插入的行数事先已知），则通过在 <strong>mutex（轻量锁） 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁</strong>，它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。<strong>如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”</strong>。</li><li>innodb_autoinc_lock_mode = 2(“交错”锁定模式)<br>从 MySQL 8.0 开始，交错锁模式是 默认 设置。<br>在这种锁定模式下，所有类INSERT语句都不会使用表级AUTO-INC 锁，并且可以同时执行多个语向。这是最快和最可扩展的锁定模式，但是当使用基于语句的复制或恢复方案时，从二进制日志重播SQL语句时，这是不安全的。</li></ol><p>在此锁定模式下，自动递增值保证在所有并发执行的所有类型的insert语向中是唯一旦单调递增的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），为任何给定语句插入的行生成的值可能不是连续的。<br>如果执行的语句是“simple inserts”，其中要插入的行数已提前知道，除了“Mixed-mode inserts°之外，为单个语句生成的数字不会有间隙。然而，当执行“bulk inserts"时，在由任何给定语向分配的自动递增值中可能存在间隙。</p></li></ol><a href=#元数据锁mdl锁><h5 id=元数据锁mdl锁><span class=hanchor arialabel=Anchor># </span>元数据锁（MDL锁）</h5></a><p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个 表结构做变更 ，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。<strong>因此，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁</strong>。<br>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。 不需要显式使用，在访问一个表的时候会被自动加上。</p><a href=#行锁-innodb><h4 id=行锁-innodb><span class=hanchor arialabel=Anchor># </span>行锁 InnoDB</h4></a><p>行锁 （Row Lock） 也称为记录锁，顾名思义，就是锁住某一行(某条记录row）。需要的注意的是，MysQL 服务器层并没有实现行锁机制，行级锁只在存储引擎层实现。<br>优点：锁定力度小，发生锁冲突概率低，可以实现的并发度高。<br>缺点：对于锁的开销比较大，加锁会比较慢，容易出现死锁情况。<br><strong>InnoDB与MyISAM的最大不同有两点：一是支持事务 (TRANSACTION)；二是采用了行级锁。</strong></p><a href=#记录锁record-locks><h5 id=记录锁record-locks><span class=hanchor arialabel=Anchor># </span>记录锁（Record Locks）</h5></a><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为： LOCK_REC_NOT_GAP 。比如我们把id值为8的那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118163401.png width=auto alt><br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118163413.png width=auto alt><br>记录锁是有S锁和X锁之分的，称之为 S型记录锁 和 X型记录锁 。<br>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；<br>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</p><a href=#间隙锁gap-locks><h5 id=间隙锁gap-locks><span class=hanchor arialabel=Anchor># </span>间隙锁（Gap Locks）</h5></a><p>MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方案解决，也可以采用 加锁 方案解决。但是在使用加锁方案解决时有个大问题，就<strong>是事务在第一次执行读取操作时，那些幻影记录尚不存在</strong>，我们无法给这些 幻影记录 加上 记录锁 。InnoDB提出了一种称之为Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们可以简称为 gap锁 。比如，把id值为8的那条记录加一个gap锁的示意图如下。<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118163606.png width=auto alt><br>图中id值为8的记录加了gap锁，意味着 不允许别的事务在id值为8的记录前边的间隙插入新记录 ，其实就是id列的值(3, 8)这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为4的新记录，它定位到该条新记录的下一条记录的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。</p><p><strong>gap锁的提出仅仅是为了防止插入幻影记录而提出的。</strong></p><a href=#临键锁next-key-locks><h5 id=临键锁next-key-locks><span class=hanchor arialabel=Anchor># </span>临键锁（Next-Key Locks）</h5></a><p><strong>有时候我们既想锁住某条记录 ，又想阻止其他事务在该记录前边的间隙插入新记录</strong> ，所以InnoDB就提出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY ，我们也可以简称为next-key锁 。Next-Key Locks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁，innodb默认的锁就是Next-Key locks。<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118165242.png width=auto alt></p><p>next-key锁 的本质就是一个
<a rel=noopener class="internal-link broken" data-src=#%e8%ae%b0%e5%bd%95%e9%94%81%ef%bc%88Record%20Locks%ef%bc%89>记录锁（Record Locks）</a>和一个
<a rel=noopener class="internal-link broken" data-src=#%e9%97%b4%e9%9a%99%e9%94%81%ef%bc%88Gap%20Locks%ef%bc%89>间隙锁（Gap Locks）</a>的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。</p><a href=#插入意向锁insert-intention-locks><h5 id=插入意向锁insert-intention-locks><span class=hanchor arialabel=Anchor># </span>插入意向锁（Insert Intention Locks）</h5></a><p>我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了gap锁（next-key锁也包含 gap锁 ），如果有的话，<strong>插入操作需要等待，直到拥有gap锁的那个事务提交</strong>。但是InnoDB规定<strong>事务在等待的时候也需要在内存中生成一个锁结构</strong>，表明有事务想在某个间隙 中插入新记录，但是现在在等待。InnoDB就把这种类型的锁命名为 Insert Intention Locks ，官方的类型名称为：LOCK_INSERT_INTENTION ，我们称为 插入意向锁 。插入意向锁是一种 Gap锁 ，不是意向锁，在insert操作时产生。</p><p>插入意向锁是在插入一条记录行前，由 INSERT 操作产生的一种间陳锁。该锁用以表示插入意向，当多个事务在同一区间(gap） 插入位置不同的多条数据时，事务之间不需要互相等待。假设存在两条值分别为4和7的记录，两个不同的事务分别试图插入值为 5和6的两条记录，每个事务在获取插入行上独占的（排他）锁前，都会获取（4， 7）之间的间隙锁，但是因为数据行之间并 不冲突，所以两个事务之间并不会产生冲突(阻塞等待）。<br>总结来说，插入意向锁的特性可以分成两部分：</p><ul><li>插入意向锁是一种特殊的间隙锁 一—间隙锁可以锁定开区间内的部分记录。</li><li>入意向锁之间 互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身（主键、唯一索引不冲突，那么事务之间就不会出现冲突等待。<br>注意，<strong>虽然插入意向锁中含有意向锁三个字，但是它并不属于意向锁而属于间隙锁，因为意向锁是表锁而插入意向锁是行锁</strong>。<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118171107.png width=auto alt><br>从图中可以看到，由于丁1持有gap锁，所以T2和丁3需要生成一个插入意向锁的锁结构并且处于等待状态。当T1提交后会把它获取到的锁都释放掉，这样T2和丁3就能获取到对应的插入意向锁了 （本质上就是把插入意向锁对应锁结构的is_ waiting属性改为false），T2和T3之间也并不会相互阻塞，它们可以同时获取到id值为s的插入意向锁，然后执行插入操作。</li></ul><p>插入意向锁是在插入一条记录行前，由 INSERT 操作产生的一种间隙锁。事实上插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</p><a href=#页锁><h4 id=页锁><span class=hanchor arialabel=Anchor># </span>页锁</h4></a><p>页锁就是在页的粒度上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。<strong>页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般</strong>。<br>每个层级的锁数量是有限制的，因为锁会占用内存空间，锁空间的大小是有限的。当某个层级的锁数量超过了这个层级的阈值时，就会进行锁升级。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p><a href=#33-从对待锁的态度划分乐观锁悲观锁><h3 id=33-从对待锁的态度划分乐观锁悲观锁><span class=hanchor arialabel=Anchor># </span>3.3 从对待锁的态度划分:乐观锁、悲观锁</h3></a><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待数据并发的思维方式。需要注意的是，<strong>乐观锁和悲观锁并不是锁，而是锁的设计思想</strong>。</p><a href=#1-悲观锁pessimistic-locking><h4 id=1-悲观锁pessimistic-locking><span class=hanchor arialabel=Anchor># </span>1 悲观锁（Pessimistic Locking）</h4></a><p>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。<strong>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）</strong>。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中 synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。</p><p><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118171652.png width=auto alt><br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118171708.png width=auto alt><br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118171740.png width=auto alt></p><a href=#2-乐观锁optimistic-locking><h4 id=2-乐观锁optimistic-locking><span class=hanchor arialabel=Anchor># </span>2 乐观锁（Optimistic Locking）</h4></a><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是不采用数据库自身的锁机制，而是通过程序来实现。在程序上，<strong>我们可以采用版本号机制或者CAS机制实现</strong>。乐观锁适用于多读的应用类型，这样可以提高吞吐量。在Java中java.util.concurrent.atomic包下的原子变量类就是使用了乐观锁的CAS实现的。</p><p><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118172152.png width=auto alt><br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118172223.png width=auto alt><br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221118172310.png width=auto alt><br>Version:0.9 StartHTML:0000000105 EndHTML:0000003877 StartFragment:0000000141 EndFragment:0000003837</p><a href=#3-两种锁的适用场景><h4 id=3-两种锁的适用场景><span class=hanchor arialabel=Anchor># </span>3 两种锁的适用场景</h4></a><p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p><ol><li>乐观锁 适合 读操作多 的场景，相对来说写的操作比较少。它的优点在于 程序实现 ， 不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</li><li>悲观锁 适合 写操作多 的场景，因为写的操作具有 排它性 。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止 读 - 写 和 写 - 写 的冲突。</li></ol><a href=#34-按加锁的方式划分显式锁隐式锁><h3 id=34-按加锁的方式划分显式锁隐式锁><span class=hanchor arialabel=Anchor># </span>3.4 按加锁的方式划分：显式锁、隐式锁</h3></a><a href=#1-隐式锁><h4 id=1-隐式锁><span class=hanchor arialabel=Anchor># </span>1 隐式锁</h4></a><p><img src=https://jieye-ericx.github.io//Pasted%20image%2020221119111250.png width=auto alt><br>（也就是为自己也创建一个锁结构， is_waiting 属性是 true ）。</p><p>情景二：对于二级索引记录来说，本身并没有 trx_id 隐藏列，但是在二级索引页面的 Page Header 部分有一个 PAGE_MAX_TRX_ID 属性，该属性代表对该页面做改动的最大的 事务id ，如果 PAGE_MAX_TRX_ID 属性值小于当前最小的活跃 事务id ，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复 情景一 的做法。</p><p><img src=https://jieye-ericx.github.io//Pasted%20image%2020221119111433.png width=auto alt></p><p>隐式锁的逻辑过程如下：<br>A. InnoDB的每条记录中都一个隐含的trx_id字段，这个字段存在于聚簇索引的B+Tree中。<br>B. 在操作一条记录前，首先根据记录中的trx_id检查该事务是否是活动的事务(未提交或回滚)。如果是活动的事务，首先将 隐式锁 转换为 显式锁 (就是为该事务添加一个锁)。<br>C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为waiting状态。如果没有冲突不加锁，跳到E。<br>D. 等待加锁成功，被唤醒，或者超时。<br>E. 写数据，并将自己的trx_id写入trx_id字段。</p><a href=#2-显式锁><h4 id=2-显式锁><span class=hanchor arialabel=Anchor># </span>2 显式锁</h4></a><p>通过特定的语句进行加锁，我们一般称之为显示加锁，例如：<br>显示加共享锁：<br><code>select …. lock in share mode</code><br>显示加排它锁：<br><code>select …. for update</code></p><a href=#35-其它锁之全局锁><h3 id=35-其它锁之全局锁><span class=hanchor arialabel=Anchor># </span>3.5 其它锁之：全局锁</h3></a><p>全局锁就是对 整个数据库实例 加锁。当你需要让整个库处于 只读状态 的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用 场景 是：做 <strong>全库逻辑备份</strong> 。<br>全局锁的命令：<code>Flush tables with read lock</code></p><a href=#占坑-死锁><h3 id=占坑-死锁><span class=hanchor arialabel=Anchor># </span>占坑 死锁</h3></a><a href=#4-锁的内存结构><h2 id=4-锁的内存结构><span class=hanchor arialabel=Anchor># </span>4 锁的内存结构</h2></a><p><img src=https://jieye-ericx.github.io//Pasted%20image%2020221120003952.png width=auto alt><br>InnoDB存储引擎中的锁结构如下：<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221120003933.png width=auto alt><br><strong>结构解析：</strong></p><ol><li>锁所在的事务信息：不论是表锁还是行锁，都是在事务执行过程中生成的，哪个事务生成了这个锁结构 ，这里就记录这个事务的信息。此锁所在的事务信息在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</li><li>索引信息：对于行锁来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</li><li>表锁／行锁信息 ：表锁结构和行锁结构在这个位置的内容是不同的：<br>表锁：记载着是对哪个表加的锁，还有其他的一些信息。<br>行锁：记载了三个重要的信息：<ul><li>Space ID ：记录所在表空间。</li><li>Page Number ：记录所在页号。</li><li>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits 属性代表使用了多少比特位。<strong>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后也不至于重新分配锁结构</strong></li></ul></li><li>type_mode：这是一个32位的数，被分成了 lock_mode 、 lock_type 和 rec_lock_type 三个部分，如图所示：<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221120005201.png width=auto alt><ul><li>锁的模式（ lock_mode ），占用低4位，可选的值如下：<br>LOCK_IS （十进制的 0 ）：表示共享意向锁，也就是 IS锁 。<br>LOCK_IX （十进制的 1 ）：表示独占意向锁，也就是 IX锁 。<br>LOCK_S （十进制的 2 ）：表示共享锁，也就是 S锁 。<br>LOCK_X （十进制的 3 ）：表示独占锁，也就是 X锁 。<br>LOCK_AUTO_INC （十进制的 4 ）：表示 AUTO-INC锁 。<br>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</li><li>锁的类型（ lock_type ），占用第5～8位，不过现阶段只有第5位和第6位被使用:<br>LOCK_TABLE （十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。LOCK_REC （十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。</li><li>行锁的具体类型（ rec_lock_type ），使用其余的位来表示。只有在 lock_type 的值为LOCK_REC 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<br>LOCK_ORDINARY （十进制的 0 ）：表示 next-key锁 。<br>LOCK_GAP （十进制的 512 ）：也就是当第10个比特位置为1时，表示 gap锁 。 LOCK_REC_NOT_GAP （十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经 记录 锁 。<br>LOCK_INSERT_INTENTION （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li><li>is_waiting 属性呢？基于内存空间的节省，所以把 is_waiting 属性放到了 type_mode 这个32位的数字中：<br>LOCK_WAIT （十进制的 256 ） ：当第9个比特位置为 1 时，表示is_waiting 为 true ，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示 is_waiting 为 false ，也就是当前事务获取锁成功。</li></ul></li><li>其他信息：<br>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</li><li>一堆比特位：<br>如果是行锁结构的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 n_bits 属性表示的。InnoDB数据页中的每条记录在 记录头信息 中都包含一个 heap_no属性，伪记录 Infimum 的 heap_no 值为 0 ， Supremum 的 heap_no 值为 1 ，之后每插入一条记录， heap_no 值就增1。 锁结 构 最后的一堆比特位就对应着一个页面中的录，一个比特位映射一个 heap_no ，即一个比特位映射到页内的一条记录。</li></ol><a href=#5-锁监控><h2 id=5-锁监控><span class=hanchor arialabel=Anchor># </span>5 锁监控</h2></a><p>关于MySQL锁的监控，我们一般可以通过检查 InnoDB_row_lock 等状态变量来分析系统上的行锁的争夺情况:<code>show status like 'innodb_row_lock%';</code></p><p>对各个状态量的说明如下：<br>Innodb_row_lock_current_waits：当前正在等待锁定的数量；<br><strong>Innodb_row_lock_time</strong> ：从系统启动到现在锁定总时间长度；（等待总时长）<br><strong>Innodb_row_lock_time_avg</strong> ：每次等待所花平均时间；（等待平均时长）<br>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；<br><strong>Innodb_row_lock_waits</strong> ：系统启动后到现在总共等待的次数；（等待总次数）</p><p>其他监控方法：<br>MySQL把事务和锁的信息记录在了 information_schema 库中，涉及到的三张表分别是<br>INNODB_TRX 、 INNODB_LOCKS 和 INNODB_LOCK_WAITS 。<br>MySQL5.7及之前 ，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。<br>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了performance_schema.data_locks ，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，<br>performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。<br>同时，information_schema.INNODB_LOCK_WAITS也被performance_schema.data_lock_waits 所代替。</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/Mysql-%E5%8E%9F%E7%90%86/ data-ctx="15 锁" data-src=/Mysql-%E5%8E%9F%E7%90%86 class=internal-link>Mysql 原理</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://jieye-ericx.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Jieye ericx using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://jieye-ericx.github.io/>Home</a></li><li><a href=https://github.com/jieye-ericx>Github</a></li></ul></footer></div></div></body></html>