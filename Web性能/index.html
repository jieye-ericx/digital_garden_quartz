<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="性能优化涉及到的分类  网络层面 构建层面 浏览器渲染层面 服务端层面  涉及到的功能点  资源的合并与压缩 图片编解码原理和类型选择 浏览器渲染机制 懒加载预加载 浏览器存储 缓存机制 PWA Vue-SSR  资源合并与压缩 http请求的过程及潜在的性能优化点  理解减少http请求数量和减少请求资源大小两个优化要点 掌握压缩与合并的原理 掌握通过在线网站和fis3两种实现压缩与合并的方法  浏览器的一个请求从发送到返回都经历了什么 动态的加载静态的资源"><meta property="og:title" content="Web性能"><meta property="og:description" content="性能优化涉及到的分类  网络层面 构建层面 浏览器渲染层面 服务端层面  涉及到的功能点  资源的合并与压缩 图片编解码原理和类型选择 浏览器渲染机制 懒加载预加载 浏览器存储 缓存机制 PWA Vue-SSR  资源合并与压缩 http请求的过程及潜在的性能优化点  理解减少http请求数量和减少请求资源大小两个优化要点 掌握压缩与合并的原理 掌握通过在线网站和fis3两种实现压缩与合并的方法  浏览器的一个请求从发送到返回都经历了什么 动态的加载静态的资源"><meta property="og:type" content="website"><meta property="og:image" content="https://jieye-ericx.github.io/icon.png"><meta property="og:url" content="https://jieye-ericx.github.io/Web%E6%80%A7%E8%83%BD/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="Web性能"><meta name=twitter:description content="性能优化涉及到的分类  网络层面 构建层面 浏览器渲染层面 服务端层面  涉及到的功能点  资源的合并与压缩 图片编解码原理和类型选择 浏览器渲染机制 懒加载预加载 浏览器存储 缓存机制 PWA Vue-SSR  资源合并与压缩 http请求的过程及潜在的性能优化点  理解减少http请求数量和减少请求资源大小两个优化要点 掌握压缩与合并的原理 掌握通过在线网站和fis3两种实现压缩与合并的方法  浏览器的一个请求从发送到返回都经历了什么 动态的加载静态的资源"><meta name=twitter:image content="https://jieye-ericx.github.io/icon.png"><title>Web性能</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://jieye-ericx.github.io//icon.png><link href=https://jieye-ericx.github.io/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://jieye-ericx.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://jieye-ericx.github.io/js/darkmode.48459b7116d092b4e98d2cab704cad80.min.js></script>
<script src=https://jieye-ericx.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://jieye-ericx.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://jieye-ericx.github.io/",fetchData=Promise.all([fetch("https://jieye-ericx.github.io/indices/linkIndex.a91535da5bc472c24479fcf5acf89c4d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://jieye-ericx.github.io/indices/contentIndex.d2e25530f3ca3ecf62396d5270cd9539.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://jieye-ericx.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://jieye-ericx.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/jieye-ericx.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=jieye-ericx.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://jieye-ericx.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://jieye-ericx.github.io/>jieye の 数字花园</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Web性能</h1><p class=meta>Last updated
Aug 19, 2022</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#性能优化涉及到的分类>性能优化涉及到的分类</a></li><li><a href=#涉及到的功能点>涉及到的功能点</a></li><li><a href=#资源合并与压缩>资源合并与压缩</a><ol><li><a href=#http请求的过程及潜在的性能优化点><code>http</code>请求的过程及潜在的性能优化点</a></li><li><a href=#html压缩><code>html</code>压缩</a></li><li><a href=#css及js压缩><code>css</code>及<code>js</code>压缩</a></li><li><a href=#不合并文件可能存在的问题>不合并文件可能存在的问题</a></li><li><a href=#cdn减少打包体积>CDN减少打包体积</a></li><li><a href=#去除-sourcemap>去除 SourceMap</a></li><li><a href=#gzip-压缩>gzip 压缩</a></li></ol></li><li><a href=#图片相关优化>图片相关优化</a><ol><li><a href=#一张jpg的解析过程>一张<code>JPG</code>的解析过程</a></li><li><a href=#png8png24png32之间的区别><code>png8</code>/<code>png24</code>/<code>png32</code>之间的区别</a></li><li><a href=#不同的格式图片常用的业务场景>不同的格式图片常用的业务场景</a></li><li><a href=#图片压缩的几种情况>图片压缩的几种情况</a></li></ol></li><li><a href=#css和js的装载与执行>css和js的装载与执行</a><ol><li><a href=#html页面加载渲染的过程>HTML页面加载渲染的过程</a></li><li><a href=#html渲染过程中的一些特点>HTML渲染过程中的一些特点</a></li></ol></li><li><a href=#懒加载与预加载>懒加载与预加载</a><ol><li><a href=#懒加载>懒加载</a></li><li><a href=#预加载>预加载</a></li><li><a href=#懒加载原生js和zeptolazyload>懒加载原生<code>js</code>和<code>zepto.lazyload</code></a></li><li><a href=#预加载原生js和preloadjs实现>预加载原生<code>js</code>和<code>preloadJS</code>实现</a></li></ol></li><li><a href=#重绘与回流>重绘与回流</a><ol><li><a href=#css性能让javascript变慢><code>css</code>性能让<code>javascript</code>变慢</a></li><li><a href=#什么是重绘和回流>什么是重绘和回流</a></li><li><a href=#避免重绘回流的两种方法>避免重绘、回流的两种方法</a></li><li><a href=#浏览器绘制dom的过程是这样子的>浏览器绘制<code>DOM</code>的过程是这样子的：</a></li><li><a href=#实战优化点总结>实战优化点总结</a></li></ol></li><li><a href=#缓存>缓存</a><ol><li><a href=#强缓存>强缓存</a></li><li><a href=#协商缓存>协商缓存</a></li><li><a href=#总结-1>总结</a></li><li><a href=#httpheader>httpheader</a></li><li><a href=#expires-1>Expires</a></li><li><a href=#last-modified和if-modified-since-1>Last-modified和If-Modified-since</a></li><li><a href=#etag和-if-none-match>Etag和 If-none-match</a></li><li><a href=#service-worker>Service Worker</a></li><li><a href=#缓存流程图>缓存流程图</a></li></ol></li><li><a href=#服务端性能优化>服务端性能优化</a><ol><li><a href=#vue渲染面临的问题>vue渲染面临的问题</a></li><li><a href=#多层次的优化方案>多层次的优化方案</a></li></ol></li><li><a href=#web性能监控>Web性能监控</a><ol><li><a href=#1-页面访问速度白屏首屏时间可交互时间>1. 页面访问速度：白屏、首屏时间、可交互时间</a></li><li><a href=#2-页面稳定性页面出错情况>2. 页面稳定性：页面出错情况</a></li><li><a href=#3-外部服务调用>3. 外部服务调用</a></li><li><a href=#监控的分类>监控的分类？</a></li><li><a href=#performance-分析>performance 分析</a></li><li><a href=#如何监控>如何监控？</a></li></ol></li></ol></nav></details></aside><a href=#性能优化涉及到的分类><h2 id=性能优化涉及到的分类><span class=hanchor arialabel=Anchor># </span>性能优化涉及到的分类</h2></a><ul><li>网络层面</li><li>构建层面</li><li>浏览器渲染层面</li><li>服务端层面</li></ul><a href=#涉及到的功能点><h2 id=涉及到的功能点><span class=hanchor arialabel=Anchor># </span>涉及到的功能点</h2></a><ul><li>资源的合并与压缩</li><li>图片编解码原理和类型选择</li><li>浏览器渲染机制</li><li>懒加载预加载</li><li>浏览器存储</li><li>缓存机制</li><li><code>PWA</code></li><li><code>Vue-SSR</code></li></ul><a href=#资源合并与压缩><h2 id=资源合并与压缩><span class=hanchor arialabel=Anchor># </span>资源合并与压缩</h2></a><a href=#http请求的过程及潜在的性能优化点><h3 id=http请求的过程及潜在的性能优化点><span class=hanchor arialabel=Anchor># </span><code>http</code>请求的过程及潜在的性能优化点</h3></a><ul><li>理解<code>减少http请求数量</code>和<code>减少请求资源大小</code>两个优化要点</li><li>掌握<code>压缩</code>与<code>合并</code>的原理</li><li>掌握通过<code>在线网站</code>和<code>fis3</code>两种实现压缩与合并的方法</li></ul><a href=#浏览器的一个请求从发送到返回都经历了什么><h4 id=浏览器的一个请求从发送到返回都经历了什么><span class=hanchor arialabel=Anchor># </span>浏览器的一个请求从发送到返回都经历了什么</h4></a><p>动态的加载静态的资源</p><ul><li><code>dns</code>是否可以通过缓存减少<code>dns</code>查询时间</li><li>网络请求的过程走最近的网络环境</li><li>相同的静态资源是否可以缓存</li><li>能否减少<code>http</code>请求大小</li><li>能否减少<code>http</code>请求数量</li><li>服务端渲染</li></ul><a href=#资源的合并与压缩设计到的性能点><h4 id=资源的合并与压缩设计到的性能点><span class=hanchor arialabel=Anchor># </span>资源的合并与压缩设计到的性能点</h4></a><ul><li>减少<code>http</code>请求的数量</li><li>减少请求的大小</li></ul><a href=#html压缩><h3 id=html压缩><span class=hanchor arialabel=Anchor># </span><code>html</code>压缩</h3></a><blockquote><p><code>HTML</code>代码压缩就是压缩这些在文本文件中有意义，但是在<code>HTML</code>中不显示的字符，包括<code>空格</code>,<code>制表符</code>,<code>换行符</code>等，还有一些其他意义的字符，如<code>HTML</code>注释也可以被压缩</p></blockquote><blockquote><p>意义</p></blockquote><ul><li>大型网站意义比较大</li></ul><a href=#如何进行html的压缩><h4 id=如何进行html的压缩><span class=hanchor arialabel=Anchor># </span>如何进行<code>html</code>的压缩</h4></a><ul><li>使用在线网站进行压缩(走构建工具多，公司级在线网站手动压缩小)</li><li><code>node.js</code>提供了<code>html-minifier</code>工具</li><li>后端<code>模板引擎渲染压缩</code></li></ul><a href=#css及js压缩><h3 id=css及js压缩><span class=hanchor arialabel=Anchor># </span><code>css</code>及<code>js</code>压缩</h3></a><a href=#css的压缩><h4 id=css的压缩><span class=hanchor arialabel=Anchor># </span><code>css</code>的压缩</h4></a><ul><li>无效代码删除<ul><li>注释、无效字符</li></ul></li><li><code>css</code>语义合并</li></ul><p><strong>压缩的方式</strong></p><ul><li>使用在线网站进行压缩</li><li>webpack使用<code>optimize-css-assets-webpack-plugin</code> <code>HtmlWebpackPlugin</code></li><li>使用<code>html-minifier</code>对<code>html</code>中的<code>css</code>进行压缩</li><li>使用<code>clean-css</code>对<code>css</code>进行压缩</li></ul><a href=#js的压缩与混乱><h4 id=js的压缩与混乱><span class=hanchor arialabel=Anchor># </span><code>js</code>的压缩与混乱</h4></a><ul><li>无效字符的删除<ul><li>空格、注释、回车等</li></ul></li><li>webpack 自动压缩</li><li>剔除注释</li><li>代码语意的缩减和优化<ul><li>变量名缩短(<code>a</code>,<code>b</code>)等</li></ul></li><li>代码保护<ul><li>前端代码是透明的，客户端代码用户是可以直接看到的，可以轻易被窥探到逻辑和漏洞</li></ul></li></ul><a href=#js压缩的方式><h4 id=js压缩的方式><span class=hanchor arialabel=Anchor># </span><code>js</code>压缩的方式</h4></a><ul><li>使用在线网站进行压缩</li><li>使用<code>html-minifier</code>对<code>html</code>中的<code>js</code>进行压缩</li><li>使用<code>uglifyjs2</code>对<code>js</code>进行压缩</li></ul><a href=#不合并文件可能存在的问题><h3 id=不合并文件可能存在的问题><span class=hanchor arialabel=Anchor># </span>不合并文件可能存在的问题</h3></a><ul><li>文件与文件有插入之间的上行请求，又增加了<code>N-1</code>个网络延迟</li><li>受丢包问题影响更严重</li><li>经过代理服务器时可能会被断开</li></ul><a href=#文件合并缺点><h4 id=文件合并缺点><span class=hanchor arialabel=Anchor># </span>文件合并缺点</h4></a><ul><li>首屏渲染问题<ul><li>文件合并之后的<code>js</code>变大，如果首页的渲染依赖这个<code>js</code>的话，整个页面的渲染要等<code>js</code>请求完才能执行</li><li>如果首屏只依赖<code>a.js</code>，只要等<code>a.js</code>完成后就可执行</li><li>没有通过服务器端渲染，现在框架都需要等合并完的文件请求完才能执行，基本都需要等文件合并后的<code>js</code></li></ul></li><li>缓存失效问题<ul><li>标记 <code>js</code> <code>md5</code>戳</li><li>合并之后的<code>js</code>,任何一个改动都会导致大面积的缓存失效</li></ul></li></ul><a href=#文件合并对应缺点的处理><h4 id=文件合并对应缺点的处理><span class=hanchor arialabel=Anchor># </span>文件合并对应缺点的处理</h4></a><ul><li>公共库合并</li><li>不同页面的合并<ul><li>不同页面<code>js</code>单独打包</li></ul></li><li>见机行事，随机应变</li></ul><a href=#文件合并对应方法><h4 id=文件合并对应方法><span class=hanchor arialabel=Anchor># </span>文件合并对应方法</h4></a><ul><li>使用在线网站进行合并</li><li>构建阶段，使用<code>nodejs</code>进行文件合并</li></ul><a href=#cdn减少打包体积><h3 id=cdn减少打包体积><span class=hanchor arialabel=Anchor># </span>CDN减少打包体积</h3></a><p>使用 <code>cdn</code> 文件来减少工程到打包体积，也可以按需加载。</p><p>在 /public/index.html 中引入需要的js和css文件</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184258.png width=auto alt=img></p><p>去掉 package.json 中对于 vue、element-ui 等相关资源的依赖</p><p>src/main.js ，去掉 vue、element-ui 等相关资源的 import 和 vue.use 这些语句</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184259.png width=auto alt=img></p><p>配置externals。由于使用 Vue Cli 3 默认配置，新建出来的项目没有了 build 目录，首先得在项目根目录下，新建 vue.config.js 文件，里面添加以下代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>module.exports = {
</span></span><span class=line><span class=cl>    configureWebpack:{
</span></span><span class=line><span class=cl>        externals:{
</span></span><span class=line><span class=cl>            &#39;Vue&#39;: &#39;Vue&#39;,
</span></span><span class=line><span class=cl>            &#39;element-ui&#39;: &#39;element-ui&#39;,
</span></span><span class=line><span class=cl>            &#39;clipboard&#39;:&#39;VueClipboard&#39;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#去除-sourcemap><h3 id=去除-sourcemap><span class=hanchor arialabel=Anchor># </span>去除 SourceMap</h3></a><p>由于打包后的文件经过了压缩、合并、混淆、babel编译后的代码不利于定位分析bug。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>module.exports = {
</span></span><span class=line><span class=cl>  productionSourceMap: false,
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#gzip-压缩><h3 id=gzip-压缩><span class=hanchor arialabel=Anchor># </span>gzip 压缩</h3></a><p><code>gzip</code> 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>//npm i -D compression-webpack-plugin
</span></span><span class=line><span class=cl>configureWebpack: config =&gt; {
</span></span><span class=line><span class=cl>  const CompressionPlugin = require(&#39;compression-webpack-plugin&#39;)
</span></span><span class=line><span class=cl>  config.plugins.push(new CompressionPlugin())
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#图片相关优化><h2 id=图片相关优化><span class=hanchor arialabel=Anchor># </span>图片相关优化</h2></a><a href=#一张jpg的解析过程><h3 id=一张jpg的解析过程><span class=hanchor arialabel=Anchor># </span>一张<code>JPG</code>的解析过程</h3></a><p><code>jpg</code>有损压缩：虽然损失一些信息，但是肉眼可见影响并不大</p><a href=#png8png24png32之间的区别><h3 id=png8png24png32之间的区别><span class=hanchor arialabel=Anchor># </span><code>png8</code>/<code>png24</code>/<code>png32</code>之间的区别</h3></a><ul><li><code>png8</code> &mdash;-<code>256色</code> + 支持透明</li><li><code>png24</code> &mdash;-<code>2^24</code> + 不支持透明</li><li><code>png32</code> &mdash;<code>2^24</code> +支持透明</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>文件大小`  +   `色彩丰富程度
</span></span></code></pre></td></tr></table></div></div><p><code>png32</code>是在<code>png24</code>上支持了透明，针对不同的业务场景选择不同的图片格式很重要</p><a href=#不同的格式图片常用的业务场景><h3 id=不同的格式图片常用的业务场景><span class=hanchor arialabel=Anchor># </span>不同的格式图片常用的业务场景</h3></a><a href=#不同格式图片的特点><h4 id=不同格式图片的特点><span class=hanchor arialabel=Anchor># </span>不同格式图片的特点</h4></a><ul><li><code>jpg</code>有损压缩，压缩率高，不支持透明</li><li><code>png</code>支持透明，浏览器兼容性好</li><li><code>webp</code>压缩程度更好，在<code>ios webview</code>中有兼容性问题</li><li><code>svg</code>矢量图，代码内嵌，相对较小，图片样式相对简单的场景(尽量使用，绘制能力有限，图片简单用的比较多)</li></ul><a href=#不同格式图片的使用场景><h4 id=不同格式图片的使用场景><span class=hanchor arialabel=Anchor># </span>不同格式图片的使用场景</h4></a><ul><li><code>jpg</code>：大部分不需要透明图片的业务场景</li><li><code>png</code>：大部分需要透明图片的业务场景</li><li><code>webp</code>：<code>android</code>全部(解码速度和压缩率高于<code>jpg</code>和<code>png</code>，但是<code>ios</code> <code>safari</code>还没支持)</li><li><code>svg</code>：图片样式相对简单的业务场景</li></ul><a href=#图片压缩的几种情况><h3 id=图片压缩的几种情况><span class=hanchor arialabel=Anchor># </span>图片压缩的几种情况</h3></a><ul><li>针对真实图片情况，舍弃一些相对无关紧要的色彩信息</li><li><code>CSS雪碧图</code>：把你的网站用到的一些图片整合到一张单独的图片中<ul><li>优点：减少<code>HTTP</code>请求的数量(通过<code>backgroundPosition</code>定位所需图片)</li><li>缺点：整合图片比较大时，加载比较慢(如果这张图片没有加载成功，整个页面会失去图片信息)<code>facebook</code>官网任然在用，主要<code>pc</code>用的比较多，相对性能比较强</li></ul></li><li><code>Image-inline</code>：将图片的内容嵌到<code>html</code>中(减少网站的<code>HTTP</code>请求)<ul><li><code>base64信息</code>，减少网站的HTTP请求,如果图片比较小比较多，时间损耗主要在请求的骨干网络</li></ul></li><li><code>使用矢量图</code><ul><li>使用<code>SVG</code>进行矢量图的绘制</li><li>使用<code>icon-font</code>解决<code>icon</code>问题</li></ul></li><li><code>在android下使用webp</code><ul><li><code>webp</code>的优势主要体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；</li><li>同时具备了无损和有损的压缩模式、<code>Alpha</code>透明以及动画的特性，在<code>JPEG</code>和<code>PNG</code>上的转化效果都非常优秀、稳定和统一</li></ul></li></ul><a href=#css和js的装载与执行><h2 id=css和js的装载与执行><span class=hanchor arialabel=Anchor># </span>css和js的装载与执行</h2></a><a href=#html页面加载渲染的过程><h3 id=html页面加载渲染的过程><span class=hanchor arialabel=Anchor># </span>HTML页面加载渲染的过程</h3></a><a href=#一个网站在浏览器端是如何进行渲染的><h4 id=一个网站在浏览器端是如何进行渲染的><span class=hanchor arialabel=Anchor># </span>一个网站在浏览器端是如何进行渲染的</h4></a><a href=#html渲染过程中的一些特点><h3 id=html渲染过程中的一些特点><span class=hanchor arialabel=Anchor># </span>HTML渲染过程中的一些特点</h3></a><ul><li>顺序执行，并发加载<ul><li>词法分析：从上到下依次解析<ul><li>通过<code>HTML</code>生成<code>Token对象</code>（当前节点的所有子节点生成后，才会通过<code>next token</code>获取到当前节点的兄弟节点），最终生成<code>Dom Tree</code></li></ul></li><li>并发加载：资源请求是并发请求的</li><li>并发上限<ul><li>浏览器中可以支持并发请求，不同浏览器所支持的并发数量不同（以域名划分），以<code>Chrome</code>为例，并发上限为6个</li><li>优化点： 把CDN资源分布在多个域名下</li></ul></li></ul></li><li>是否阻塞<ul><li><p>css阻塞</p><ul><li>css 在head中通过link引入会阻塞页面的渲染<ul><li>如果我们把<code>css</code>代码放在<code>head</code>中去引入的话，那么我们整个页面的渲染实际上就会等待<code>head</code>中<code>css</code>加载并生成<code>css树</code>，最终和<code>DOM</code>整合生成<code>RanderTree</code>之后才会进行渲染</li></ul></li><li>为了浏览器的渲染，能让页面显示的时候视觉上更好。 避免某些情况，如：假设你放在页面最底部，用户打开页面时，有可能出现，页面先是显示一大堆文字或图片，自上而下，丝毫没有排版和样式可言。最后，页面又恢复所要的效果</li></ul></li><li><p><code>css</code>不阻塞<code>js</code>的加载，但阻塞<code>js</code>的执行</p><ul><li><code>css</code>不阻塞外部脚步的加载(<code>webkit preloader 预资源加载器</code>)</li></ul></li><li><p>js阻塞</p><ul><li>直接通过&lt;script src>引入会阻塞后面节点的渲染<ul><li><code>html parse</code>认为<code>js</code>会动态修改文档结构(<code>document.write</code>等方式)，没有进行后面文档的变化</li><li>async defer(async放弃了依赖关系)<ul><li><code>defer</code>属性（<code>） (这是延迟执行引入的`js`脚本（即脚本加载是不会导致解析停止，等到`document`全部解析完毕后，`defer-script`也加载完毕后，在执行所有的`defer-script`加载的`js`代码，再触发`Domcontentloaded`）</code></li><li>async属性（&lt;script src="" async>&lt;/script>）<ul><li>这是异步执行引入的<code>js</code>脚本文件</li><li>与<code>defer</code>的区别是<code>async</code>会在加载完成后就执行，但是不会影响阻塞到解析和渲染。但是还是会阻塞<code>load</code>事件，所以<code>async-script</code>会可能在<code>DOMcontentloaded</code>触发前或后执行，但是一定会在<code>load</code>事件前触发。</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><a href=#懒加载与预加载><h2 id=懒加载与预加载><span class=hanchor arialabel=Anchor># </span>懒加载与预加载</h2></a><a href=#懒加载><h3 id=懒加载><span class=hanchor arialabel=Anchor># </span>懒加载</h3></a><ul><li>图片进入可视区域之后请求图片资源</li><li>对于电商等图片很多，页面很长的业务场景适用</li><li>减少无效资源的加载</li><li>并发加载的资源过多会会阻塞js的加载，影响网站的正常使用</li></ul><p><code>img src</code>被设置之后，<code>webkit</code>解析到之后才去请求这个资源。所以我们希望图片到达可视区域之后，<code>img src</code>才会被设置进来，没有到达可视区域前并不现实真正的<code>src</code>，而是类似一个<code>1px</code>的占位符。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>场景：电商图片
</span></span></code></pre></td></tr></table></div></div><a href=#预加载><h3 id=预加载><span class=hanchor arialabel=Anchor># </span>预加载</h3></a><ul><li>图片等静态资源在使用之前的提前请求</li><li>资源使用到时能从缓存中加载，提升用户体验</li><li>页面展示的依赖关系维护</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>场景：抽奖
</span></span></code></pre></td></tr></table></div></div><a href=#懒加载原生js和zeptolazyload><h3 id=懒加载原生js和zeptolazyload><span class=hanchor arialabel=Anchor># </span>懒加载原生<code>js</code>和<code>zepto.lazyload</code></h3></a><blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>原理
</span></span></code></pre></td></tr></table></div></div></blockquote><p>先将<code>img</code>标签中的<code>src</code>链接设为同一张图片（空白图片），将其真正的图片地址存储再<code>img</code>标签的自定义属性中（比如<code>data-src</code>）。当<code>js</code>监听到该图片元素进入可视窗口时，即将自定义属性中的地址存储到<code>src</code>属性中，达到懒加载的效果。</p><blockquote><p>注意问题：</p></blockquote><ul><li>关注首屏处理,因为还没滑动</li><li>占位，图片大小首先需要预设高度，如果没有设置的话，会全部显示出来</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>viewheight</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>documentElement</span><span class=p>.</span><span class=nx>clientHeight</span>   <span class=c1>//可视区域高度
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>lazyload</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>eles</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>querySelectorAll</span><span class=p>(</span><span class=s1>&#39;img[data-original][lazyload]&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>Array</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>forEach</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>eles</span><span class=p>,</span><span class=kd>function</span><span class=p>(</span><span class=nx>item</span><span class=p>,</span><span class=nx>index</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>rect</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=nx>item</span><span class=p>.</span><span class=nx>dataset</span><span class=p>.</span><span class=nx>original</span> <span class=o>===</span> <span class=s1>&#39;&#39;</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nx>rect</span> <span class=o>=</span> <span class=nx>item</span><span class=p>.</span><span class=nx>getBoundingClientRect</span><span class=p>();</span> <span class=c1>//返回元素的大小及其相对于视口的
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=nx>rect</span><span class=p>.</span><span class=nx>bottom</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>rect</span><span class=p>.</span><span class=nx>top</span> <span class=o>&lt;</span> <span class=nx>viewheight</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=o>!</span><span class=kd>function</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>                <span class=kd>var</span> <span class=nx>img</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Image</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=nx>img</span><span class=p>.</span><span class=nx>src</span> <span class=o>=</span> <span class=nx>item</span><span class=p>.</span><span class=nx>dataset</span><span class=p>.</span><span class=nx>url</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=nx>img</span><span class=p>.</span><span class=nx>onload</span> <span class=o>=</span> <span class=kd>function</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>                    <span class=nx>item</span><span class=p>.</span><span class=nx>src</span> <span class=o>=</span> <span class=nx>img</span><span class=p>.</span><span class=nx>src</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=nx>item</span><span class=p>.</span><span class=nx>removeAttribute</span><span class=p>(</span><span class=s1>&#39;data-original&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nx>item</span><span class=p>.</span><span class=nx>removeAttribute</span><span class=p>(</span><span class=s1>&#39;lazyload&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}()</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>lazyload</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>document</span><span class=p>.</span><span class=nx>addEventListener</span><span class=p>(</span><span class=s1>&#39;scroll&#39;</span><span class=p>,</span><span class=nx>lazyload</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><a href=#预加载原生js和preloadjs实现><h3 id=预加载原生js和preloadjs实现><span class=hanchor arialabel=Anchor># </span>预加载原生<code>js</code>和<code>preloadJS</code>实现</h3></a><a href=#预加载实现的几种方式><h4 id=预加载实现的几种方式><span class=hanchor arialabel=Anchor># </span>预加载实现的几种方式</h4></a><ul><li>第一种方式：直接请求下来</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>img</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;https://user-gold-cdn.xitu.io/2019/2/21/1690d1b216cbfa18&#34;</span> <span class=na>style</span><span class=o>=</span><span class=s>&#34;display: none&#34;</span><span class=p>/&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>img</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;https://user-gold-cdn.xitu.io/2019/2/21/1690d1b21b70c8d2&#34;</span> <span class=na>style</span><span class=o>=</span><span class=s>&#34;display: none&#34;</span><span class=p>/&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>img</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;https://user-gold-cdn.xitu.io/2019/2/21/1690d1b216e17e26&#34;</span> <span class=na>style</span><span class=o>=</span><span class=s>&#34;display: none&#34;</span><span class=p>/&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>img</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;https://user-gold-cdn.xitu.io/2019/2/21/1690d1b217b3ae59&#34;</span> <span class=na>style</span><span class=o>=</span><span class=s>&#34;display: none&#34;</span><span class=p>/&gt;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>第二种方式：<code>image</code>对象</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>image</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Image</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>image</span><span class=p>.</span><span class=nx>src</span> <span class=o>=</span> <span class=s2>&#34;www.pic26.com/dafdafd/safdas.jpg&#34;</span><span class=err>；</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>第三种方式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>xmlhttprequest</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>缺点：存在跨域问题</li><li>优点：好控制</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>xmlhttprequest</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>XMLHttpRequest</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>xmlhttprequest</span><span class=p>.</span><span class=nx>onreadystatechange</span> <span class=o>=</span> <span class=nx>callback</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>xmlhttprequest</span><span class=p>.</span><span class=nx>onprogress</span> <span class=o>=</span> <span class=nx>progressCallback</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>xmlhttprequest</span><span class=p>.</span><span class=nx>open</span><span class=p>(</span><span class=s2>&#34;GET&#34;</span><span class=p>,</span><span class=s2>&#34;http:www.xxx.com&#34;</span><span class=p>,</span><span class=kc>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>xmlhttprequest</span><span class=p>.</span><span class=nx>send</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>callback</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=nx>xmlhttprequest</span><span class=p>.</span><span class=nx>readyState</span> <span class=o>==</span> <span class=mi>4</span> <span class=o>&amp;&amp;</span> <span class=nx>xmlhttprequest</span><span class=p>.</span><span class=nx>status</span> <span class=o>==</span> <span class=mi>200</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>responseText</span> <span class=o>=</span> <span class=nx>xmlhttprequest</span><span class=p>.</span><span class=nx>responseText</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Request was unsuccessful:&#34;</span> <span class=o>+</span> <span class=nx>xmlhttprequest</span><span class=p>.</span><span class=nx>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>progressCallback</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=nx>e</span> <span class=o>=</span> <span class=nx>e</span> <span class=o>||</span> <span class=nx>event</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nx>lengthComputable</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Received&#34;</span><span class=o>+</span><span class=nx>e</span><span class=p>.</span><span class=nx>loaded</span><span class=o>+</span><span class=s2>&#34;of&#34;</span><span class=o>+</span><span class=nx>e</span><span class=p>.</span><span class=nx>total</span><span class=o>+</span><span class=s2>&#34;bytes&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>   
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>PreloadJS模块
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>本质</strong>：<strong>权衡浏览器加载能力，让它尽可能饱和利用起来</strong></li></ul><a href=#重绘与回流><h2 id=重绘与回流><span class=hanchor arialabel=Anchor># </span>重绘与回流</h2></a><a href=#css性能让javascript变慢><h3 id=css性能让javascript变慢><span class=hanchor arialabel=Anchor># </span><code>css</code>性能让<code>javascript</code>变慢</h3></a><p>要把<code>css</code>相关的外部文件引入放进<code>head</code>中，加载<code>css</code>时，整个页面的渲染是阻塞的，同样的执行<code>javascript</code>代码的时候也是阻塞的，例如<code>javascript</code>死循环。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>一个线程   =&gt;  javascript解析
</span></span><span class=line><span class=cl>一个线程   =&gt;  UI渲染
</span></span></code></pre></td></tr></table></div></div><p>这两个线程是互斥的，当<code>UI</code>渲染的时候，<code>javascript</code>的代码被终止。当<code>javascript</code>代码执行，<code>UI</code>线程被冻结。所以<code>css</code>的性能让<code>javascript</code>变慢。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>频繁触发重绘与回流，会导致UI频繁渲染，最终导致js变慢
</span></span></code></pre></td></tr></table></div></div><a href=#什么是重绘和回流><h3 id=什么是重绘和回流><span class=hanchor arialabel=Anchor># </span>什么是重绘和回流</h3></a><a href=#回流><h4 id=回流><span class=hanchor arialabel=Anchor># </span>回流</h4></a><ul><li>当<code>render tree</code>中的一部分(或全部)因为元素的<code>规模尺寸</code>，<code>布局</code>，<code>隐藏</code>等改变而需要<code>重新构建</code>。这就成为回流(<code>reflow</code>)</li><li>当页面布局和几何属性改变时，就需要<code>回流</code>。</li></ul><a href=#重绘><h4 id=重绘><span class=hanchor arialabel=Anchor># </span>重绘</h4></a><ul><li>当<code>render tree</code>中的一些元素需要更新属性，而这些属性只是影响元素的<code>外观</code>，<code>风格</code>，而不影响布局，比如<code>background-color</code>。就称重绘。</li></ul><a href=#关系><h4 id=关系><span class=hanchor arialabel=Anchor># </span>关系</h4></a><p>用到<code>chrome</code> 分析 <code>performance</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>回流必将引起重绘，但是重绘不一定会引起回流
</span></span></code></pre></td></tr></table></div></div><a href=#避免重绘回流的两种方法><h3 id=避免重绘回流的两种方法><span class=hanchor arialabel=Anchor># </span>避免重绘、回流的两种方法</h3></a><a href=#触发页面重布局的一些css属性><h4 id=触发页面重布局的一些css属性><span class=hanchor arialabel=Anchor># </span>触发页面重布局的一些css属性</h4></a><ul><li>盒子模型相关属性会触发重布局<ul><li><code>width</code> <code>height</code> <code>padding</code> <code>margin</code> <code>display</code> <code>border-width</code> <code>border</code> <code>min-height</code></li></ul></li><li>定位属性及浮动也会触发重布局<ul><li><code>top</code> <code>bottom</code> <code>left</code> <code>right</code> <code>position</code> <code>float</code> <code>clear</code></li></ul></li><li>改变节点内部文字结构也会触发重布局<ul><li><code>text-align</code> <code>overflow-y</code> <code>font-weight</code> <code>overflow</code> <code>font-family</code> <code>line-height</code> <code>vertical-align</code> <code>white-space</code> <code>font-size</code></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>优化点：使用不触发回流的方案替代触发回流的方案
</span></span></code></pre></td></tr></table></div></div><a href=#只触发重绘不触发回流><h4 id=只触发重绘不触发回流><span class=hanchor arialabel=Anchor># </span>只触发重绘不触发回流</h4></a><ul><li><code>color</code></li><li><code>border-style</code>、<code>border-radius</code></li><li><code>visibility</code></li><li><code>text-decoration</code></li><li><code>background</code>、<code>background-image</code>、<code>background-position</code>、<code>background-repeat</code>、<code>background-size</code></li><li><code>outline</code>、<code>outline-color</code>、<code>outline-style</code>、<code>outline-width</code></li><li><code>box-shadow</code></li></ul><a href=#新建dom的过程><h4 id=新建dom的过程><span class=hanchor arialabel=Anchor># </span>新建DOM的过程</h4></a><ul><li>获取<code>DOM</code>后分割为多个图层</li><li>对每个图层的节点计算样式结果(<code>Recalculate style</code> 样式重计算)</li><li>为每个节点生成图形和位置(<code>Layout</code> 回流和重布局)</li><li>将每个节点绘制填充到图层位图中(<code>Paint Setup</code>和<code>Paint</code> <code>重绘</code>)</li><li>图层作为纹理上传至<code>gpu</code></li><li>符合多个图层到页面上生成最终屏幕图像(<code>Composite Layers</code> 图层重组)</li></ul><a href=#浏览器绘制dom的过程是这样子的><h3 id=浏览器绘制dom的过程是这样子的><span class=hanchor arialabel=Anchor># </span>浏览器绘制<code>DOM</code>的过程是这样子的：</h3></a><ul><li>获取 DOM 并将其分割为多个层（<code>layer</code>），将每个层独立地绘制进位图（<code>bitmap</code>）中</li><li>将层作为纹理（<code>texture</code>）上传至 <code>GPU</code>，复合（<code>composite</code>）多个层来生成最终的屏幕图像</li><li><code>left/top/margin</code>之类的属性会影响到元素在文档中的布局，当对布局（<code>layout</code>）进行动画时，该元素的布局改变可能会影响到其他元素在文档中的位置，就导致了所有被影响到的元素都要进行重新布局，浏览器需要为整个层进行重绘并重新上传到 <code>GPU</code>，造成了极大的性能开销。</li><li><code>transform</code> 属于合成属性（<code>composite property</code>），对合成属性进行 <code>transition/animation</code> 动画将会创建一个合成层（<code>composite layer</code>），这使得被动画元素在一个独立的层中进行动画。</li><li>通常情况下，浏览器会将一个层的内容先绘制进一个位图中，然后再作为纹理（<code>texture</code>）上传到 <code>GPU</code>，只要该层的内容不发生改变，就没必要进行重绘（<code>repaint</code>），浏览器会通过重新复合（<code>recomposite</code>）来形成一个新的帧。</li></ul><a href=#chrome创建图层的条件><h4 id=chrome创建图层的条件><span class=hanchor arialabel=Anchor># </span><code>chrome</code>创建图层的条件</h4></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>将频繁重绘回流的DOM元素单独作为一个独立图层，那么这个DOM元素的重绘和回流的影响只会在这个图层中
</span></span></code></pre></td></tr></table></div></div><ul><li><code>3D</code>或透视变换</li><li><code>CSS</code>属性使用加速视频解码的 <code>&lt;video></code> 元素</li><li>拥有 <code>3D</code> (<code>WebGL</code>) 上下文或加速的 <code>2D</code> 上下文的 <code>&lt;canvas></code> 元素</li><li>复合插件(如 <code>Flash</code>)</li><li>进行 <code>opacity/transform</code> 动画的元素拥有加速</li><li><code>CSS filters</code> 的元素元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)</li><li>元素有一个 <code>z-index</code> 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</li></ul><blockquote><p>总结：对布局属性进行动画，浏览器需要为每一帧进行重绘并上传到 <code>GPU</code> 中对合成属性进行动画，浏览器会为元素创建一个独立的复合层，当元素内容没有发生改变，该层就不会被重绘，浏览器会通过重新复合来创建动画帧</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gif图
</span></span></code></pre></td></tr></table></div></div><a href=#总结><h4 id=总结><span class=hanchor arialabel=Anchor># </span>总结</h4></a><ul><li>尽量避免使用触发<code>回流</code>、<code>重绘</code>的<code>CSS</code>属性</li><li>将<code>重绘</code>、<code>回流</code>的影响范围限制在单独的图层(<code>layers</code>)之内</li><li>图层合成过程中消耗很大页面性能，这时候需要平衡考虑重绘回流的性能消耗</li></ul><a href=#实战优化点总结><h3 id=实战优化点总结><span class=hanchor arialabel=Anchor># </span>实战优化点总结</h3></a><ul><li>用<code>translate</code>替代<code>top</code>属性<ul><li><code>top</code>会触发<code>layout</code>，但<code>translate</code>不会</li></ul></li><li>用<code>opacity</code>代替<code>visibility</code><ul><li><code>opacity</code>不会触发重绘也不会触发回流，只是改变图层<code>alpha</code>值，但是必须要将这个图片独立出一个图层</li><li><code>visibility</code>会触发重绘</li></ul></li><li>不要一条一条的修改<code>DOM</code>的样式，预先定义好<code>class</code>，然后修改<code>DOM</code>的<code>className</code></li><li><code>把DOM</code>离线后修改，比如：先把<code>DOM</code>给<code>display:none</code>（有一次<code>reflow</code>），然后你修改100次，然后再把它显示出来</li><li>不要把<code>DOM</code>节点的属性值放在一个循环里当成循环的变量<ul><li><code>offsetHeight</code>、<code>offsetWidth</code>每次都要刷新缓冲区，缓冲机制被破坏</li><li>先用变量存储下来</li></ul></li><li>不要使用<code>table</code>布局，可能很小的一个小改动会造成整个<code>table</code>的重新布局<ul><li><code>div</code>只会影响后续样式的布局</li></ul></li><li>动画实现的速度的选择<ul><li>选择合适的动画速度</li><li>根据<code>performance</code>量化性能优化</li></ul></li><li>对于动画新建图层<ul><li>启用<code>gpu</code>硬件加速(并行运算)，<code>gpu加速</code>意味着数据需要从<code>cpu</code>走总线到<code>gpu</code>传输，需要考虑传输损耗.</li></ul></li><li><code>transform:translateZ(0)</code><ul><li><code>transform:translate3D(0)</code></li></ul></li></ul><p><a href=https://lavas.baidu.com/guide/v1/foundation/lavas-start rel=noopener>https://lavas.baidu.com/guide/v1/foundation/lavas-start</a>)</p><a href=#缓存><h2 id=缓存><span class=hanchor arialabel=Anchor># </span>缓存</h2></a><p>缓存算是很重要了，面试经常问到，故整理。</p><p>总体感知一下它的匹配流程，如下：</p><ol><li>浏览器发送请求前，根据请求头的expires和cache-control判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。</li><li>没有命中强缓存规则，浏览器会发送请求，根据请求头的last-modified和etag判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。</li><li>如果前两步都没有命中，则直接从服务端获取资源。</li></ol><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184300.jpg width=auto alt=img></p><a href=#强缓存><h3 id=强缓存><span class=hanchor arialabel=Anchor># </span>强缓存</h3></a><p>强缓存：不会向服务器发送请求，直接从缓存中读取资源。</p><a href=#强缓存原理><h4 id=强缓存原理><span class=hanchor arialabel=Anchor># </span>强缓存原理</h4></a><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p><ul><li>第一次请求，不存在缓存结果和缓存标识，直接向服务器发送请求</li></ul><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184301.jpg width=auto alt=img></p><ul><li>存在缓存标识和缓存结果，但是已经失效，强制缓存是啊比，则使用协商缓存（暂不分析）</li></ul><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184302.jpg width=auto alt=img></p><ul><li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li></ul><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184303.jpg width=auto alt=img></p><p>那么强制缓存的缓存规则是什么？ 当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是<code>Expires</code>和<code>Cache-Control</code>，其中<code>Cache-Control</code>优先级比<code>Expires</code>高。</p><a href=#expires><h4 id=expires><span class=hanchor arialabel=Anchor># </span>Expires</h4></a><p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，<code>Expires=max-age + 请求时间</code>，需要和<code>Last-modified</code>结合使用。<code>Expires</code>是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><blockquote><p>Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p></blockquote><a href=#cache-control><h4 id=cache-control><span class=hanchor arialabel=Anchor># </span>Cache-Control</h4></a><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为： - public：所有内容都将被缓存（客户端和代理服务器都可缓存） - private：所有内容只有客户端可以缓存，<code>Cache-Control</code>的默认取值 - no-cache：客户端缓存内容，但是是否使用缓存则需要经过<strong>协商缓存</strong>来验证决定 - no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 - max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</p><blockquote><p>需要注意的是，<code>no-cache</code>这个名字有一点误导。设置了<code>no-cache</code>之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致，也就是协商缓存。而<code>no-store</code>才表示不会被缓存，即不使用强制缓存，也不使用协商缓存</p></blockquote><a href=#nginx设置><h4 id=nginx设置><span class=hanchor arialabel=Anchor># </span>nginx设置</h4></a><p>强缓存需要服务端设置<code>expires</code>和<code>cache-control</code>。 <code>nginx</code>代码参考，设置了一年的缓存时间：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>location ~ .*\.(ico|svg|ttf|eot|woff)(.*) {
</span></span><span class=line><span class=cl>  proxy_cache               pnc;
</span></span><span class=line><span class=cl>  proxy_cache_valid         200 304 1y;
</span></span><span class=line><span class=cl>  proxy_cache_valid         any 1m;
</span></span><span class=line><span class=cl>  proxy_cache_lock          on;
</span></span><span class=line><span class=cl>  proxy_cache_lock_timeout  5s;
</span></span><span class=line><span class=cl>  proxy_cache_use_stale     updating error timeout invalid_header http_500 http_502;
</span></span><span class=line><span class=cl>  expires                   1y;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？这就是下面我们要讲到的<code>from disk cache</code>和<code>from memory cache</code>。</p><a href=#from-disk-cache和from-memory-cache><h4 id=from-disk-cache和from-memory-cache><span class=hanchor arialabel=Anchor># </span>from disk cache和from memory cache</h4></a><p>细心地同学在开发的时候应该注意到了Chrome的网络请求的Size会出现三种情况<code>from disk cache(磁盘缓存)</code>、<code>from memory cache(内存缓存)</code>、以及资源大小数值。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184304.jpg width=auto alt=img></p><p>浏览器读取缓存的顺序为memory –> disk。 以访问<code>https://github.com/xiangxingchen/blog</code>为例 我们第一次访问时<code>https://github.com/xiangxingchen/blog</code></p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184305.jpg width=auto alt=img></p><p>关闭标签页，再此打开<code>https://github.com/xiangxingchen/blog</code>时</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184306.jpg width=auto alt=img></p><p>F5刷新时</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184307.jpg width=auto alt=img></p><p>简单的对比一下</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184308.jpg width=auto alt=img></p><a href=#协商缓存><h3 id=协商缓存><span class=hanchor arialabel=Anchor># </span>协商缓存</h3></a><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><ul><li>协商缓存生效，返回304和Not Modified</li></ul><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184309.jpg width=auto alt=img></p><ul><li>协商缓存失效，返回200和请求结果</li></ul><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184310.jpg width=auto alt=img></p><a href=#last-modified和if-modified-since><h4 id=last-modified和if-modified-since><span class=hanchor arialabel=Anchor># </span>Last-Modified和If-Modified-Since</h4></a><ol><li>浏览器首先发送一个请求，让服务端在<code>response header</code>中返回请求的资源上次更新时间，就是<code>last-modified</code>，浏览器会缓存下这个时间。</li><li>然后浏览器再下次请求中，<code>request header</code>中带上<code>if-modified-since</code>:<code>[保存的last-modified的值]</code>。根据浏览器发送的修改时间和服务端的修改时间进行比对，一致的话代表资源没有改变，服务端返回正文为空的响应，让浏览器中缓存中读取资源，这就大大减小了请求的消耗。</li></ol><p>由于last-modified依赖的是保存的绝对时间，还是会出现误差的情况：</p><ol><li>保存的时间是以秒为单位的，1秒内多次修改是无法捕捉到的；</li><li>各机器读取到的时间不一致，就有出现误差的可能性。为了改善这个问题，提出了使用etag。</li></ol><a href=#etag和if-none-match><h4 id=etag和if-none-match><span class=hanchor arialabel=Anchor># </span>ETag和If-None-Match</h4></a><p><code>etag</code>是<code>http</code>协议提供的若干机制中的一种<code>Web</code>缓存验证机制，并且允许客户端进行缓存协商。生成etag常用的方法包括对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。 和<code>last-modified</code>一样. - 浏览器会先发送一个请求得到<code>etag</code>的值，然后再下一次请求在<code>request header</code>中带上<code>if-none-match</code>:<code>[保存的etag的值]</code>。 - 通过发送的<code>etag</code>的值和服务端重新生成的<code>etag</code>的值进行比对，如果一致代表资源没有改变，服务端返回正文为空的响应，告诉浏览器从缓存中读取资源。</p><blockquote><p>etag能够解决last-modified的一些缺点，但是etag每次服务端生成都需要进行读写操作，而last-modified只需要读取操作，从这方面来看，etag的消耗是更大的。</p></blockquote><p>二者对比 - 精确度上：<code>Etag</code>要优于<code>Last-Modified</code>。 - 优先级上：服务器校验优先考虑<code>Etag</code>。 - 性能上：<code>Etag</code>要逊于<code>Last-Modified</code></p><a href=#用户行为对浏览器缓存的影响><h4 id=用户行为对浏览器缓存的影响><span class=hanchor arialabel=Anchor># </span>用户行为对浏览器缓存的影响</h4></a><ol><li>打开网页，地址栏输入地址： 查找 <code>disk cache</code> 中是否有匹配。如有则使用；如没有则发送网络请求。</li><li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 <code>memory cache</code> 是可用的，会被优先使用(如果匹配的话)。其次才是 <code>disk cache</code>。</li><li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 <code>Cache-control:no-cache</code>(为了兼容，还带了 <code>Pragma:no-cache</code>),服务器直接返回 200 和最新内容。</li></ol><a href=#总结-1><h3 id=总结-1><span class=hanchor arialabel=Anchor># </span>总结</h3></a><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184311.jpg width=auto alt=img></p><blockquote><p>期望大规模数据能自动化缓存，而不是手动进行缓存，需要浏览器端和服务器端协商一种缓存机制</p></blockquote><blockquote><ul><li>Cache-Control所控制的缓存策略</li><li>last-modified 和 etage以及整个服务端浏览器端的缓存流程</li><li>基于node实践以上缓存方式</li></ul></blockquote><a href=#httpheader><h3 id=httpheader><span class=hanchor arialabel=Anchor># </span>httpheader</h3></a><a href=#可缓存性><h4 id=可缓存性><span class=hanchor arialabel=Anchor># </span>可缓存性</h4></a><ul><li><code>public</code>:表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。</li><li><code>private</code>:表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。</li><li><code>no-cache</code>:强制所有缓存了该响应的缓存用户，在使用已存储的缓存数据前，发送带验证器的请求到原始服务器</li><li><code>only-if-cached</code>:表明如果缓存存在，只使用缓存，无论原始服务器数据是否有更新</li></ul><a href=#到期><h4 id=到期><span class=hanchor arialabel=Anchor># </span>到期</h4></a><ul><li><code>max-age=</code>:设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与 <code>Expires</code>相反，时间是相对于请求的时间。</li><li><code>s-maxage=</code>:覆盖<code>max-age</code> 或者 <code>Expires</code> 头，但是仅适用于共享缓存(比如各个代理)，并且私有缓存中它被忽略。<code>cdn</code>缓存</li><li><code>max-stale[=]</code> 表明客户端愿意接收一个已经过期的资源。 可选的设置一个时间(单位秒)，表示响应不能超过的过时时间。</li><li><code>min-fresh=</code> 表示客户端希望在指定的时间内获取最新的响应。</li></ul><a href=#重新验证和重新加载><h4 id=重新验证和重新加载><span class=hanchor arialabel=Anchor># </span>重新验证和重新加载</h4></a><blockquote><p>重新验证</p></blockquote><ul><li><code>must-revalidate</code>：缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。</li><li><code>proxy-revalidate</code>：与<code>must-revalidate</code>作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。</li><li><code>immutable</code> ：表示响应正文不会随时间而改变。资源（如果未过期）在服务器上不发生改变，因此客户端不应发送重新验证请求头（例如<code>If-None-Match</code>或<code>If-Modified-Since</code>）来检查更新，即使用户显式地刷新页面。在<code>Firefox</code>中，<code>immutable</code>只能被用在 <code>https:// transactions</code>.</li></ul><blockquote><p>重新加载</p></blockquote><ul><li><code>no-store</code>:缓存不应存储有关客户端请求或服务器响应的任何内容。</li><li><code>no-transform</code>:不得对资源进行转换或转变。<code>Content-Encoding</code>,<code>Content-Range</code>, <code>Content-Type</code>等<code>HTTP</code>头不能由代理修改。例如，非透明代理可以对图像格式进行转换，以便节省缓存空间或者减少缓慢链路上的流量。 <code>no-transform</code>指令不允许这样做。</li></ul><a href=#expires-1><h3 id=expires-1><span class=hanchor arialabel=Anchor># </span>Expires</h3></a><ul><li>缓存过期时间，用来指定资源到期的时间，是服务器端的时间点</li><li>告诉浏览器在过期时间前浏览器可以直接从浏览器缓存中存取数据，而无需再次请求</li><li><code>expires</code>是<code>http1.0</code>的时候的</li><li><code>http1.1</code>时候，我们希<code>望cache</code>的管理统一进行，<code>max-age</code>优先级高于<code>expires</code>，当有<code>max-age</code>在的时候<code>expires</code>可能就会被忽略。</li><li>如果没有设置<code>cache-control</code>时候会使用<code>expires</code></li></ul><a href=#last-modified和if-modified-since-1><h3 id=last-modified和if-modified-since-1><span class=hanchor arialabel=Anchor># </span>Last-modified和If-Modified-since</h3></a><ul><li>基于客户端和服务器端协商的缓存机制</li><li><code>last-modified</code> &ndash;> <code>response header</code><br><code>if-modified-since</code> &ndash;> <code>request header</code></li><li>需要与<code>cache-control</code>共同使用</li></ul><blockquote><p><code>last-modified</code>有什么缺点？</p></blockquote><ul><li>某些服务端不能获取精确的修改时间</li><li>文件修改时间改了，但文件的内容却没有变</li></ul><a href=#etag和-if-none-match><h3 id=etag和-if-none-match><span class=hanchor arialabel=Anchor># </span>Etag和 If-none-match</h3></a><ul><li>文件内容的hash值</li><li><code>etag</code> &ndash;><code>reponse header</code><br><code>if-none-match</code> &ndash;><code>request header</code></li><li>需要与<code>cache-control</code>共同使用</li></ul><p>好处：</p><ul><li>比<code>if-modified-since</code>更加准确</li><li>优先级比<code>etage</code>更高</li></ul><a href=#service-worker><h3 id=service-worker><span class=hanchor arialabel=Anchor># </span>Service Worker</h3></a><p><code>ServiceWorker</code> 是运行在浏览器后台进程里的一段 JS，它可以做许多事情，比如拦截客户端的请求、向客户端发送消息、向服务器发起请求等等，其中最重要的作用之一就是离线资源缓存。</p><p><code>ServiceWorker</code> 拥有对缓存流程丰富灵活的控制能力，当页面请求到 <code>ServiceWorker</code>时，<code>ServiceWorker</code> 同时请求缓存和网络，把缓存的内容直接给用户，而后覆盖缓存。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184312.png width=auto alt=img></p><p><strong>注意：需要HTTPS才可以使用 ServiceWorker</strong></p><a href=#缓存流程图><h3 id=缓存流程图><span class=hanchor arialabel=Anchor># </span>缓存流程图</h3></a><a href=#服务端性能优化><h2 id=服务端性能优化><span class=hanchor arialabel=Anchor># </span>服务端性能优化</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>服务端用的node.js因为和前端用的同一种语言，可以利用服务端运算能力来进行相关的运算而减少前端的运算
</span></span></code></pre></td></tr></table></div></div><ul><li><code>vue</code>渲染遇到的问题</li><li><code>vue-ssr</code>和原理和引用</li></ul><a href=#vue渲染面临的问题><h3 id=vue渲染面临的问题><span class=hanchor arialabel=Anchor># </span>vue渲染面临的问题</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    先加载vue.js
</span></span><span class=line><span class=cl>=&gt;  执行vue.js代码
</span></span><span class=line><span class=cl>=&gt;  生成html
</span></span></code></pre></td></tr></table></div></div><blockquote><p>以前没有前端框架时，</p></blockquote><ul><li>用<code>jsp/php</code>在服务端进行数据的填充<code>，发送给客户端就是已经</code>填充好数据`的html</li><li>使用<code>jQuery</code>异步加载数据</li><li>使用<code>React</code>和<code>Vue</code>前端框架<ul><li>代价：需要框架全部加载完，才能把页面渲染出来，页面的首屏性能不好</li></ul></li></ul><a href=#多层次的优化方案><h3 id=多层次的优化方案><span class=hanchor arialabel=Anchor># </span>多层次的优化方案</h3></a><ul><li>构建层的模板编译。<code>runtime</code>,<code>compile</code>拆开,构建层做模板编译工作。<code>webpack</code>构建时候，统一，直接编译成<code>runtime</code>可以执行的代码</li><li>数据无关的<code>prerender</code>的方式</li><li>服务端渲染</li></ul><a href=#web性能监控><h2 id=web性能监控><span class=hanchor arialabel=Anchor># </span>Web性能监控</h2></a><p>google 开发者提出了一种 RAIL 模型来衡量应用性能，即：Response、Animation、Idle、Load，分别代表着 web 应用生命周期的四个不同方面。并指出最好的性能指标是：100ms 内响应用户输入；动画或者滚动需在 10ms 内产生下一帧；最大化空闲时间；页面加载时长不超过 5 秒。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184313.jpg width=auto alt=0></p><p>我们可转化为三个方面来看：响应速度、页面稳定性、外部服务调用</p><ul><li>响应速度：页面初始访问速度 + 交互响应速度</li><li>页面稳定性：页面出错率</li><li>外部服务调用：网络请求访问速度</li></ul><a href=#1-页面访问速度白屏首屏时间可交互时间><h3 id=1-页面访问速度白屏首屏时间可交互时间><span class=hanchor arialabel=Anchor># </span>1. 页面访问速度：白屏、首屏时间、可交互时间</h3></a><p>我们来看看 google 开发者针对用户体验，提出的几个性能指标</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184314.jpg width=auto alt=1></p><p>这几个指标其实都是根据用户体验，提炼出对应的性能指标</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184315.jpg width=auto alt=img></p><a href=#1first-paint-fp-and-first-contentful-paint-fcp><h4 id=1first-paint-fp-and-first-contentful-paint-fcp><span class=hanchor arialabel=Anchor># </span>1）first paint (FP) and first contentful paint (FCP)</h4></a><p>首次渲染、首次有内容的渲染<br>这两个指标浏览器已经标准化了，从 performance 的 The Paint Timing API 可以获取到，一般来说两个时间相同，但也有情况下两者不同。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184316.jpg width=auto alt=img></p><a href=#2first-meaningful-paint-and-hero-element-timing><h4 id=2first-meaningful-paint-and-hero-element-timing><span class=hanchor arialabel=Anchor># </span>2）First meaningful paint and hero element timing</h4></a><p>首次有意义的渲染、页面关键元素<br>我们假设当一个网页的 DOM 结构发生剧烈的变化的时候，就是这个网页主要内容出现的时候，那么在这样的一个时间点上，就是首次有意义的渲染。这个指标浏览器还没有规范，毕竟很难统一一个标准来定义网站的主体内容。<br>google lighthouse 定义的 first meaningful paint：<br><a href=https://docs.google.com/document/d/1BR94tJdZLsin5poeet0XoTW60M0SjvOJQttKT-JK8HI/view rel=noopener>https://docs.google.com/document/d/1BR94tJdZLsin5poeet0XoTW60M0SjvOJQttKT-JK8HI/view</a></p><a href=#3time-to-interactive><h4 id=3time-to-interactive><span class=hanchor arialabel=Anchor># </span>3）Time to interactive</h4></a><p>可交互时间</p><a href=#4长任务><h4 id=4长任务><span class=hanchor arialabel=Anchor># </span>4）长任务</h4></a><p>浏览器是单线程的，如果长任务过多，那必然会影响着用户响应时长。好的应用需要最大化空闲时间，以保证能最快响应用户的输入。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184317.jpg width=auto alt=img></p><a href=#2-页面稳定性页面出错情况><h3 id=2-页面稳定性页面出错情况><span class=hanchor arialabel=Anchor># </span>2. 页面稳定性：页面出错情况</h3></a><p>资源加载错误<br>JS 执行报错</p><a href=#3-外部服务调用><h3 id=3-外部服务调用><span class=hanchor arialabel=Anchor># </span>3. 外部服务调用</h3></a><p>CGI 耗时<br>CGI 成功率<br>CDN 资源耗时</p><a href=#监控的分类><h3 id=监控的分类><span class=hanchor arialabel=Anchor># </span>监控的分类？</h3></a><p>web 性能监控可分为两类，一类是合成监控（Synthetic Monitoring，SYN），另一类是真实用户监控（Real User Monitoring，RUM）</p><a href=#1合成监控><h4 id=1合成监控><span class=hanchor arialabel=Anchor># </span>1.合成监控</h4></a><p>合成监控是采用 web 浏览器模拟器来加载网页，通过模拟终端用户可能的操作来采集对应的性能指标，最后输出一个网站性能报告。例如：Lighthouse、PageSpeed、WebPageTest、Pingdom、PhantomJS 等。</p><a href=#1-lighthouse><h5 id=1-lighthouse><span class=hanchor arialabel=Anchor># </span>1. Lighthouse</h5></a><p>Lighthouse 是 google 一个开源的自动化工具，运行 Lighthouse 的方式有两种：一种是作为 Chrome 扩展程序运行；另一种作为命令行工具运行。 Chrome 扩展程序提供了一个对用户更友好的界面，方便读取报告。通过命令行工具可以将 Lighthouse 集成到持续集成系统。<br>展示了白屏、首屏、可交互时间等性能指标和 SEO、PWA 等。<br>腾讯文档移动端官网首页测速结果：</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184318.jpg width=auto alt=img></p><a href=#2-pagespeed><h5 id=2-pagespeed><span class=hanchor arialabel=Anchor># </span>2. PageSpeed</h5></a><p><a href=https://developers.google.com/speed/pagespeed/insights/ rel=noopener>https://developers.google.com/speed/pagespeed/insights/</a><br>不仅展示了一些主要的性能指标数据，还给出了部分性能优化建议。<br>腾讯文档移动端首页测速结果和性能优化建议：</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184319.jpg width=auto alt=img></p><a href=#3-webpagetest><h5 id=3-webpagetest><span class=hanchor arialabel=Anchor># </span>3. WebPageTest</h5></a><p>WebPageTest<br>给出性能测速结果和资源加载的瀑布图。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184320.jpg width=auto alt=img></p><a href=#4-pingdom><h5 id=4-pingdom><span class=hanchor arialabel=Anchor># </span>4. Pingdom</h5></a><p><a href=https://www.pingdom.com/ rel=noopener>https://www.pingdom.com/</a><br>注意：Pingdom 不仅提供合成监控，也提供真实用户监控。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184321.jpg width=auto alt=img><br>合成监控方式的优缺点：<br>优点：<br>无侵入性。<br>简单快捷。<br>缺点：<br>不是真实的用户访问情况，只是模拟的。<br>没法考虑到登录的情况，对于需要登录的页面就无法监控到。</p><a href=#2真实用户监控><h4 id=2真实用户监控><span class=hanchor arialabel=Anchor># </span>2.真实用户监控</h4></a><p>真实用户监控是一种被动监控技术，是一种应用服务，被监控的 web 应用通过 sdk 等方式接入该服务，将真实的用户访问、交互等性能指标数据收集上报、通过数据清洗加工后形成性能分析报表。例如 FrontJs、oneapm、Datadog 等。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184322.jpg width=auto alt=img></p><a href=#1-oneapm><h5 id=1-oneapm><span class=hanchor arialabel=Anchor># </span>1. oneapm</h5></a><p><a href=https://www.oneapm.com/bi/feature.html rel=noopener>https://www.oneapm.com/bi/feature.html</a><br>功能包括：大盘数据、特征统计、慢加载追踪、访问页面、脚本错误、AJAX、组合分析、报表、告警等。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184323.jpg width=auto alt=img></p><a href=#2-datadog><h5 id=2-datadog><span class=hanchor arialabel=Anchor># </span>2. Datadog</h5></a><p><a href=https://www.datadoghq.com/rum/ rel=noopener>https://www.datadoghq.com/rum/</a></p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184324.jpg width=auto alt=img></p><a href=#3-frontjs><h5 id=3-frontjs><span class=hanchor arialabel=Anchor># </span>3. FrontJs</h5></a><p><a href=https://www.frontjs.com/ rel=noopener>https://www.frontjs.com/</a><br>功能包括：访问性能、异常监控、报表、趋势等。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184325.jpg width=auto alt=img><br><strong>这种监控方式的优缺点：</strong><br><strong>优点：</strong><br>是真实用户访问情况。<br>可以观察历史性能趋势。<br>有一些额外的功能：报表推送、监控告警等等。<br><strong>缺点：</strong><br>有侵入性，会一定程度上响应 web 性能。</p><a href=#performance-分析><h3 id=performance-分析><span class=hanchor arialabel=Anchor># </span>performance 分析</h3></a><p>在讲如何监控之前，先来看看浏览器提供的 performance api，这也是性能监控数据的主要来源。<br>performance 提供高精度的时间戳，精度可达纳秒级别，且不会随操作系统时间设置的影响。<br>目前市场上的支持情况：主流浏览器都支持，大可放心使用。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184326.jpg width=auto alt=img></p><a href=#基本属性><h4 id=基本属性><span class=hanchor arialabel=Anchor># </span>基本属性</h4></a><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184327.jpg width=auto alt=img></p><p>performance.navigation: 页面是加载还是刷新、发生了多少次重定向</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184328.jpg width=auto alt=img></p><p>performance.timing: 页面加载的各阶段时长</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184329.jpg width=auto alt=img></p><p>各阶段的含义：</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184330.jpg width=auto alt=img></p><p>performance.memory： 基本内存使用情况，Chrome 添加的一个非标准扩展</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184331.jpg width=auto alt=img></p><p>performance.timeorigin: 性能测量开始时的时间的高精度时间戳</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184332.jpg width=auto alt=img></p><a href=#基本方法><h4 id=基本方法><span class=hanchor arialabel=Anchor># </span>基本方法</h4></a><p>performance.getEntries()<br>通过这个方法可以获取到所有的 performance 实体对象，通过 getEntriesByName 和 getEntriesByType 方法可对所有的 performance 实体对象 进行过滤，返回特定类型的实体。<br>mark 方法 和 measure 方法的结合可打点计时，获取某个函数执行耗时等。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184333.jpg width=auto alt=img></p><p>performance.getEntriesByName()<br>performance.getEntriesByType()<br>performance.mark()<br>performance.clearMarks()<br>performance.measure()<br>performance.clearMeasures()<br>performance.now()<br>…</p><a href=#提供的-api><h4 id=提供的-api><span class=hanchor arialabel=Anchor># </span>提供的 API</h4></a><p>performance 也提供了多种 API，不同的 API 之间可能会有重叠的部分。</p><a href=#1-performanceobserver-api><h5 id=1-performanceobserver-api><span class=hanchor arialabel=Anchor># </span>1. PerformanceObserver API</h5></a><p>用于检测性能的事件，这个 API 利用了观察者模式。<br>获取资源信息</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184334.jpg width=auto alt=img></p><p>监测 TTI</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184335.jpg width=auto alt=img></p><p>监测 长任务</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184336.jpg width=auto alt=img></p><a href=#2-navigation-timing-api><h5 id=2-navigation-timing-api><span class=hanchor arialabel=Anchor># </span>2. Navigation Timing API</h5></a><p><a href=https://www.w3.org/TR/navigation-timing-2/ rel=noopener>https://www.w3.org/TR/navigation-timing-2/</a><br>performance.getEntriesByType(&ldquo;navigation&rdquo;);</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184337.jpg width=auto alt=img></p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184338.jpg width=auto alt=img></p><p>不同阶段之间是连续的吗? —— 不连续<br>每个阶段都一定会发生吗？—— 不一定</p><p>重定向次数：performance.navigation.redirectCount<br>重定向耗时: redirectEnd - redirectStart<br>DNS 解析耗时: domainLookupEnd - domainLookupStart<br>TCP 连接耗时: connectEnd - connectStart<br>SSL 安全连接耗时: connectEnd - secureConnectionStart<br>网络请求耗时 (TTFB): responseStart - requestStart<br>数据传输耗时: responseEnd - responseStart<br>DOM 解析耗时: domInteractive - responseEnd<br>资源加载耗时: loadEventStart - domContentLoadedEventEnd<br>首包时间: responseStart - domainLookupStart<br>白屏时间: responseEnd - fetchStart<br>首次可交互时间: domInteractive - fetchStart<br>DOM Ready 时间: domContentLoadEventEnd - fetchStart<br>页面完全加载时间: loadEventStart - fetchStart<br>http 头部大小： transferSize - encodedBodySize</p><a href=#3-resource-timing-api><h5 id=3-resource-timing-api><span class=hanchor arialabel=Anchor># </span>3. Resource Timing API</h5></a><p><a href=https://w3c.github.io/resource-timing/ rel=noopener>https://w3c.github.io/resource-timing/</a><br>performance.getEntriesByType(&ldquo;resource&rdquo;);</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184339.jpg width=auto alt=img></p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184340.jpg width=auto alt=img></p><table><thead><tr><th>123456</th><th>// 某类资源的加载时间，可测量图片、js、css、XHRresourceListEntries.forEach(resource => { if (resource.initiatorType == &lsquo;img&rsquo;) { console.info(<code>Time taken to load ${resource.name}: </code>, resource.responseEnd - resource.startTime); }});</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>这个数据和 chrome 调式工具里 network 的瀑布图数据是一样的。</p><a href=#4-paint-timing-api><h5 id=4-paint-timing-api><span class=hanchor arialabel=Anchor># </span>4. paint Timing API</h5></a><p><a href=https://w3c.github.io/paint-timing/ rel=noopener>https://w3c.github.io/paint-timing/</a><br>首屏渲染时间、首次有内容渲染时间</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184341.jpg width=auto alt=img></p><a href=#5-user-timing-api><h5 id=5-user-timing-api><span class=hanchor arialabel=Anchor># </span>5. User Timing API</h5></a><p><a href=https://www.w3.org/TR/user-timing-2/#introduction rel=noopener>https://www.w3.org/TR/user-timing-2/#introduction</a><br>主要是利用 mark 和 measure 方法去打点计算某个阶段的耗时，例如某个函数的耗时等。</p><a href=#6-high-resolution-time-api><h5 id=6-high-resolution-time-api><span class=hanchor arialabel=Anchor># </span>6. High Resolution Time API</h5></a><p><a href=https://w3c.github.io/hr-time/#dom-performance-timeorigin rel=noopener>https://w3c.github.io/hr-time/#dom-performance-timeorigin</a><br>主要包括 now() 方法和 timeOrigin 属性。</p><a href=#7-performance-timeline-api><h5 id=7-performance-timeline-api><span class=hanchor arialabel=Anchor># </span>7. Performance Timeline API</h5></a><p><a href=https://www.w3.org/TR/performance-timeline-2/#introduction rel=noopener>https://www.w3.org/TR/performance-timeline-2/#introduction</a></p><a href=#总结-2><h4 id=总结-2><span class=hanchor arialabel=Anchor># </span>总结</h4></a><p>基于 performance 我们可以测量如下几个方面：<br>mark、measure、navigation、resource、paint、frame。</p><p>let p = window.performance.getEntries();<br>重定向次数：performance.navigation.redirectCount<br>JS 资源数量：p.filter(ele => ele.initiatorType === &ldquo;script&rdquo;).length<br>CSS 资源数量：p.filter(ele => ele.initiatorType === &ldquo;css&rdquo;).length<br>AJAX 请求数量：p.filter(ele => ele.initiatorType === &ldquo;xmlhttprequest&rdquo;).length<br>IMG 资源数量：p.filter(ele => ele.initiatorType === &ldquo;img&rdquo;).length<br>总资源数量: window.performance.getEntriesByType(&ldquo;resource&rdquo;).length</p><p><strong>不重复的耗时时段区分：</strong><br>重定向耗时: redirectEnd - redirectStart<br>DNS 解析耗时: domainLookupEnd - domainLookupStart<br>TCP 连接耗时: connectEnd - connectStart<br>SSL 安全连接耗时: connectEnd - secureConnectionStart<br>网络请求耗时 (TTFB): responseStart - requestStart<br>HTML 下载耗时：responseEnd - responseStart<br>DOM 解析耗时: domInteractive - responseEnd<br>资源加载耗时: loadEventStart - domContentLoadedEventEnd</p><p><strong>其他组合分析：</strong><br>白屏时间: domLoading - fetchStart<br>粗略首屏时间: loadEventEnd - fetchStart 或者 domInteractive - fetchStart<br>DOM Ready 时间: domContentLoadEventEnd - fetchStart<br>页面完全加载时间: loadEventStart - fetchStart</p><p><strong>JS 总加载耗时:</strong></p><table><thead><tr><th>123</th><th>const p = window.performance.getEntries();let cssR = p.filter(ele => ele.initiatorType === &ldquo;script&rdquo;);Math.max(…cssR.map((ele) => ele.responseEnd)) - Math.min(…cssR.map((ele) => ele.startTime));</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>CSS 总加载耗时:</strong></p><table><thead><tr><th>123</th><th>const p = window.performance.getEntries();let cssR = p.filter(ele => ele.initiatorType === &ldquo;css&rdquo;);Math.max(…cssR.map((ele) => ele.responseEnd)) - Math.min(…cssR.map((ele) => ele.startTime));</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><a href=#如何监控><h3 id=如何监控><span class=hanchor arialabel=Anchor># </span>如何监控？</h3></a><p>在了解了 performance 之后，我们来看看，具体是如何监控的？</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184342.jpg width=auto alt=img></p><p>总体流程：性能指标收集与数据上报—数据存储—数据聚合—分析展示—告警、报表推送</p><p>这里主要讲述如何收集性能数据。<br>性能指标收集注意项：1）保证数据的准确性 2）尽量不影响应用的性能</p><a href=#1-基本性能上报><h4 id=1-基本性能上报><span class=hanchor arialabel=Anchor># </span>1. 基本性能上报</h4></a><p>采集数据：将 performance navagation timing 中的所有点都上报，其余的上报内容可参考 performance 分析一节中截取部分上报。例如：白屏时间，JS 和 CSS 总数，以及加载总时长。<br>其余可参考的上报：是否有缓存？是否启用 gzip 压缩、页面加载方式。<br>在收集好性能数据后，即可将数据上报。<br>那选择什么时机上报？<br>google 开发者推荐的上报方式：</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184343.jpg width=auto alt=img></p><a href=#2-首屏时间计算><h4 id=2-首屏时间计算><span class=hanchor arialabel=Anchor># </span>2. 首屏时间计算</h4></a><p>我们知道首屏时间是一项重要指标，但是又很难从 performance 中拿到，来看下首屏时间计算主要有哪些方式？<br><a href=https://web.dev/first-meaningful-paint/ rel=noopener>https://web.dev/first-meaningful-paint/</a><br>1）用户自定义打点—最准确的方式（只有用户自己最清楚，什么样的时间才算是首屏加载完成）<br>2）lighthouse 中使用的是 chrome 渲染过程中记录的 trace event<br>3）可利用
<a href=https://chromedevtools.github.io/devtools-protocol/ rel=noopener>Chrome DevTools Protocol</a> 拿到页面布局节点数目。思想是：获取到当页面具有最大布局变化的时间点<br>4）aegis 的方法：利用 MutationObserver 接口，监听 document 对象的节点变化。<br>检查这些变化的节点是否显示在首屏中，若这些节点在首屏中，那当前的时间点即为首屏渲染时间。但是还有首屏内图片的加载时间需要考虑，遍历 performance.getEntries() 拿到的所有图片实体对象，根据图片的初始加载时间和加载完成时间去更新首屏渲染时间。<br>5）利用 MutationObserver 接口提供了监视对 DOM 树所做更改的能力，是 DOM3 Events 规范的一部分。<br>方法：在首屏内容模块插入一个 div，利用 Mutation Observer API 监听该 div 的 dom 事件，判断该 div 的高度是否大于 0 或者大于指定值，如果大于了，就表示主要内容已经渲染出来，可计算首屏时间。<br>6）某个专利：在 loading 状态下循环判断当前页面高度是否大于屏幕高度，若大于，则获取到当前页面的屏幕图像，通过逐像素对比来判断页面渲染是否已满屏。https://patentimages.storage.googleapis.com/bd/83/3d/f65775c31c7120/CN103324521A.pdf</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/webperformance/20210410184344.jpg width=auto alt=img></p><a href=#3-异常上报><h4 id=3-异常上报><span class=hanchor arialabel=Anchor># </span>3. 异常上报</h4></a><p>1）js error<br>监听 window.onerror 事件<br>2）promise reject 的异常<br>监听 unhandledrejection 事件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nb>window</span><span class=p>.</span><span class=nx>addEventListener</span><span class=p>(</span><span class=s2>&#34;unhandledrejection&#34;</span><span class=p>,</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>event</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>warn</span><span class=p>(</span><span class=s2>&#34;WARNING: Unhandled promise rejection. Shame on you! Reason: &#34;</span>
</span></span><span class=line><span class=cl>        <span class=o>+</span> <span class=nx>event</span><span class=p>.</span><span class=nx>reason</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p>3）资源加载失败<br>window.addEventListener(&rsquo;error&rsquo;)<br>4）网络请求失败<br>重写 window.XMLHttpRequest 和 window.fetch 捕获请求错误<br>5）iframe 异常<br>window.frames[0].onerror<br>6）window.console.error</p><a href=#4-cgi-上报><h4 id=4-cgi-上报><span class=hanchor arialabel=Anchor># </span>4. CGI 上报</h4></a><p>大致原理：拦截 ajax 请求<br>数据存储与聚合<br>一个用户访问，可能会上报几十条数据，每条数据都是多维度的。即：当前访问时间、平台、网络、ip 等。这些一条条的数据都会被存储到数据库中，然后通过数据分析与聚合，提炼出有意义的数据。例如：某日所有用户的平均访问时长、pv 等。</p><p>数据统计分析的方法：平均值统计法、百分位数统计法、样本分布统计法。</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/%E5%89%8D%E7%AB%AF/ data-ctx=Web性能 data-src=/%E5%89%8D%E7%AB%AF class=internal-link>前端</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://jieye-ericx.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Jieye ericx using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://jieye-ericx.github.io/>Home</a></li><li><a href=https://github.com/jieye-ericx>Github</a></li></ul></footer></div></div></body></html>