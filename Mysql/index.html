<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="重要 MySQL 和 Redis 的数据一致性问题  针对读写缓存时：同步直写，更新数据库+更新缓存 针对只读缓存时：更新数据库+删除缓存 较为通用的一致性策略拟定： 在并发场景下，使用 “更新数据库 + 更新缓存” 需要用分布式锁保证缓存和数据一致性，且可能存在”缓存资源浪费“和”机器性能浪费“的情况；一般推荐使用 “更新数据库 + 删除缓存” 的方案。如果根据需要，热点数据较多，可以使用 “更新数据库 + 更新缓存” 策略。 在 “更新数据库 + 删除缓存” 的方案中，推荐使用推荐用 “先更新数据库，再删除缓存” 策略，因为先删除缓存可能会导致大量请求落到数据库，而且延迟双删的时间很难评估。 在 “先更新数据库，再删除缓存” 策略中，可以使用“消息队列+重试机制” 的方案保证缓存的删除。 并通过 “订阅 binlog” 进行缓存比对，加上一层保障。 此外，需要通过初始化缓存预热、多数据源触发、延迟消息比对等策略进行辅助和补偿。 【多种数据更新触发源：定时任务扫描，业务系统 MQ、binlog 变更 MQ，相互之间作为互补来保证数据不会漏更新】"><meta property="og:title" content><meta property="og:description" content="重要 MySQL 和 Redis 的数据一致性问题  针对读写缓存时：同步直写，更新数据库+更新缓存 针对只读缓存时：更新数据库+删除缓存 较为通用的一致性策略拟定： 在并发场景下，使用 “更新数据库 + 更新缓存” 需要用分布式锁保证缓存和数据一致性，且可能存在”缓存资源浪费“和”机器性能浪费“的情况；一般推荐使用 “更新数据库 + 删除缓存” 的方案。如果根据需要，热点数据较多，可以使用 “更新数据库 + 更新缓存” 策略。 在 “更新数据库 + 删除缓存” 的方案中，推荐使用推荐用 “先更新数据库，再删除缓存” 策略，因为先删除缓存可能会导致大量请求落到数据库，而且延迟双删的时间很难评估。 在 “先更新数据库，再删除缓存” 策略中，可以使用“消息队列+重试机制” 的方案保证缓存的删除。 并通过 “订阅 binlog” 进行缓存比对，加上一层保障。 此外，需要通过初始化缓存预热、多数据源触发、延迟消息比对等策略进行辅助和补偿。 【多种数据更新触发源：定时任务扫描，业务系统 MQ、binlog 变更 MQ，相互之间作为互补来保证数据不会漏更新】"><meta property="og:type" content="website"><meta property="og:image" content="https://jieye-ericx.github.io/icon.png"><meta property="og:url" content="https://jieye-ericx.github.io/Mysql/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="重要 MySQL 和 Redis 的数据一致性问题  针对读写缓存时：同步直写，更新数据库+更新缓存 针对只读缓存时：更新数据库+删除缓存 较为通用的一致性策略拟定： 在并发场景下，使用 “更新数据库 + 更新缓存” 需要用分布式锁保证缓存和数据一致性，且可能存在”缓存资源浪费“和”机器性能浪费“的情况；一般推荐使用 “更新数据库 + 删除缓存” 的方案。如果根据需要，热点数据较多，可以使用 “更新数据库 + 更新缓存” 策略。 在 “更新数据库 + 删除缓存” 的方案中，推荐使用推荐用 “先更新数据库，再删除缓存” 策略，因为先删除缓存可能会导致大量请求落到数据库，而且延迟双删的时间很难评估。 在 “先更新数据库，再删除缓存” 策略中，可以使用“消息队列+重试机制” 的方案保证缓存的删除。 并通过 “订阅 binlog” 进行缓存比对，加上一层保障。 此外，需要通过初始化缓存预热、多数据源触发、延迟消息比对等策略进行辅助和补偿。 【多种数据更新触发源：定时任务扫描，业务系统 MQ、binlog 变更 MQ，相互之间作为互补来保证数据不会漏更新】"><meta name=twitter:image content="https://jieye-ericx.github.io/icon.png"><title>ericx 's 数字花园</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://jieye-ericx.github.io//icon.png><link href=https://jieye-ericx.github.io/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://jieye-ericx.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://jieye-ericx.github.io/js/darkmode.48459b7116d092b4e98d2cab704cad80.min.js></script>
<script src=https://jieye-ericx.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://jieye-ericx.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://jieye-ericx.github.io/",fetchData=Promise.all([fetch("https://jieye-ericx.github.io/indices/linkIndex.978b539fabc6a7a29a0ecd89a7f575a5.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://jieye-ericx.github.io/indices/contentIndex.e4f1617822572a37abb893fb2b9f5e7c.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://jieye-ericx.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://jieye-ericx.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/jieye-ericx.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=jieye-ericx.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://jieye-ericx.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://jieye-ericx.github.io/>ericx 's 数字花园</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown
<a href=https://github.com/jackyzha0/quartz/tree/hugo/content/Mysql.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#mysql-和-redis-的数据一致性问题>MySQL 和 Redis 的数据一致性问题</a></li><li><a href=#一-mysql-索引>一 Mysql 索引</a><ol><li><a href=#001-mysql-如何实现的索引机制>001 Mysql 如何实现的索引机制？</a></li><li><a href=#002-innodb-索引与-myisam-索引实现的区别是什么>002 InnoDB 索引与 MyISAM 索引实现的区别是什么？</a></li><li><a href=#003-一个表中如果没有创建索引那么还会创建-b树吗>003 一个表中如果没有创建索引，那么还会创建 B+树吗？</a></li><li><a href=#004-说一下-b树索引实现原理数据结构>004 说一下 B+树索引实现原理（数据结构）</a></li><li><a href=#005-聚簇索引与非聚簇索引-b树实现有什么区别>005 聚簇索引与非聚簇索引 b+树实现有什么区别？</a></li><li><a href=#006-说一下-b树中聚簇索引的查找匹配逻辑>006 说一下 B+树中聚簇索引的查找（匹配）逻辑</a></li><li><a href=#007-说一下-b树中非聚簇索引的查找匹配逻辑>007 说一下 B+树中非聚簇索引的查找（匹配）逻辑</a></li><li><a href=#008-平衡二叉树红黑树b-树和-b树的区别是什么都有哪些应用场景>008 平衡二叉树，红黑树，B 树和 B+树的区别是什么？都有哪些应用场景？</a></li><li><a href=#009-一个-b树中大概能存放多少条索引记录>009 一个 b+树中大概能存放多少条索引记录？</a></li><li><a href=#010-使用-b树存储的索引-crud-执行效率如何>010 使用 B+树存储的索引 crud 执行效率如何？</a></li><li><a href=#011-什么是自适应哈希索引>011 什么是自适应哈希索引？</a></li><li><a href=#012-什么是-2-3-树-2-3-4-树>012 什么是 2-3 树 2-3-4 树？</a></li><li><a href=#013-为什么官方建议使用自增长主键作为索引说一下自增主键和字符串类型主键的区别和影响>013 为什么官方建议使用自增长主键作为索引？（说一下自增主键和字符串类型主键的区别和影响）</a></li><li><a href=#014-使用-int-自增主键后-最大-id-是-10删除-id-10-和-9再添加一条记录最后添加的-id-是几删除后重启-mysql-然后添加一条记录最后-id-是几>014 使用 int 自增主键后 最大 id 是 10，删除 id 10 和 9，再添加一条记录，最后添加的 id 是几？删除后重启 mysql 然后添加一条记录最后 id 是几？</a></li><li><a href=#015-索引的优缺点是什么>015 索引的优缺点是什么？</a></li><li><a href=#016-使用索引一定能提升效率吗>016 使用索引一定能提升效率吗？</a></li><li><a href=#017-如果是大段文本内容如何创建优化索引>017 如果是大段文本内容，如何创建（优化）索引？</a></li><li><a href=#018-什么是聚簇索引>018 什么是聚簇索引？</a></li><li><a href=#019-一个表中可以有多个非聚簇索引吗>019 一个表中可以有多个（非）聚簇索引吗</a></li><li><a href=#020-聚簇索引与非聚集索引的特点是什么>020 聚簇索引与非聚集索引的特点是什么？</a></li><li><a href=#021-crud-时聚簇索引与非聚簇索引的区别是什么>021 CRUD 时聚簇索引与非聚簇索引的区别是什么？</a></li><li><a href=#022-非聚簇索引为什么不存数据地址值而存储主键>022 非聚簇索引为什么不存数据地址值而存储主键？</a></li><li><a href=#023-什么是回表操作>023 什么是回表操作？</a></li><li><a href=#024-什么是覆盖索引>024 什么是覆盖索引？</a></li><li><a href=#025-非聚集索引一定回表查询吗>025 非聚集索引一定回表查询吗?</a></li><li><a href=#026-为什么要回表查询直接存储数据不可以吗>026 为什么要回表查询？直接存储数据不可以吗？</a></li><li><a href=#027-如果把一个-innodb-表的主键删掉是不是就没有主键就没办法进行回表查询了>027 如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？</a></li><li><a href=#028-什么是联合索引组合索引复合索引>028 什么是联合索引，组合索引，复合索引？</a></li><li><a href=#030-什么是唯一索引>030 什么是唯一索引？</a></li><li><a href=#031-唯一索引是否影响性能>031 唯一索引是否影响性能？</a></li><li><a href=#032-什么时候使用唯一索引>032 什么时候使用唯一索引？</a></li><li><a href=#033-什么时候适合创建索引什么时候不适合创建索引>033 什么时候适合创建索引，什么时候不适合创建索引？</a></li><li><a href=#034-什么是索引下推>034 什么是索引下推？</a></li><li><a href=#035-有哪些情况会导致索引失效>035 有哪些情况会导致索引失效？</a></li><li><a href=#036-为什么-like-以开头索引会失效>036 为什么 LIKE 以%开头索引会失效？</a></li><li><a href=#037-一个表有多个索引的时候能否手动选择使用哪个索引>037 一个表有多个索引的时候，能否手动选择使用哪个索引？</a></li><li><a href=#038-如何查看一个表的索引>038 如何查看一个表的索引？</a></li><li><a href=#039-能否查看到索引选择的逻辑是否使用过-optimizer_trace>039 能否查看到索引选择的逻辑？是否使用过 optimizer_trace？</a></li><li><a href=#040-多个索引优先级是如何匹配的>040 多个索引优先级是如何匹配的？</a></li><li><a href=#041-使用-order-by-时能否通过索引排序>041 使用 Order By 时能否通过索引排序？</a></li><li><a href=#042-通过索引排序内部流程是什么>042 通过索引排序内部流程是什么？</a></li><li><a href=#043-什么是双路排序和单路排序>043 什么是双路排序和单路排序</a></li><li><a href=#044-group-by-分组和-order-by-在索引使用上有什么区别>044 group by 分组和 order by 在索引使用上有什么区别？</a></li><li><a href=#045-如果表中有字段为-null又被经常查询该不该给这个字段创建索引>045 如果表中有字段为 null，又被经常查询该不该给这个字段创建索引？</a></li><li><a href=#046-有字段为-null-索引是否会失效>046 有字段为 null 索引是否会失效？</a></li></ol></li><li><a href=#二-mysql-内部技术架构>二 MySQL 内部技术架构</a><ol><li><a href=#047-mysql-内部支持缓存查询吗>047 Mysql 内部支持缓存查询吗？</a></li><li><a href=#048-mysql8-为何废弃掉查询缓存>048 mysql8 为何废弃掉查询缓存？</a></li><li><a href=#049-缓存替代方案是什么>049 缓存替代方案是什么？</a></li><li><a href=#050-mysql-内部有哪些核心模块组成作用是什么>050 Mysql 内部有哪些核心模块组成，作用是什么？</a></li><li><a href=#051-一条-sql-发送给-mysql-后内部是如何执行的说一下-mysql-执行一条查询语句的内部执行过程>051 一条 sql 发送给 mysql 后，内部是如何执行的？（说一下 MySQL 执行一条查询语句的内部执行过程？）</a></li><li><a href=#052-mysql-提示不存在此列是执行到哪个节点报出的>052 MySQL 提示“不存在此列”是执行到哪个节点报出的？</a></li><li><a href=#053-如果一张表创建了多个索引在哪个阶段或模块进行的索引选择>053 如果一张表创建了多个索引，在哪个阶段或模块进行的索引选择？</a></li><li><a href=#054-mysql-支持哪些存储引擎默认使用哪个>054 MySQL 支持哪些存储引擎？默认使用哪个？</a></li><li><a href=#055-mysql80-自带哪些存储引擎分别是做什么的>055 Mysql8.0 自带哪些存储引擎？分别是做什么的？</a></li><li><a href=#056-mysql-存储引擎架构了解吗>056 MySQL 存储引擎架构了解吗？</a></li><li><a href=#057-能否单独为一张表设置存储引擎>057 能否单独为一张表设置存储引擎？</a></li><li><a href=#058-阿里京东等大厂都有自研的存储引擎如何开发一套自己的>058 阿里、京东等大厂都有自研的存储引擎，如何开发一套自己的？</a></li><li><a href=#059-myisam-和-innodb-的区别是什么>059 MyISAM 和 InnoDB 的区别是什么？</a></li><li><a href=#060-具体说一下如何做技术选型>060 具体说一下如何做技术选型</a></li></ol></li><li><a href=#三-mysql-事务>三 mysql 事务</a><ol><li><a href=#061-什么是数据库事务事务的特性是什么>061 什么是数据库事务？事务的特性是什么？</a></li><li><a href=#062-什么是-acid>062 什么是 ACID？</a></li><li><a href=#063-并发事务会有哪些问题>063 并发事务会有哪些问题？</a></li><li><a href=#064-什么是脏读-065-丢失修改-066-不可重复读-067-幻读>064 什么是脏读 065 丢失修改 066 不可重复读 067 幻读</a></li><li><a href=#068-不可重复读和幻读有什么区别>068 不可重复读和幻读有什么区别？</a></li><li><a href=#069-mysql-是如何避免事务并发问题的>069 Mysql 是如何避免事务并发问题的？</a></li><li><a href=#070-什么是事务隔离级别>070 什么是事务隔离级别？</a></li><li><a href=#071-默认的级别是什么>071 默认的级别是什么？</a></li><li><a href=#072-如何选择事务隔离级别>072 如何选择事务隔离级别？</a></li><li><a href=#073-靠缓存可以提升高事务隔离级别的性能吗>073 靠缓存可以提升高事务隔离级别的性能吗？</a></li><li><a href=#074-mysql-事务隔离是如何实现的>074 Mysql 事务隔离是如何实现的？</a></li><li><a href=#075-什么是一致性非锁定读和锁定读>075 什么是一致性非锁定读和锁定读？</a></li><li><a href=#076-说一下-mvcc-内部细节>076 说一下 MVCC 内部细节</a></li><li><a href=#077-mysql-事务一致性原子性是如何实现的>077 Mysql 事务一致性，原子性是如何实现的？</a></li><li><a href=#078mysql-事务的持久性是如何实现的>078Mysql 事务的持久性是如何实现的？</a></li><li><a href=#079-表级锁和行级锁有什么区别>079 表级锁和行级锁有什么区别？</a></li><li><a href=#080-什么是行级锁mysql-如何完成的>080 什么是行级锁？Mysql 如何完成的？</a></li><li><a href=#081-什么是共享锁读锁>081 什么是共享锁（读锁）？</a></li><li><a href=#082-什么是排它锁写锁独占锁>082 什么是排它锁（写锁/独占锁）？</a></li><li><a href=#083-什么是意向锁>083 什么是意向锁？</a></li><li><a href=#084-innodb-支持哪几种锁>084 InnoDB 支持哪几种锁？</a></li><li><a href=#085-当前读和快照读分别是什么>085 当前读和快照读分别是什么？</a></li><li><a href=#086-什么是-xa-协议>086 什么是 XA 协议？</a></li><li><a href=#087-什么是-mysql-xa-事务>087 什么是 mysql xa 事务？</a></li><li><a href=#088-xa-事务与普通事务区别是什么>088 xa 事务与普通事务区别是什么？</a></li><li><a href=#089-什么是-2pc-3pc>089 什么是 2pc 3pc？</a></li><li><a href=#090-是否使用过-select-for-update会产生哪些操作>090 是否使用过 select for update？会产生哪些操作？</a></li><li><a href=#091-说一下-mysql-死锁的原因和处理方法>091 说一下 mysql 死锁的原因和处理方法</a></li><li><a href=#092-mysql-会产生几种日志>092 Mysql 会产生几种日志？</a></li><li><a href=#093-bin-log-作用是什么>093 bin log 作用是什么？</a></li><li><a href=#094-redo-log-作用是什么>094 redo log 作用是什么？</a></li><li><a href=#095-undo-log-作用是什么>095 undo log 作用是什么？</a></li><li><a href=#096-mysql-日志是否实时写入磁盘-097-bin-log-刷盘机制是如何实现的098-redo-log-刷盘机制是如何实现的-099-undo-log-刷盘机制是如何实现的>096 Mysql 日志是否实时写入磁盘？ 097 bin log 刷盘机制是如何实现的？098 redo log 刷盘机制是如何实现的？ 099 undo log 刷盘机制是如何实现的？</a></li><li><a href=#100-mysql-的-binlog-有有几种录入格式分别有什么区别>100 MySQL 的 binlog 有有几种录入格式？分别有什么区别？</a></li><li><a href=#101-mysql-集群同步时为什么使用-binlog优缺点是什么>101 Mysql 集群同步时为什么使用 binlog？优缺点是什么？</a></li></ol></li><li><a href=#四-mysql-开发>四 Mysql 开发</a><ol><li><a href=#102-可以使用-mysql-直接存储文件吗>102 可以使用 MySQL 直接存储文件吗？</a></li><li><a href=#103-什么时候存什么时候不存>103 什么时候存，什么时候不存？</a></li><li><a href=#104-存储的时候有遇到过什么问题吗>104 存储的时候有遇到过什么问题吗？</a></li><li><a href=#105-emoji-乱码怎么办>105 Emoji 乱码怎么办？</a></li><li><a href=#106-如何存储-ip-地址>106 如何存储 ip 地址？</a></li><li><a href=#107-长文本如何存储>107 长文本如何存储？</a></li><li><a href=#108-大段文本如何设计表结构>108 大段文本如何设计表结构？</a></li><li><a href=#109-大段文本查找时如何建立索引>109 大段文本查找时如何建立索引？</a></li><li><a href=#110-有没有在开发中使用过-textblob-数据类型>110 有没有在开发中使用过 TEXT,BLOB 数据类型</a></li><li><a href=#111-日期时间如何存取>111 日期，时间如何存取？</a></li><li><a href=#112-timestampdatetime-的区别是什么>112 TIMESTAMP，DATETIME 的区别是什么？</a></li><li><a href=#113-为什么不使用字符串存储日期>113 为什么不使用字符串存储日期？</a></li><li><a href=#114-如果需要使用时间戳-timestamp-和-int-该如何选择>114 如果需要使用时间戳 timestamp 和 int 该如何选择？</a></li><li><a href=#115-char-与-varchar-的区别如何选择>115 char 与 varchar 的区别？如何选择？</a></li><li><a href=#116-财务计算有没有出现过错乱>116 财务计算有没有出现过错乱？</a></li><li><a href=#117-decimal-与-floatdouble-的区别是什么>117 decimal 与 float,double 的区别是什么？</a></li><li><a href=#118-浮点类型如何选型为什么>118 浮点类型如何选型？为什么？</a></li><li><a href=#119-预编译-sql-是什么>119 预编译 sql 是什么？</a></li><li><a href=#120-预编译-sql-有什么好处>120 预编译 sql 有什么好处？</a></li><li><a href=#121-子查询与-join-哪个效率高>121 子查询与 join 哪个效率高？</a></li><li><a href=#122-为什么子查询效率低>122 为什么子查询效率低？</a></li><li><a href=#123-join-查询可以无限叠加吗mysql-对-join-查询有什么限制吗>123 join 查询可以无限叠加吗？Mysql 对 join 查询有什么限制吗？</a></li><li><a href=#124-join-查询算法了解吗>124 join 查询算法了解吗？</a></li><li><a href=#125-如何优化过多-join-查询关联>125 如何优化过多 join 查询关联？</a></li><li><a href=#126-是否有过-mysql-调优经验>126 是否有过 mysql 调优经验？</a></li><li><a href=#127-开发中使用过哪些调优工具>127 开发中使用过哪些调优工具？</a></li><li><a href=#128-如何监控线上环境中执行比较慢的-sql-129-如何分析一条慢-sql>128 如何监控线上环境中执行比较慢的 sql？ 129 如何分析一条慢 sql？</a></li><li><a href=#130-如何查看当前-sql-使用了哪个索引>130 如何查看当前 sql 使用了哪个索引？</a></li><li><a href=#131-索引如何进行分析和调优>131 索引如何进行分析和调优？</a></li><li><a href=#132-explain-关键字中的重要指标有哪些>132 EXPLAIN 关键字中的重要指标有哪些？</a></li><li><a href=#133-mysql-数据库-cpu-飙升的话你会如何分析>133 MySQL 数据库 cpu 飙升的话你会如何分析</a></li><li><a href=#134-有没有进行过分库分表>134 有没有进行过分库分表？</a></li><li><a href=#135-什么是分库分表>135 什么是分库分表？</a></li><li><a href=#136-什么时候进行分库分表有没有配合-es-使用经验>136 什么时候进行分库分表？有没有配合 es 使用经验？</a></li><li><a href=#137-说一下实现分库分表工具的实现思路>137 说一下实现分库分表工具的实现思路</a></li><li><a href=#138-用过哪些分库分表工具>138 用过哪些分库分表工具？</a></li><li><a href=#139-分库分表后可能会有哪些问题>139 分库分表后可能会有哪些问题？</a></li><li><a href=#140-说一下读写分离常见方案>140 说一下读写分离常见方案？</a></li><li><a href=#141-为什么要使用视图-什么是视图>141 为什么要使用视图？ 什么是视图？</a></li><li><a href=#142-什么是存储过程有没有使用过>142 什么是存储过程？有没有使用过？</a></li><li><a href=#143-有没有使用过外键有什么需要注意的地方>143 有没有使用过外键？有什么需要注意的地方？</a></li><li><a href=#144-用过-processlist-吗>144 用过 processlist 吗？</a></li><li><a href=#145-某个表有数千万数据查询比较慢如何优化说一下思路>145 某个表有数千万数据，查询比较慢，如何优化？说一下思路</a></li><li><a href=#146-count列名和-count有什么区别>146 count(列名)和 count(*)有什么区别？</a></li><li><a href=#147-如果有超大分页改怎么处理>147 如果有超大分页改怎么处理？</a></li><li><a href=#148-mysql-服务器毫无规律的异常重启如何排查问题>148 mysql 服务器毫无规律的异常重启如何排查问题？</a></li><li><a href=#149-mysql-线上修改表结构有哪些风险>149 mysql 线上修改表结构有哪些风险?</a></li><li><a href=#150-什么是-mysql-多实例部署>150 什么是 mysql 多实例部署？</a></li></ol></li></ol></nav></details></aside><a href=#重要><h1 id=重要><span class=hanchor arialabel=Anchor># </span>重要</h1></a><a href=#mysql-和-redis-的数据一致性问题><h2 id=mysql-和-redis-的数据一致性问题><span class=hanchor arialabel=Anchor># </span>MySQL 和 Redis 的数据一致性问题</h2></a><p><img src=https://jieye-ericx.github.io//../../pics/v2-34125bb8924b7c221739ceaae8f936e2_b.jpg width=auto alt=img>
针对读写缓存时：同步直写，更新数据库+更新缓存
<img src=https://jieye-ericx.github.io//../../pics/v2-0794689daefbbab6f3b9230075d68954_b.jpg width=auto alt=img>
针对只读缓存时：更新数据库+删除缓存
<img src=https://jieye-ericx.github.io//../../pics/v2-c71d826fb485bfa2312d4588df60d751_b.jpg width=auto alt=img>
<strong>较为通用的一致性策略拟定：</strong>
在并发场景下，使用 “更新数据库 + 更新缓存” 需要用分布式锁保证缓存和数据一致性，且可能存在”缓存资源浪费“和”机器性能浪费“的情况；一般<strong>推荐使用 “更新数据库 + 删除缓存” 的方案</strong>。如果根据需要，热点数据较多，可以使用 “更新数据库 + 更新缓存” 策略。
在 “更新数据库 + 删除缓存” 的方案中，推荐使用推荐用 “先更新数据库，再删除缓存” 策略，因为先删除缓存可能会导致大量请求落到数据库，而且延迟双删的时间很难评估。 在 “先更新数据库，再删除缓存” 策略中，可以使用“消息队列+重试机制” 的方案保证缓存的删除。 并通过 “订阅 binlog” 进行缓存比对，加上一层保障。
此外，需要通过初始化缓存预热、多数据源触发、延迟消息比对等策略进行辅助和补偿。 【多种数据更新触发源：定时任务扫描，业务系统 MQ、binlog 变更 MQ，相互之间作为互补来保证数据不会漏更新】</p><p><strong>(1) k-v 大小的合理设置</strong></p><blockquote><p><strong>Redis key 大小设计：</strong> 由于网络的一次传输 MTU 最大为 1500 字节，所以为了保证高效的性能，建议单个 k-v 大小不超过 1KB，一次网络传输就能完成，避免多次网络交互；k-v 是越小性能越好 <strong>Redis 热 key：</strong>（1） 当业务遇到单个读热 key，通过增加副本来提高读能力或是用 hashtag 把 key 存多份在多个分片中；（2）当业务遇到单个写热 key，需业务拆分这个 key 的功能，属于设计不合理- 当业务遇到热分片，即多个热 key 在同一个分片上导致单分片 cpu 高，可通过 hashtag 方式打散</p></blockquote><a href=#一-mysql-索引><h2 id=一-mysql-索引><span class=hanchor arialabel=Anchor># </span>一 Mysql 索引</h2></a><a href=#001-mysql-如何实现的索引机制><h3 id=001-mysql-如何实现的索引机制><span class=hanchor arialabel=Anchor># </span>001 Mysql 如何实现的索引机制？</h3></a><p>MySQL 中索引分三类：B+树索引、Hash 索引、全文索引</p><a href=#002-innodb-索引与-myisam-索引实现的区别是什么><h3 id=002-innodb-索引与-myisam-索引实现的区别是什么><span class=hanchor arialabel=Anchor># </span>002 InnoDB 索引与 MyISAM 索引实现的区别是什么？</h3></a><p>MyISAM的索引方式都是非聚簇的，与InnoDB包含1个聚簇索引是不同的。</p><ul><li><p>在 InnoDB 存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而<strong>在 MyISAM 中却需要进行一次回表操作，意味着 MyISAM 中建立的索引相当于全部都是二级索引</strong> 。</p></li><li><p>InnoDB 的数据文件本身就是索引文件，而 MyISAM 索引文件和数据文件是分离的 ，索引文件仅保存数据记录的地址。</p></li><li><p>MyISAM 的表在磁盘上存储在以下文件中： <code>*.sdi（描述表结构）</code>、<code>*.MYD（数据）</code>，<code>*.MYI（索引）</code></p></li><li><p>InnoDB 的表在磁盘上存储在以下文件中： <code>.ibd（表结构、索引和数据都存在一起）</code></p></li><li><p>InnoDB 的非聚簇索引 data 域存储相应记录主键的值 ，而 MyISAM 索引记录的是地址 。换句话说，InnoDB 的所有非聚簇索引都引用主键作为 data 域。</p></li><li><p>MyISAM 的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观 InnoDB 是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p></li><li><p>InnoDB 要求表必须有主键 （ MyISAM 可以没有 ）。如果没有显式指定，则 MySQL 系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整型。
<img src=https://jieye-ericx.github.io//../../pics/image-20220709183820796.png width=auto alt=image-20220709183820796></p></li></ul><a href=#003-一个表中如果没有创建索引那么还会创建-b树吗><h3 id=003-一个表中如果没有创建索引那么还会创建-b树吗><span class=hanchor arialabel=Anchor># </span>003 一个表中如果没有创建索引，那么还会创建 B+树吗？</h3></a><p>会</p><ul><li>如果有主键会创建聚簇索引</li><li>如果没有主键会生成 rowid 作为隐式主键</li></ul><a href=#004-说一下-b树索引实现原理数据结构><h3 id=004-说一下-b树索引实现原理数据结构><span class=hanchor arialabel=Anchor># </span>004 说一下 B+树索引实现原理（数据结构）</h3></a><p>假设有一个表 index_demo，表中有 2 个 INT 类型的列，1 个 CHAR(1)类型的列，c1 列为主键：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>index_demo</span><span class=p>(</span><span class=n>c1</span><span class=w> </span><span class=nb>INT</span><span class=p>,</span><span class=n>c2</span><span class=w> </span><span class=nb>INT</span><span class=p>,</span><span class=n>c3</span><span class=w> </span><span class=nb>CHAR</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>(</span><span class=n>c1</span><span class=p>))</span><span class=w> </span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>index_demo 表的简化的行格式示意图如下：
<img src=https://jieye-ericx.github.io//../../pics/image-20220709071051043.png width=auto alt=image-20220709071051043>
我们只在示意图里展示记录的这几个部分：</p><ul><li><code>record_type：</code>表示记录的类型， 0 是普通记录、 2 是最小记录、 3 是最大记录、<strong>1 是 B+树非叶子节点记录</strong>。</li><li><code>next_record：</code>表示下一条记录的相对位置，我们用箭头来表明下一条记录。</li><li><code>各个列的值：</code>这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。</li><li><code>其他信息：</code>除了上述 3 种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。
将<code>其他信息</code>项暂时去掉并把它竖起来的效果就是这样：
<img src=https://jieye-ericx.github.io//../../pics/image-20220709071958145.png width=auto alt=image-20220709071958145>
把一些记录放到页里的示意图就是（这里一页就是一个磁盘块，代表一次 IO）：
<img src=https://jieye-ericx.github.io//../../pics/image-20220709072138395.png width=auto alt=image-20220709072138395>
<code>MySQL InnoDB的默认的页大小是16KB</code>，因此数据存储在磁盘中，可能会占用多个数据页。如果各个页中的记录没有规律，我们就不得不依次遍历所有的数据页。<code>如果我们想快速的定位到需要查找的记录在哪些数据页中</code>，我们可以这样做 ：</li><li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</li><li>给所有的页建立目录项
<img src=https://jieye-ericx.github.io//../../pics/image-20220709073749310.png width=auto alt=image-20220709073749310>
以<code>页28</code>为例，它对应<code>目录项2</code> ，这个目录项中包含着该页的<code>页号28</code>以及该页中用户记录的<code>最小主键值 5</code>。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。<code>比如：查找主键值为 20 的记录，具体查找过程分两步：</code></li></ul><ol><li>先从目录项中根据二分法快速确定出<code>主键值为20的记录在目录项3中</code>（因为 12 ≤ 20 &lt; 209 ），<code>对应页9</code>。</li><li>再到页 9 中根据二分法快速定位到主键值为 20 的用户记录。
至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为<code>索引</code> 。</li></ol><a href=#innodb-中的索引方案><h4 id=innodb-中的索引方案><span class=hanchor arialabel=Anchor># </span>InnoDB 中的索引方案</h4></a><p>我们新分配一个编号为 30 的页来专门存储<code>目录项记录</code>，页 10、28、9、20 专门存储<code>用户记录</code>：
<img src=https://jieye-ericx.github.io//../../pics/image-20220709074801215.png width=auto alt=image-20220709073749310>
<img src=https://jieye-ericx.github.io//../../pics/1557565-20220429110413866-1755798300.png width=auto alt=img>
目录项记录和普通的用户记录的不同点：</p><ul><li>目录项记录 的 record_type 值是 1，而 普通用户记录 的 record_type 值是 0。</li><li>目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，包含很多列，另外还有 InnoDB 自己添加的隐藏列。
现在查找主键值为 20 的记录，具体查找过程分两步：</li></ul><ol><li>先到页 30 中通过二分法快速定位到对应目录项，因为 12 ≤ 20 &lt; 209 ，就是页 9。</li><li>再到页 9 中根据二分法快速定位到主键值为 20 的用户记录。
<strong>更复杂的情况如下：</strong>
我们生成了一个存储更高级目录项的 页 33 ，这个页中的两条记录分别代表页 30 和页 32，如果用户记录的主键值在 <code>[1, 320)</code> 之间，则到页 30 中查找更详细的目录项记录，如果主键值 不小于 320 的话，就到页 32 中查找更详细的目录项记录。<strong>这个数据结构，它的名称是 B+树 。</strong>
<img src=https://jieye-ericx.github.io//../../pics/image-20220709080648851.png width=auto alt=image-20220709080648851></li></ol><a href=#005-聚簇索引与非聚簇索引-b树实现有什么区别><h3 id=005-聚簇索引与非聚簇索引-b树实现有什么区别><span class=hanchor arialabel=Anchor># </span>005 聚簇索引与非聚簇索引 b+树实现有什么区别？</h3></a><a href=#聚簇索引><h5 id=聚簇索引><span class=hanchor arialabel=Anchor># </span>聚簇索引</h5></a><p><strong>特点：</strong></p><ul><li><code>索引和数据保存在同一个B+树中</code></li><li><code>页内的记录</code>是按照<code>主键</code>的大小顺序排成一个<code>单向链表</code> 。</li><li><code>页和页之间</code>也是根据页中记录的<code>主键</code>的大小顺序排成一个<code>双向链表</code> 。</li><li>非叶子节点存储的是记录的<code>主键+页号</code>。</li><li>叶子节点存储的是<code>完整的用户记录</code>。
<strong>优点：</strong></li><li>数据访问更快 ，因为<code>索引和数据保存在同一个B+树中</code>，因此从聚簇索引中获取数据比非聚簇索引更快。</li><li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快。</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于<code>数据都是紧密相连</code>，数据库可以从更少的数据块中提取数据，<code>节省了大量的IO操作</code> 。
<strong>缺点：</strong></li><li>插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个<code>自增的ID列为主键</code>。</li><li>更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义<code>主键为不可更新</code>。
<strong>限制：</strong></li><li>只有 InnoDB 引擎支持聚簇索引，<code>MyISAM不支持聚簇索引</code>。</li><li>由于数据的物理存储排序方式只能有一种，所以<code>每个MySQL的表只能有一个聚簇索引</code>。</li><li>如果没有为表定义主键，InnoDB 会选择<code>非空的唯一索引列代替</code>。如果没有这样的列，InnoDB 会<code>隐式的定义一个主键</code>作为聚簇索引。</li><li>为了充分利用聚簇索引的聚簇特性，InnoDB 中表的<code>主键应选择有序的id</code>，不建议使用无序的 id，比如 UUID、MD5、HASH、字符串作为主键，无法保证数据的顺序增长。</li></ul><a href=#非聚簇索引二级索引辅助索引><h5 id=非聚簇索引二级索引辅助索引><span class=hanchor arialabel=Anchor># </span>非聚簇索引（二级索引、辅助索引）</h5></a><p><code>聚簇索引</code>，只能在搜索条件是<code>主键值</code>时才发挥作用，因为 B+树中的数据都是按照主键进行排序的，如果我们想以别的列作为搜索条件，那么需要创建<code>非聚簇索引</code>。
<strong>例如，</strong><code>以c2列作为搜索条件</code>，那么需要使<code>用c2列创建一棵B+树</code>，如下所示：
<img src=https://jieye-ericx.github.io//../../pics/image-20220709130937991.png width=auto alt=image-20220709130937991>
<strong>这个 B+树与聚簇索引有几处不同：</strong></p><ul><li><code>页内的记录</code>是按照从<code>c2列</code>的大小顺序排成一个<code>单向链表</code> 。</li><li><code>页和页之间</code>也是根据页中记录的<code>c2列</code>的大小顺序排成一个<code>双向链表</code> 。</li><li>非叶子节点存储的是记录的<code>c2列+页号</code>。</li><li>叶子节点存储的并不是完整的用户记录，而只是<code>c2列+主键</code>这两个列的值。
<strong>一张表可以有多个非聚簇索引：</strong>
<img src=https://jieye-ericx.github.io//../../pics/image-20220709134109900-16668534893372.png width=auto alt=image-20220709134109900></li></ul><a href=#006-说一下-b树中聚簇索引的查找匹配逻辑><h3 id=006-说一下-b树中聚簇索引的查找匹配逻辑><span class=hanchor arialabel=Anchor># </span>006 说一下 B+树中聚簇索引的查找（匹配）逻辑</h3></a><p><img src=https://jieye-ericx.github.io//../../pics/image-20220709080648851.png width=auto alt=image-20220709080648851></p><a href=#007-说一下-b树中非聚簇索引的查找匹配逻辑><h3 id=007-说一下-b树中非聚簇索引的查找匹配逻辑><span class=hanchor arialabel=Anchor># </span>007 说一下 B+树中非聚簇索引的查找（匹配）逻辑</h3></a><p>**例如：**根据 c2 列的值查找 c2=4 的记录，查找过程如下：</p><ol><li>根据<code>根页面44</code>定位到<code>页42</code>（因为<code>2 ≤ 4 &lt; 9</code>）</li><li>由于<code>c2列没有唯一性约束</code>，所以 c2=4 的记录可能分布在多个数据页中，又因为 <code>2 ≤ 4 ≤ 4</code>，所以确定实际存储用户记录的页在<code>页34和页35</code>中。</li><li>在页 34 和 35 中<code>定位到具体的记录</code>。</li><li>但是这个 B+树的叶子节点<code>只存储了c2和c1（主键）</code>两个列，所以我们必须<code>再根据主键值去聚簇索引中再查找</code>一遍完整的用户记录。</li><li>like 张%
<img src=https://jieye-ericx.github.io//../../pics/image-20220709130937991.png width=auto alt=image-20220709130937991></li></ol><a href=#008-平衡二叉树红黑树b-树和-b树的区别是什么都有哪些应用场景><h3 id=008-平衡二叉树红黑树b-树和-b树的区别是什么都有哪些应用场景><span class=hanchor arialabel=Anchor># </span>008 平衡二叉树，红黑树，B 树和 B+树的区别是什么？都有哪些应用场景？</h3></a><p>平衡二叉树</p><ul><li>基础数据结构</li><li>左右平衡</li><li>高度差大于 1 会自旋</li><li>每个节点记录一个数据
<strong>平衡二叉树（AVL）</strong>
AVL 树全称 G.M. Adelson-Velsky 和 E.M. Landis，这是两个人的人名。
平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为 AVL 树， 可以保证查询效率较高。
<code>具有以下特点：</code></li><li>它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1</li><li>并且左右两个子树都是一棵平衡二叉树。
<img src=https://jieye-ericx.github.io//../../pics/image-20220708235509010.png width=auto alt=image-20220708235509010>
AVL 的生成演示：https://www.cs.usfca.edu/~galles/visualization/AVLtree.html
<strong>AVL 的问题</strong>
众所周知，IO 操作的效率很低，在大量数据存储中，查询时我们不能一下子将所有数据加载到内存中，只能逐节点加载（一个节点一次 IO）。如果我们利用二叉树作为索引结构，<code>那么磁盘的IO次数和索引树的高度是相关的</code>。平衡二叉树由于树深度过大而造成磁盘 IO 读写过于频繁，进而导致效率低下。
<img src=https://jieye-ericx.github.io//../../pics/image-20220708233351509.png width=auto alt=image-20220708233351509>
为了提高查询效率，就需要 减少磁盘 IO 数 。<code>为了减少磁盘IO的次数，就需要尽量降低树的高度</code> ，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。针对同样的数据，如果我们把二叉树改成 三叉树：
<img src=https://jieye-ericx.github.io//../../pics/image-20220708235725124.png width=auto alt=image-20220708235725124>
上面的例子中，我们将二叉树变成了三叉树，降低了树的高度。如果能够在一个节点中存放更多的数据，我们还可以进一步减少节点的数量，从而进一步降低树的高度。这就是<code>多叉树</code>。
<strong>普通树的问题</strong></li><li>左子树全部为空，从形式上看，更像一个单链表，不能发挥 BST 的优势。</li><li><code>解决方案：平衡二叉树(AVL)</code></li></ul><p><img src=https://jieye-ericx.github.io//../../pics/image-20220708231622916.png width=auto alt=image-20220708231622916>
红黑树</p><ul><li>hashmap 存储</li><li>两次旋转达到平衡</li><li>分为红黑节点
在这个棵严格的平台树上又进化为“红黑树”{是一个非严格的平衡树 左子树与右子树的高度差不能超过 1}，红黑树的长子树只要不超过短子树的两倍即可！</li></ul><p><img src=https://jieye-ericx.github.io//../../pics/image-20221027154142690.png width=auto alt=image-20221027154142690>
当再次插入 7 的时候，这棵树就会发生旋转
<img src=https://jieye-ericx.github.io//../../pics/image-20221027154120483.png width=auto alt=image-20221027154120483>
<strong>B+</strong> <strong>树和</strong> <strong>B</strong> <strong>树的差异：</strong></p><ul><li>B+树中非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大值（或最小）。</li><li>B+树中非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， 非叶子节点既保存索引，也保存数据记录 。</li><li>B+树中所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</li></ul><a href=#009-一个-b树中大概能存放多少条索引记录><h3 id=009-一个-b树中大概能存放多少条索引记录><span class=hanchor arialabel=Anchor># </span>009 一个 b+树中大概能存放多少条索引记录？</h3></a><ul><li><code>真实环境</code>中一个页存放的记录数量是非常大的（默认 16KB），假设指针与键值忽略不计（或看做 10 个字节），数据占 1 kb 的空间：</li><li>如果 B+树只有 1 层，也就是只有 1 个用于存放用户记录的节点，最多能存放 16 条记录。</li><li>如果 B+树有 2 层，最多能存放 <code>1600×16=25600</code> 条记录。</li><li>如果 B+树有 3 层，最多能存放 <code>1600×1600×16=40960000</code> 条记录。</li><li>如果存储千万级别的数据，只需要三层就够了
<code>B+树的非叶子节点不存储用户记录，只存储目录记录，相对B树每个节点可以存储更多的记录，树的高度会更矮胖，IO次数也会更少。</code></li></ul><a href=#010-使用-b树存储的索引-crud-执行效率如何><h3 id=010-使用-b树存储的索引-crud-执行效率如何><span class=hanchor arialabel=Anchor># </span>010 使用 B+树存储的索引 crud 执行效率如何？</h3></a><p>c 新增
O(lognN)
N = 高度</p><a href=#011-什么是自适应哈希索引><h3 id=011-什么是自适应哈希索引><span class=hanchor arialabel=Anchor># </span>011 什么是自适应哈希索引？</h3></a><p>自适应哈希索引是 Innodb 引擎的一个特殊功能，当它注意到某些索引值被使用的非常频繁时，会在内存中基于 B-Tree 所有之上再创建一个哈希索引，这就让 B-Tree 索引也具有哈希索引的一些优点，比如快速哈希查找。<em>这是一个完全自动的内部行为，用户无法控制或配置</em>
<strong>使用命令</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SHOW ENGINE INNODB STATUS \G ;
</span></span></code></pre></td></tr></table></div></div><p>查看 INSERT BUFFER AND ADAPTIVE HASH INDEX</p><a href=#012-什么是-2-3-树-2-3-4-树><h3 id=012-什么是-2-3-树-2-3-4-树><span class=hanchor arialabel=Anchor># </span>012 什么是 2-3 树 2-3-4 树？</h3></a><p>多叉树（multiway tree）允许<code>每个节点可以有更多的数据项和更多的子节点</code>。2-3 树，2-3-4 树就是多叉树，多叉树通过<code>重新组织节点，减少节点数量，增加分叉，减少树的高度</code>，能对二叉树进行优化。
<strong>2-3 树</strong>
下面 2-3 树就是一颗多叉树
<img src=https://jieye-ericx.github.io//../../pics/image-20220709002223882.png width=auto alt=image-20220709002223882></p><p>2-3 树具有如下特点：</p><ul><li>2-3 树的所有叶子节点都在同一层。</li><li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点。</li><li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点。</li><li>2-3 树是由二节点和三节点构成的树。</li><li>对于三节点的子树的值大小仍然遵守 BST 二叉排序树的规则。</li></ul><p><img src=https://jieye-ericx.github.io//../../pics/image-20220709002554341.png width=auto alt=image-20220709002554341>
<strong>2-3-4 树</strong>
<img src=https://jieye-ericx.github.io//../../pics/image-20220709004531952.png width=auto alt=image-20220709004531952></p><a href=#013-为什么官方建议使用自增长主键作为索引说一下自增主键和字符串类型主键的区别和影响><h3 id=013-为什么官方建议使用自增长主键作为索引说一下自增主键和字符串类型主键的区别和影响><span class=hanchor arialabel=Anchor># </span>013 为什么官方建议使用自增长主键作为索引？（说一下自增主键和字符串类型主键的区别和影响）</h3></a><ul><li>自增主键能够维持底层数据顺序写入</li><li>读取可以由 b+树的二分查找定位</li><li>支持范围查找，范围数据自带顺序
字符串无法完成以上操作</li></ul><a href=#014-使用-int-自增主键后-最大-id-是-10删除-id-10-和-9再添加一条记录最后添加的-id-是几删除后重启-mysql-然后添加一条记录最后-id-是几><h3 id=014-使用-int-自增主键后-最大-id-是-10删除-id-10-和-9再添加一条记录最后添加的-id-是几删除后重启-mysql-然后添加一条记录最后-id-是几><span class=hanchor arialabel=Anchor># </span>014 使用 int 自增主键后 最大 id 是 10，删除 id 10 和 9，再添加一条记录，最后添加的 id 是几？删除后重启 mysql 然后添加一条记录最后 id 是几？</h3></a><p>删除之后</p><ul><li>如果重启，会从最大的 id 开始递增</li><li>如果没重启，会延续删除之前最大的 id 开始递增</li></ul><a href=#015-索引的优缺点是什么><h3 id=015-索引的优缺点是什么><span class=hanchor arialabel=Anchor># </span>015 索引的优缺点是什么？</h3></a><p><strong>优点</strong>
聚簇（主键）索引：</p><ul><li>顺序读写</li><li>范围快速查找</li><li>范围查找自带顺序
非聚簇索引：</li><li>条件查询避免全表扫描 scan</li><li>范围，排序，分组查询返回行 id，排序分组后，再回表查询完整数据，有可能利用顺序读写</li><li>覆盖索引不需要回表操作
<strong>索引的代价</strong>
索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</li><li><strong>空间上的代价</strong>
每建立一个索引都要为它建立一棵 B+树，<code>每一棵B+树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间</code>，一棵很大的 B+树由许多数据页组成，那就是很大的一片存储空间。</li><li><strong>时间上的代价</strong>
<code>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引</code>。而增、删、改操作可能会对节点和记录的排序造成破坏<code>，所以存储引擎需要额外的时间进行一些记录移位、页面分裂、页面回收等操作来维护好节点和记录的排序。</code>如果我们建了许多索引，每个索引对应的 B+树都要进行相关的维护操作，会给性能拖后腿。
B 树和 B+ 树都可以作为索引的数据结构，<strong>在 MySQL 中采用的是 B+ 树。</strong>
但 B 树和 B+树各有自己的应用场景，不能说 B+树完全比 B 树好，反之亦然。</li></ul><a href=#016-使用索引一定能提升效率吗><h3 id=016-使用索引一定能提升效率吗><span class=hanchor arialabel=Anchor># </span>016 使用索引一定能提升效率吗？</h3></a><p>不一定</p><ul><li>少量数据全表扫描也很快，可以直接获取到全量数据</li><li>唯一索引会影响插入速度，但建议使用</li><li>索引过多会影响更新，插入，删除数据速度</li></ul><a href=#017-如果是大段文本内容如何创建优化索引><h3 id=017-如果是大段文本内容如何创建优化索引><span class=hanchor arialabel=Anchor># </span>017 如果是大段文本内容，如何创建（优化）索引？</h3></a><p>第一种方式是分表存储，然后创建索引
第二是使用 es 为大文本创建索引</p><a href=#018-什么是聚簇索引><h3 id=018-什么是聚簇索引><span class=hanchor arialabel=Anchor># </span>018 什么是聚簇索引？</h3></a><p>聚簇索引数据和索引存放在一起组成一个 b+树
参考
<a href=/Mysql/ rel=noopener class=internal-link data-src=/Mysql/>005 聚簇索引与非聚簇索引 b+树实现有什么区别？</a></p><a href=#019-一个表中可以有多个非聚簇索引吗><h3 id=019-一个表中可以有多个非聚簇索引吗><span class=hanchor arialabel=Anchor># </span>019 一个表中可以有多个（非）聚簇索引吗</h3></a><p>聚簇索引只能有一个
非聚簇索引可以有多个</p><a href=#020-聚簇索引与非聚集索引的特点是什么><h3 id=020-聚簇索引与非聚集索引的特点是什么><span class=hanchor arialabel=Anchor># </span>020 聚簇索引与非聚集索引的特点是什么？</h3></a><p>参考
<a href=/Mysql/ rel=noopener class=internal-link data-src=/Mysql/>005 聚簇索引与非聚簇索引 b+树实现有什么区别？</a></p><a href=#021-crud-时聚簇索引与非聚簇索引的区别是什么><h3 id=021-crud-时聚簇索引与非聚簇索引的区别是什么><span class=hanchor arialabel=Anchor># </span>021 CRUD 时聚簇索引与非聚簇索引的区别是什么？</h3></a><ul><li>聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多，因为插入要保证主键不能重复</li><li>聚簇索引范围，排序查找效率高，因为是有序的</li><li>非聚簇索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据</li></ul><a href=#022-非聚簇索引为什么不存数据地址值而存储主键><h3 id=022-非聚簇索引为什么不存数据地址值而存储主键><span class=hanchor arialabel=Anchor># </span>022 非聚簇索引为什么不存数据地址值而存储主键？</h3></a><p>因为聚簇索引中有时会引发分页操作、重排操作数据有可能会移动</p><a href=#023-什么是回表操作><h3 id=023-什么是回表操作><span class=hanchor arialabel=Anchor># </span>023 什么是回表操作？</h3></a><p>id age name sex
age -> index
select * from user where age >20 ;
第一次 取回 id，第二次（回表）根据 id 拿到完整数据
select * from user where age >20 ;</p><a href=#024-什么是覆盖索引><h3 id=024-什么是覆盖索引><span class=hanchor arialabel=Anchor># </span>024 什么是覆盖索引？</h3></a><p>id age name sex
age -> index
select * from user where age >20 ;
第一次 取回 id，第二次（回表）根据 id 拿到完整数据
age,name -> index
select age from user where age >20 and name like"张%" ;
覆盖索引不会回表查询，查询效率也是比较高的</p><blockquote><p>覆盖索引（covering index ，或称为索引覆盖）即从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。</p></blockquote><a href=#025-非聚集索引一定回表查询吗><h3 id=025-非聚集索引一定回表查询吗><span class=hanchor arialabel=Anchor># </span>025 非聚集索引一定回表查询吗?</h3></a><p>不一定，只要 b+树中包含的字段（创建索引的字段），覆盖（包含）想要 select 的字段，那么就不会回表查询了。</p><a href=#026-为什么要回表查询直接存储数据不可以吗><h3 id=026-为什么要回表查询直接存储数据不可以吗><span class=hanchor arialabel=Anchor># </span>026 为什么要回表查询？直接存储数据不可以吗？</h3></a><p>为了控制非聚簇索引的大小</p><a href=#027-如果把一个-innodb-表的主键删掉是不是就没有主键就没办法进行回表查询了><h3 id=027-如果把一个-innodb-表的主键删掉是不是就没有主键就没办法进行回表查询了><span class=hanchor arialabel=Anchor># </span>027 如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？</h3></a><p>不是，InnoDB 会生成 rowid 辅助回表查询</p><a href=#028-什么是联合索引组合索引复合索引><h3 id=028-什么是联合索引组合索引复合索引><span class=hanchor arialabel=Anchor># </span>028 什么是联合索引，组合索引，复合索引？</h3></a><p>为c2和c3列建立联合索引，如下所示：
c2，c3 - > index
c3,c2 -> index
where c3=?
全职匹配:匹配c2，c3顺序也不能变
最左前缀：
<img src=https://jieye-ericx.github.io//../../pics/image-20220712002627554.png width=auto alt=image-20220712002627554></p><a href=#029-复合索引创建时字段顺序不一样使用效果一样吗><h4 id=029-复合索引创建时字段顺序不一样使用效果一样吗><span class=hanchor arialabel=Anchor># </span>029 复合索引创建时字段顺序不一样使用效果一样吗？</h4></a><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让 B+树按照 <code>c2和c3列</code> 的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照<code>c2</code>列进行排序。</li><li>在记录的<code>c2</code>列相同的情况下，采用<code>c3</code>列进行排序</li><li>B+树叶子节点处的记录由<code>c2列、c3列和主键c1列组成</code></li><li>本质上也是二级索引
<code>create index idx_c2_c3 on user (c2,c3);</code></li></ul><a href=#030-什么是唯一索引><h3 id=030-什么是唯一索引><span class=hanchor arialabel=Anchor># </span>030 什么是唯一索引？</h3></a><ul><li>随表一起创建索引：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>customer</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=n>UNSIGNED</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>customer_no</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>200</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>customer_name</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>200</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>(</span><span class=n>id</span><span class=p>),</span><span class=w> </span><span class=c1>-- 主键索引：列设定为主键后会自动建立索引，唯一且不能为空。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UNIQUE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>uk_no</span><span class=w> </span><span class=p>(</span><span class=n>customer_no</span><span class=p>),</span><span class=w> </span><span class=c1>-- 唯一索引：索引列值必须唯一，允许有NULL值，且NULL可能会出现多次。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>KEY</span><span class=w> </span><span class=n>idx_name</span><span class=w> </span><span class=p>(</span><span class=n>customer_name</span><span class=p>),</span><span class=w> </span><span class=c1>-- 普通索引：既不是主键，列值也不需要唯一，单纯的为了提高查询速度而创建。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>KEY</span><span class=w> </span><span class=n>idx_no_name</span><span class=w> </span><span class=p>(</span><span class=n>customer_no</span><span class=p>,</span><span class=n>customer_name</span><span class=p>)</span><span class=w> </span><span class=c1>-- 复合索引：即一个索引包含多个列。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>单独创建索引：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>customer1</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=n>UNSIGNED</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>customer_no</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>200</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>customer_name</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>200</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>customer1</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=n>customer1</span><span class=p>(</span><span class=n>id</span><span class=p>);</span><span class=w> </span><span class=c1>-- 主键索引
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>UNIQUE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>uk_no</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>customer1</span><span class=p>(</span><span class=n>customer_no</span><span class=p>);</span><span class=w> </span><span class=c1>-- 唯一索引
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>customer1</span><span class=p>(</span><span class=n>customer_name</span><span class=p>);</span><span class=w> </span><span class=c1>-- 普通索引
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_no_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>customer1</span><span class=p>(</span><span class=n>customer_no</span><span class=p>,</span><span class=n>customer_name</span><span class=p>);</span><span class=w> </span><span class=c1>-- 复合索引
</span></span></span></code></pre></td></tr></table></div></div><a href=#031-唯一索引是否影响性能><h3 id=031-唯一索引是否影响性能><span class=hanchor arialabel=Anchor># </span>031 唯一索引是否影响性能？</h3></a><p>是</p><a href=#032-什么时候使用唯一索引><h3 id=032-什么时候使用唯一索引><span class=hanchor arialabel=Anchor># </span>032 什么时候使用唯一索引？</h3></a><p>业务需求唯一字段的时候，一般不考虑性能问题
. 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明 显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必 然有脏数据产生。</p><a href=#033-什么时候适合创建索引什么时候不适合创建索引><h3 id=033-什么时候适合创建索引什么时候不适合创建索引><span class=hanchor arialabel=Anchor># </span>033 什么时候适合创建索引，什么时候不适合创建索引？</h3></a><p>适合创建索引</p><ul><li>频繁作为 where 条件语句查询字段</li><li>关联字段需要建立索引</li><li>排序字段可以建立索引</li><li>分组字段可以建立索引(因为分组前提是排序)</li><li>统计字段可以建立索引（如.count(),max()）
不适合创建索引</li><li>频繁更新的字段不适合建立索引</li><li>where，分组，排序中用不到的字段不必要建立索引</li><li>可以确定表数据非常少不需要建立索引</li><li>参与 mysql 函数计算的列不适合建索引
创建索引时避免有如下极端误解：
1）宁滥勿缺。认为一个查询就需要建一个索引。
2）宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。
3）抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</li></ul><a href=#034-什么是索引下推><h3 id=034-什么是索引下推><span class=hanchor arialabel=Anchor># </span>034 什么是索引下推？</h3></a><p>5.6 之前的版本是没有索引下推这个优化的
**Using index condition：叫作 Index Condition Pushdown Optimization （索引下推优化）</p><ul><li><code>如果没有索引下推（ICP）</code>，那么 MySQL 在存储引擎层找到满足<code>content1 > 'z'</code>条件的第一条二级索引记录。主键值进行回表，返回完整的记录给 server 层，server 层再判断其他的搜索条件是否成立。如果成立则保留该记录，否则跳过该记录，然后向存储引擎层要下一条记录。</li><li><code>如果使用了索引下推（ICP</code>），那么 MySQL 在存储引擎层找到满足<code>content1 > 'z'</code>条件的第一条二级索引记录。不着急执行回表，而是在这条记录上先判断一下所有关于<code>idx_content1</code>索引中包含的条件是否成立，也就是<code>content1 > 'z' AND content1 LIKE '%a'</code>是否成立。如果这些条件不成立，则直接跳过该二级索引记录，去找下一条二级索引记录；如果这些条件成立，则执行回表操作，返回完整的记录给 server 层。
总结：
未开启索引下推：</li><li>根据筛选条件在索引树中筛选第一个条件</li><li>获得结果集后回表操作</li><li>进行其他条件筛选</li><li>再次回表查询
开启索引下推：在条件查询时，当前索引树如果满足全部筛选条件，可以在当前树中完成全部筛选过滤，得到比较小的结果集再进行回表操作</li></ul><a href=#035-有哪些情况会导致索引失效><h3 id=035-有哪些情况会导致索引失效><span class=hanchor arialabel=Anchor># </span>035 有哪些情况会导致索引失效？</h3></a><ul><li>计算、函数导致索引失效</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>-- 显示查询分析
</span></span><span class=line><span class=cl>EXPLAIN SELECT * FROM emp WHERE emp.name LIKE &#39;abc%&#39;;
</span></span><span class=line><span class=cl>EXPLAIN SELECT * FROM emp WHERE LEFT(emp.name,3) = &#39;abc&#39;; --索引失效
</span></span></code></pre></td></tr></table></div></div><ul><li>LIKE 以%，_ 开头索引失效</li></ul><blockquote><p><strong>拓展：Alibaba《Java 开发手册》</strong>
【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>EXPLAIN SELECT * FROM emp WHERE name LIKE &#39;%ab%&#39;; --索引失效
</span></span></code></pre></td></tr></table></div></div><ul><li>不等于(!= 或者&lt;>)索引失效</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.name = &#39;abc&#39; ;
</span></span><span class=line><span class=cl>EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.name &lt;&gt; &#39;abc&#39; ; --索引失效
</span></span></code></pre></td></tr></table></div></div><ul><li>IS NOT NULL 失效 和 IS NULL</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>EXPLAIN SELECT * FROM emp WHERE emp.name IS NULL;
</span></span><span class=line><span class=cl>EXPLAIN SELECT * FROM emp WHERE emp.name IS NOT NULL; --索引失效
</span></span></code></pre></td></tr></table></div></div><p>**注意：当数据库中的数据的索引列的<code>NULL值达到比较高的比例的时候</code>，即使在 IS NOT NULL 的情况下 MySQL 的查询优化器会选择使用索引，<code>此时type的值是range（范围查询）</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 将 id&gt;20000 的数据的 name 值改为 NULL
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>emp</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=o>`</span><span class=n>name</span><span class=o>`</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>20000</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 执行查询分析，可以发现 IS NOT NULL 使用了索引
</span></span></span><span class=line><span class=cl><span class=c1>-- 具体多少条记录的值为NULL可以使索引在IS NOT NULL的情况下生效，由查询优化器的算法决定
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>emp</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>emp</span><span class=p>.</span><span class=n>name</span><span class=w> </span><span class=k>IS</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>类型转换导致索引失效</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>emp</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>name</span><span class=o>=</span><span class=s1>&#39;123&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>emp</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>name</span><span class=o>=</span><span class=w> </span><span class=mi>123</span><span class=p>;</span><span class=w> </span><span class=c1>--索引失效
</span></span></span></code></pre></td></tr></table></div></div><ul><li>复合索引未用左列字段失效</li><li>如果 mysql 觉得全表扫描更快时（数据少）;</li></ul><a href=#036-为什么-like-以开头索引会失效><h3 id=036-为什么-like-以开头索引会失效><span class=hanchor arialabel=Anchor># </span>036 为什么 LIKE 以%开头索引会失效？</h3></a><p>id,name,age
name 创建索引
select * from user where name like &lsquo;%明&rsquo;
type=all
select name,id from user where name like &lsquo;%明&rsquo;
type=index
张明
(name,age)
其实并不会完全失效，覆盖索引下会出现 type=index，表示遍历了索引树，再回表查询，
覆盖索引没有生效的时会直接 type=all
没有高效使用索引是因为字符串索引会逐个转换成 accii 码，生成 b+树时按首个字符串顺序排序，类似复合索引未用左列字段失效一样，跳过开始部分也就无法使用生成的 b+树了</p><a href=#037-一个表有多个索引的时候能否手动选择使用哪个索引><h3 id=037-一个表有多个索引的时候能否手动选择使用哪个索引><span class=hanchor arialabel=Anchor># </span>037 一个表有多个索引的时候，能否手动选择使用哪个索引？</h3></a><p>不可用手动直接干预，只能通过 mysql 优化器自动选择</p><a href=#038-如何查看一个表的索引><h3 id=038-如何查看一个表的索引><span class=hanchor arialabel=Anchor># </span>038 如何查看一个表的索引？</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>show index from t_emp; // 显示表上的索引
</span></span><span class=line><span class=cl>explain select * from t_emp where id=1; // 显示可能会用到的索引及最终使用的索引
</span></span></code></pre></td></tr></table></div></div><a href=#039-能否查看到索引选择的逻辑是否使用过-optimizer_trace><h3 id=039-能否查看到索引选择的逻辑是否使用过-optimizer_trace><span class=hanchor arialabel=Anchor># </span>039 能否查看到索引选择的逻辑？是否使用过 optimizer_trace？</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>set session optimizer_trace=&#34;enabled=on&#34;,end_markers_in_json=on;
</span></span><span class=line><span class=cl>SELECT * FROM information_schema.OPTIMIZER_TRACE;
</span></span><span class=line><span class=cl>set session optimizer_trace=&#34;enabled=off&#34;;
</span></span></code></pre></td></tr></table></div></div><a href=#040-多个索引优先级是如何匹配的><h3 id=040-多个索引优先级是如何匹配的><span class=hanchor arialabel=Anchor># </span>040 多个索引优先级是如何匹配的？</h3></a><ol><li>主键（唯一索引）匹配</li><li>全值匹配（单值匹配）</li><li>最左前缀匹配</li><li>范围匹配</li><li>索引扫描</li><li>全表扫描
一般性建议</li></ol><ul><li>对于单键索引，尽量选择过滤性更好的索引（例如：手机号，邮件，身份证）</li><li>在选择组合索引的时候，过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>选择组合索引时，尽量包含 where 中更多字段的索引</li><li>组合索引出现范围查询时，尽量把这个字段放在索引次序的最后面</li><li>尽量避免造成索引失效的情况</li></ul><a href=#041-使用-order-by-时能否通过索引排序><h3 id=041-使用-order-by-时能否通过索引排序><span class=hanchor arialabel=Anchor># </span>041 使用 Order By 时能否通过索引排序？</h3></a><p>没有过滤条件不走索引</p><a href=#042-通过索引排序内部流程是什么><h3 id=042-通过索引排序内部流程是什么><span class=hanchor arialabel=Anchor># </span>042 通过索引排序内部流程是什么？</h3></a><p>select name,id from user where name like &lsquo;%明&rsquo; order by name；
select name,id，age from user where name like &lsquo;%明&rsquo;
关键配置：</p><ul><li>sort_buffer 可供排序的内存缓冲区大小</li><li>max_length_for_sort_data 单行所有字段总和限制，超过这个大小启动双路排序</li></ul><ol><li>通过索引检过滤筛选条件索到需要排序的字段+其他字段（如果是符合索引）</li><li>判断索引内容是否覆盖 select 的字段</li><li>如果覆盖索引，select 的字段和排序都在索引上，那么在内存中进行排序，排序后输出结果</li><li>如果索引没有覆盖查询字段，接下来计算 select 的字段是否超过 max_length_for_sort_data 限制，如果超过，启动双路排序，否则使用单路</li></ol><a href=#043-什么是双路排序和单路排序><h3 id=043-什么是双路排序和单路排序><span class=hanchor arialabel=Anchor># </span>043 什么是双路排序和单路排序</h3></a><p>单路排序：一次取出所有字段进行排序，内存不够用的时候会使用磁盘
双路排序：取出排序字段进行排序，排序完成后再次回表查询所需要的其他字段
如果不在索引列上，filesort 有两种算法： mysql 就要启动双路排序和单路排序
<strong>双路排序（慢）</strong>
Select id,age,name from stu order by name;</p><ul><li>MySQL 4.1 之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和 order by 列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li><li>从磁盘取排序字段，在 buffer 进行排序，再从磁盘取其他字段。</li><li>取一批数据，要对磁盘进行两次扫描，众所周知，I\O 是很耗时的，所以在 mysql4.1 之后，出现了第二种改进的算法，就是单路排序。
<strong>单路排序（快）</strong>
从磁盘读取查询需要的所有列，按照 order by 列在 buffer 对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。
<strong>结论及引申出的问题</strong>
但是用单路有问题
在 sort_buffer 中，单路比多路要多占用很多空间，因为单路是把所有字段都取出, 所以有可能取出的数据的总大小超出了 sort_buffer 的容量，导致每次只能取 sort_buffer 容量大小的数据，进行排序（创建 tmp 文件，多路合并），排完再取 sort_buffer 容量大小，再排……从而多次 I/O。
单路本来想省一次 I/O 操作，反而导致了大量的 I/O 操作，反而得不偿失。
<strong>优化策略</strong></li><li>增大 sort_buffer_size 参数的设置</li><li>增大 max_length_for_sort_data 参数的设置</li><li>减少 select 后面的查询的字段。 禁止使用 select *
<strong>提高 Order By 的速度</strong>
\1. Order by 时 select * 是一个大忌。只 Query 需要的字段， 这点非常重要。在这里的影响是：</li><li>当 Query 的字段大小总和小于 max_length_for_sort_data 而且排序字段不是 TEXT|BLOB 类型时，会用改进后的算法——单路排序， 否则用老算法——多路排序。</li><li>两种算法的数据都有可能超出 sort_buffer 的容量，超出之后，会创建 tmp 文件进行合并排序，导致多次 I/O，但是用单路排序算法的风险会更大一些，所以要提高 sort_buffer_size。
\2. 尝试提高 sort_buffer_size</li><li>不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程（connection）的 1M-8M 之间调整。 MySQL5.7 和 8.0，InnoDB 存储引擎默认值是 1048576 字节，1MB。
SHOW VARIABLES LIKE &lsquo;%sort_buffer_size%&rsquo;;
\3. 尝试提高 max_length_for_sort_data</li><li>提高这个参数， 会增加用改进算法的概率。
SHOW VARIABLES LIKE &lsquo;%max_length_for_sort_data%&rsquo;;</li></ul><blockquote><p>5.7 默认 1024 字节 8.0 默认 4096 字节</p></blockquote><ul><li>但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大，明显症状是高的磁盘 I/O 活动和低的处理器使用率。如果需要返回的列的总长度大于 max_length_for_sort_data，使用双路算法，否则使用单路算法。1024-8192 字节之间调整</li></ul><a href=#044-group-by-分组和-order-by-在索引使用上有什么区别><h3 id=044-group-by-分组和-order-by-在索引使用上有什么区别><span class=hanchor arialabel=Anchor># </span>044 group by 分组和 order by 在索引使用上有什么区别？</h3></a><p>group by 使用索引的原则几乎跟 order by 一致 ，唯一区别：</p><ul><li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li><li>group by 没有过滤条件，也可以用上索引。Order By 必须有过滤条件才能使用上索引。</li></ul><a href=#045-如果表中有字段为-null又被经常查询该不该给这个字段创建索引><h3 id=045-如果表中有字段为-null又被经常查询该不该给这个字段创建索引><span class=hanchor arialabel=Anchor># </span>045 如果表中有字段为 null，又被经常查询该不该给这个字段创建索引？</h3></a><p>应该创建索引，使用的时候尽量使用 is null 判断。</p><ul><li>IS NOT NULL 失效 和 IS NULL</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>EXPLAIN SELECT * FROM emp WHERE emp.name IS NULL;
</span></span><span class=line><span class=cl>EXPLAIN SELECT * FROM emp WHERE emp.name IS NOT NULL; --索引失效
</span></span></code></pre></td></tr></table></div></div><p>**注意：当数据库中的数据的索引列的<code>NULL值达到比较高的比例的时候</code>，即使在 IS NOT NULL 的情况下 MySQL 的查询优化器会选择使用索引，<code>此时type的值是range（范围查询）</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 将 id&gt;20000 的数据的 name 值改为 NULL
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>emp</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=o>`</span><span class=n>name</span><span class=o>`</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>20000</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 执行查询分析，可以发现 IS NOT NULL 使用了索引
</span></span></span><span class=line><span class=cl><span class=c1>-- 具体多少条记录的值为NULL可以使索引在IS NOT NULL的情况下生效，由查询优化器的算法决定
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>emp</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>emp</span><span class=p>.</span><span class=n>name</span><span class=w> </span><span class=k>IS</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><a href=#046-有字段为-null-索引是否会失效><h3 id=046-有字段为-null-索引是否会失效><span class=hanchor arialabel=Anchor># </span>046 有字段为 null 索引是否会失效？</h3></a><p>不一定会失效，每一条 sql 具体有没有使用索引 可以通过 trace 追踪一下
最好还是给上默认值
数字类型的给 0，字符串给个空串“”，
参考
<a href=/Mysql/ rel=noopener class=internal-link data-src=/Mysql/>045 如果表中有字段为 null，又被经常查询该不该给这个字段创建索引？</a></p><a href=#二-mysql-内部技术架构><h2 id=二-mysql-内部技术架构><span class=hanchor arialabel=Anchor># </span>二 MySQL 内部技术架构</h2></a><p><img src=https://jieye-ericx.github.io//../../pics/image-20221028155608009.png width=auto alt=image-20221028155608009>
<img src=https://jieye-ericx.github.io//../../pics/29f7e85dea17e100b38b450d9949a330.png width=auto alt=img></p><a href=#047-mysql-内部支持缓存查询吗><h3 id=047-mysql-内部支持缓存查询吗><span class=hanchor arialabel=Anchor># </span>047 Mysql 内部支持缓存查询吗？</h3></a><p>当 MySQL 接收到客户端的查询 SQL 之后，仅仅只需要对其进行相应的权限验证之后，就会通过 Query Cache 来查找结果，甚至都不需要经过 Optimizer 模块进行执行计划的分析优化，更不需要发生任何存储引擎的交互
mysql5.7 支持内部缓存，8.0 之后就废弃掉了</p><a href=#048-mysql8-为何废弃掉查询缓存><h3 id=048-mysql8-为何废弃掉查询缓存><span class=hanchor arialabel=Anchor># </span>048 mysql8 为何废弃掉查询缓存？</h3></a><p>缓存的意义在于快速查询提升系统性能，可以灵活控制缓存的一致性
mysql 缓存的限制</p><ol><li>mysql 基本没有手段灵活的管理缓存失效和生效，尤其对于频繁更新的表</li><li>SQL 必须完全一致才会导致 cache 命中</li><li>为了节省内存空间，太大的 result set 不会被 cache (&lt; query_cache_limit)；</li><li>MySQL 缓存在分库分表环境下是不起作用的；</li><li>执行 SQL 里有触发器,自定义函数时，MySQL 缓存也是不起作用的；</li><li>在表的结构或数据发生改变时，基于该表相关 cache 立即全部失效。</li></ol><a href=#049-缓存替代方案是什么><h3 id=049-缓存替代方案是什么><span class=hanchor arialabel=Anchor># </span>049 缓存替代方案是什么？</h3></a><p>应用层组织缓存，最简单的是使用 redis，ehcached 等</p><a href=#050-mysql-内部有哪些核心模块组成作用是什么><h3 id=050-mysql-内部有哪些核心模块组成作用是什么><span class=hanchor arialabel=Anchor># </span>050 Mysql 内部有哪些核心模块组成，作用是什么？</h3></a><p><img src=https://jieye-ericx.github.io//../../pics/image-20220627113443003.png width=auto alt=image-20220627113443003>
<strong>Connectors（客户端）</strong>
MySQL 服务器之外的客户端程序，与具体的语言相关，例如 Java 中的 JDBC，图形用户界面 SQLyog 等。<code>本质上都是在TCP连接上通过MySQL协议和MySQL服务器进行通信。</code>
<strong>MySQL Server（服务器）</strong>
<strong>第 1 层：连接层</strong></p><ul><li>系统（客户端）访问 MySQL 服务器前，做的<code>第一件事就是建立 TCP 连接</code>。</li><li>经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做<code>身份认证、权限获取</code>。</li><li>用户名或密码不对<code>，会收到一个</code>Access denied for user<code>错误，客户端程序结束执行</code></li><li><code>用户名密码认证通过</code>，会从权限表<code>查出账号拥有的权限</code>与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</li><li>TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。
<strong>第 2 层：服务层</strong>
<strong>Management Serveices & Utilities： 系统管理和控制工具</strong>
<strong>SQL Interface：SQL 接口：</strong></li><li><code>接收用户的SQL命令，并且返回用户需要查询的结果。</code>比如 SELECT &mldr; FROM 就是调用 SQL Interface</li><li>MySQL 支持 DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种 SQL 语言接口
<strong>Parser：解析器：</strong></li><li>在 SQL 命令传递到解析器的时候会被解析器验证和解析。解析器中 SQL 语句进行<code>语法分析、语法解析</code>，并为其创建<code>语法树</code>。</li><li><strong>语法分析</strong>
语法分析主要是把输入转化成若干个 tokens，包含 key 和非 key。
在分析之后，会得到 4 个 Token，其中有 2 个 key，它们分别是 SELECT、FROM。
| key | 非 key | key | 非 key |
| SELECT | age | FROM | user |</li><li>典型的解析树如下：
<img src=https://jieye-ericx.github.io//../../pics/image-20220702002430362.png width=auto alt=image-20220702002430362>
<strong>Optimizer：查询优化器：</strong></li><li>SQL 语句在语法解析后、查询前会使用查询优化器对查询进行优化，<code>确定SQL语句的执行路径，生成一个执行计划</code>。
<strong>Caches & Buffers： 查询缓存组件：</strong></li><li>MySQL 内部维持着一些 Cache 和 Buffer，比如 Query Cache 用来缓存一条 SELECT 语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、查询优化和执行的整个过程了，直接将结果反馈给客户端。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等。</li><li>这个查询缓存可以在不同客户端之间共享 。
<strong>第 3 层 引擎层</strong>
插件式存储引擎层（ Storage Engines），<code>负责MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信</code>。不同的存储引擎具有的功能不同，管理的表有不同的存储结构，采用的存取算法也不同，这样我们可以根据自己的实际需要进行选取。例如 MyISAM 引擎和 InnoDB 引擎。
<strong>存储层</strong>
所有的数据、数据库、表的定义、表的每一行的内容、索引，都是存在<code>文件系统</code> 上，以文件的方式存在，并完成与存储引擎的交互。</li></ul><a href=#051-一条-sql-发送给-mysql-后内部是如何执行的说一下-mysql-执行一条查询语句的内部执行过程><h3 id=051-一条-sql-发送给-mysql-后内部是如何执行的说一下-mysql-执行一条查询语句的内部执行过程><span class=hanchor arialabel=Anchor># </span>051 一条 sql 发送给 mysql 后，内部是如何执行的？（说一下 MySQL 执行一条查询语句的内部执行过程？）</h3></a><p><img src=https://jieye-ericx.github.io//../../pics/%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png width=auto alt=image-20220627141453944>
<strong>首先，</strong><code>MySQL客户端通过协议与MySQL服务器建连接，通过SQL接口发送SQL语句，先检查查询缓存，如果命中，直接返回结果，否则进行语句解析。</code>也就是说，在解析查询之前，服务器会先访问查询缓存，如果某个查询结果已经位于缓存中，服务器就不会再对查询进行解析、优化、以及执行。它仅仅将缓存中的结果返回给用户即可，这将大大提高系统的性能。
<strong>接下来，</strong><code>MySQL解析器通过关键字将SQL语句进行解析，并生成一棵对应的解析树，</code>解析器使用 MySQL 语法规则验证和解析SQL语句。例如，它将验证是否使用了错误的关键字，或者使用关键字的顺序是否正确，引号能否前后匹配等；<code>预处理器则根据MySQL规则进一步检查解析树是否合法，</code>例如，这里将检查数据表和数据列是否存在，还会解析名字和别名，看是否有歧义等。<code>然后预处理器会进行查询重写，生成一棵新解析树。</code>
<strong>接下来</strong>查询优化器将解析树转化成<strong>执行计划</strong>。MySQL 优化程序会对我们的语句做一些优化，如子查询转换为连接、表达式简化等等。优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引执行查询，以及表之间的连接顺序是啥样，等等。我们可以使用EXPLAIN 语句来查看某个语句的执行计划。
<strong>最后，</strong><code>进入执行器阶段。</code>完成查询优化后，<code>查询执行引擎</code>会按照生成的执行计划调用存储引擎提供的接口执行 SQL 查询并将结果返回给客户端。在 MySQL8 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存，再返回给客户端。</p><a href=#052-mysql-提示不存在此列是执行到哪个节点报出的><h3 id=052-mysql-提示不存在此列是执行到哪个节点报出的><span class=hanchor arialabel=Anchor># </span>052 MySQL 提示“不存在此列”是执行到哪个节点报出的？</h3></a><p>是在 Parser：解析器 分析 sql 语法的时候检查的列。</p><a href=#053-如果一张表创建了多个索引在哪个阶段或模块进行的索引选择><h3 id=053-如果一张表创建了多个索引在哪个阶段或模块进行的索引选择><span class=hanchor arialabel=Anchor># </span>053 如果一张表创建了多个索引，在哪个阶段或模块进行的索引选择？</h3></a><p>在优化器阶段<strong>Optimizer：查询优化器：</strong></p><a href=#054-mysql-支持哪些存储引擎默认使用哪个><h3 id=054-mysql-支持哪些存储引擎默认使用哪个><span class=hanchor arialabel=Anchor># </span>054 MySQL 支持哪些存储引擎？默认使用哪个？</h3></a><p>查看 MySQL 提供什么存储引擎<code>SHOW ENGINES;</code>
下面的结果表示 MySQL 中默认使用的存储引擎是 InnoDB，支持事务，行锁，外键，支持分布式事务(XA)，支持保存点(回滚)
<img src=https://jieye-ericx.github.io//../../pics/image-20220703164220030.png width=auto alt=image-20220703164220030>
也可以通过以下语句查看默认的存储引擎：
<code>SHOW VARIABLES LIKE '%default_storage_engine%';</code>
<img src=https://jieye-ericx.github.io//../../pics/image-20220703170334348.png width=auto alt=image-20220703170334348></p><a href=#055-mysql80-自带哪些存储引擎分别是做什么的><h3 id=055-mysql80-自带哪些存储引擎分别是做什么的><span class=hanchor arialabel=Anchor># </span>055 Mysql8.0 自带哪些存储引擎？分别是做什么的？</h3></a><p><code>1. InnoDB存储引擎</code></p><ul><li>InnoDB 是 MySQL 的默认事务型引擎，它被设计用来<code>处理大量的短期(short-lived)事务</code>。可以确保事务的完整提交(Commit)和回滚(Rollback)。</li><li>除非有非常特别的原因需要使用其他的存储引擎，否则<code>应该优先考虑InnoDB引擎</code>。</li><li>数据文件结构：</li><li>表名.frm 存储表结构（MySQL8.0 时，合并在表名.ibd 中）</li><li>表名.ibd 存储数据和索引</li><li>InnoDB 不仅缓存索引还要缓存真实数据， 对内存要求较 高 ，而且内存大小对性能有决定性的影响。
<code>2. MyISAM存储引擎</code></li><li>MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但<code>MyISAM不支持事务和行级锁</code>，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</li><li>优势是访问的 速度快 ，对事务完整性没有要求或者以 SELECT、INSERT 为主的应用。</li><li>数据文件结构：</li><li>表名.frm 存储表结构</li><li>表名.MYD 存储数据</li><li>表名.MYI 存储索引</li><li>MyISAM 只缓存索引，不缓存真实数据。
<code>3. Archive引擎</code></li><li><code>Archive档案存储引擎只支持INSERT和SELECT操作</code>。</li><li>Archive 表适合日志和数据采集（档案）类应用。</li><li>根据英文的测试结论来看，Archive 表比 MyISAM 表要小大约 75%，比支持事务处理的 InnoDB 表小大约 83%。
<code>4. Blackhole引擎</code></li><li><code>Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存</code>。</li><li>但服务器会记录 Blackhole 表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。
<code>5. CSV引擎</code></li><li><code>CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引</code>。</li><li>CSV 引擎可以作为一种数据交换的机制，非常有用。</li><li>CSV 存储的数据直接可以在操作系统里，用文本编辑器，或者 excel 读取。
<code>6. Memory引擎</code></li><li>如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用 Memory 表是非常有用。</li><li>Memory 表至少比 MyISAM 表要快一个数量级。
<code>7. Federated引擎</code></li><li><code>Federated引擎是访问其他MySQL服务器的一个代理（跨库关联查询）</code>，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</li></ul><a href=#056-mysql-存储引擎架构了解吗><h3 id=056-mysql-存储引擎架构了解吗><span class=hanchor arialabel=Anchor># </span>056 MySQL 存储引擎架构了解吗？</h3></a><p><a href=https://dev.mysql.com/doc/refman/5.7/en/innodb-architecture.html rel=noopener>https://dev.mysql.com/doc/refman/5.7/en/innodb-architecture.html</a>
下面是官方的 InnoDB 引擎结构图，主要分为内存结构和磁盘结构两大部分。
<img src=https://jieye-ericx.github.io//../../pics/16701032-f8547d110ba34135.png width=auto alt=img>
<strong>内存区域</strong>
<strong>Buffer Pool</strong>:在 InnoDB 访问表记录和索引时会在 Buffer Pool 的页中缓存，以后使用可以减少磁盘 IO 操作，提升效率。主要用来缓存热的数据页和索引页。
<strong>Log Buffer</strong>：用来缓存 redolog
<strong>Adaptive Hash Index</strong>：自适应哈希索引
<strong>Change Buffer</strong>:它是一种应用在非唯一普通索引页（non-unique secondary index page）不在缓冲池中，对页进行了写操作，并不会立刻将磁盘页加载到缓冲池，而仅仅记录缓冲变更（Buffer Changes），等未来数据被读取时，再将数据合并（Merge）恢复到缓冲池中的技术。写缓冲的目的是降低写操作的磁盘 IO，提升数据库性能。
<strong>磁盘区域</strong>
磁盘中的结构分为两大类：表空间和重做日志。</p><ul><li>表空间：分为系统表空间(MySQL 目录的 ibdata1 文件)，临时表空间，常规表空间，Undo 表空间以及 file-per-table 表空间(MySQL5.7 默认打开 file_per_table 配置）。系统表空间又包括了 InnoDB 数据字典，双写缓冲区(Doublewrite Buffer)，修改缓存(Change Buffer），Undo 日志等。</li><li>Redo 日志：存储的就是 Log Buffer 刷到磁盘的数据。
官方文档：
<a href=https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html rel=noopener>https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html</a></li></ul><a href=#057-能否单独为一张表设置存储引擎><h3 id=057-能否单独为一张表设置存储引擎><span class=hanchor arialabel=Anchor># </span>057 能否单独为一张表设置存储引擎？</h3></a><p>方法1：设置默认存储引擎：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SET</span><span class=w> </span><span class=n>DEFAULT_STORAGE_ENGINE</span><span class=o>=</span><span class=n>MyISAM</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>方法2：
或者修改 my.cnf 文件：vim /etc/my.cnf
新增一行：default-storage-engine=MyISAM
重启 MySQL：systemctl restart mysqld
方法3：
我们可以为不同的表设置不同的存储引擎</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=err>表名</span><span class=p>(</span><span class=w> </span><span class=err>建表语句</span><span class=p>;</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=n>ENGINE</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=err>存储引擎名称</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=err>表名</span><span class=w> </span><span class=n>ENGINE</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=err>存储引擎名称</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><a href=#058-阿里京东等大厂都有自研的存储引擎如何开发一套自己的><h3 id=058-阿里京东等大厂都有自研的存储引擎如何开发一套自己的><span class=hanchor arialabel=Anchor># </span>058 阿里、京东等大厂都有自研的存储引擎，如何开发一套自己的？</h3></a><p>开发存储引擎并不难，难的是开发出来高效的有意义的存储引擎。
简单例子可以看一下官方源码中的示例，可以实现一个什么也没做的存储引擎。
有兴趣可以参考官方文档：https://dev.mysql.com/doc/dev/mysql-server/latest/</p><a href=#059-myisam-和-innodb-的区别是什么><h3 id=059-myisam-和-innodb-的区别是什么><span class=hanchor arialabel=Anchor># </span>059 MyISAM 和 InnoDB 的区别是什么？</h3></a><p>外键 事务 锁</p><table><thead><tr><th><strong>对比项</strong></th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td>行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td>关注点</td><td>并发查询，节省资源、消耗少、简单业务</td><td>并发写、事务、多表关系、更大资源</td></tr><tr><td>默认安装</td><td>Y</td><td>Y</td></tr><tr><td>默认使用</td><td>N</td><td>Y</td></tr><tr><td>自带系统表使用</td><td>Y</td><td>N</td></tr></tbody></table><a href=#060-具体说一下如何做技术选型><h3 id=060-具体说一下如何做技术选型><span class=hanchor arialabel=Anchor># </span>060 具体说一下如何做技术选型</h3></a><p>除非几乎没有写操作全部都是高频的读操作可以选择 MyISAM 作为表的存储引擎，其他业务可以一律使用 InnoDB。</p><a href=#三-mysql-事务><h2 id=三-mysql-事务><span class=hanchor arialabel=Anchor># </span>三 mysql 事务</h2></a><a href=#061-什么是数据库事务事务的特性是什么><h3 id=061-什么是数据库事务事务的特性是什么><span class=hanchor arialabel=Anchor># </span>061 什么是数据库事务？事务的特性是什么？</h3></a><p><strong>事务</strong>：</p><ul><li>是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；</li><li>这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；</li><li>事务是一组不可再分割的操作集合（工作逻辑单元）
事务都有 <strong>ACID</strong> 特性</li></ul><a href=#062-什么是-acid><h3 id=062-什么是-acid><span class=hanchor arialabel=Anchor># </span>062 什么是 ACID？</h3></a><p><strong>1 、原子性</strong> atomicity
过程的保证
<strong>只做一个步骤</strong>
1 给钱
2 去买
3 交回来
事务是数据库的逻辑工作单位，事务中包含的各操作<strong>要么都做，要么都不做</strong>
<strong>2 、一致性</strong> consistency
结果的保证
<strong>保证要吃完</strong> 刚张嘴挂了，失去一致性
事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。
<strong>3 、隔离性</strong> isolation
并发事务互相干扰
<strong>不被干扰</strong> 刚张嘴别人塞了东西
一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
<strong>4 、持续性</strong> <strong>永久性</strong> durability
<strong>保存</strong> 吃到肚子里
也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</p><a href=#063-并发事务会有哪些问题><h3 id=063-并发事务会有哪些问题><span class=hanchor arialabel=Anchor># </span>063 并发事务会有哪些问题？</h3></a><p>多个事务并发执行一定会产生相互争夺资源的问题</p><a href=#064-什么是脏读-065-丢失修改-066-不可重复读-067-幻读><h3 id=064-什么是脏读-065-丢失修改-066-不可重复读-067-幻读><span class=hanchor arialabel=Anchor># </span>064 什么是脏读 065 丢失修改 066 不可重复读 067 幻读</h3></a><p><strong>脏读（Dirty read）</strong>
是一个事务在处理过程中读取了另外一个事务未提交的数据
当一个事务正在访问数据并且对其进行了修改，但是还没提交事务，这时另外一个事务也访问了这个数据，然后使用了这个数据，因为这个数据的修改还没提交到数据库，所以另外一个事务读取的数据就是“<strong>脏数据</strong>”，这种行为就是“<strong>脏读</strong>”，依据“<strong>脏数据</strong>”所做的操作可能是会出现问题的。
<strong>修改丢失（Lost of modify）</strong>
是指一个事务读取一个数据时，另外一个数据也访问了该数据，那么在第一个事务修改了这个数据之后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，这种情况就被称为**修改丢失
<strong>不可重复读（Unrepeatableread）</strong>
指在一个事务内多<strong>次读取同一数据</strong>，在这个事务还没结束时，另外一个事务也访问了这个数据并<strong>对这个数据进行了修改</strong>，那么就可能造成第一个事务两次读取的数据不一致，这种情况就被称为不可重复读。
<strong>幻读（Phantom read）</strong>
是指同一个事务内多次查询返回的结果集总数不一样（比如增加了或者减少了行记录）。
幻读与不可重复读类似，幻读是指一个事务<strong>读取了几行数据</strong>，这个事务还没结束，接着另外一个事务<strong>插入了一些数据</strong>，在随后的查询中，第一个事务读取到的数据就会<strong>比原本读取到的多</strong>，就好像发生了幻觉一样，所以称为**幻读**。</p><a href=#068-不可重复读和幻读有什么区别><h3 id=068-不可重复读和幻读有什么区别><span class=hanchor arialabel=Anchor># </span>068 不可重复读和幻读有什么区别？</h3></a><p>不可重复读 针对的是一份数据的修改
幻读 针对的是行数修改</p><a href=#069-mysql-是如何避免事务并发问题的><h3 id=069-mysql-是如何避免事务并发问题的><span class=hanchor arialabel=Anchor># </span>069 Mysql 是如何避免事务并发问题的？</h3></a><p>避免事务并发问题是需要付出性能代价的，此时和分布式系统设计一样（CAP 定理及 base 理论），为了保证一致性就一定会牺牲性能，要做取舍
在 mysql 内部通过加锁的方式实现好了解决方案可供选择，就是配置事务隔离级别</p><a href=#070-什么是事务隔离级别><h3 id=070-什么是事务隔离级别><span class=hanchor arialabel=Anchor># </span>070 什么是事务隔离级别？</h3></a><p>事务隔离级别 脏读 不可重复读(被修改) 幻读（删减）
读未提交（read-uncommitted） 是 是 是
不可重复读（read-committed） 否 是 是
可重复读（repeatable-read） 否 否 是
串行化（serializable） 否 否 否</p><a href=#071-默认的级别是什么><h3 id=071-默认的级别是什么><span class=hanchor arialabel=Anchor># </span>071 默认的级别是什么？</h3></a><p><code>MySQL InnoDB</code>存储引擎默认的事务隔离级别是<strong>可重复读（REPEATABLE-READ）</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>MySQL 5.7 SELECT @@tx_isolation;
</span></span><span class=line><span class=cl>MySQL 8.0 SELECT @@transaction_isolation;
</span></span></code></pre></td></tr></table></div></div><a href=#072-如何选择事务隔离级别><h3 id=072-如何选择事务隔离级别><span class=hanchor arialabel=Anchor># </span>072 如何选择事务隔离级别？</h3></a><p>隔离级别越低，事务请求的锁越少相应性能也就越高，如没有特殊要求或有错误发生，使用默认的隔离级别即可，如果系统中有高频读写并且对一致性要求高那么就需要比较高的事务隔离级别甚至串行化。</p><a href=#073-靠缓存可以提升高事务隔离级别的性能吗><h3 id=073-靠缓存可以提升高事务隔离级别的性能吗><span class=hanchor arialabel=Anchor># </span>073 靠缓存可以提升高事务隔离级别的性能吗？</h3></a><p>提升事务级别的目的本质是提供更高的数据一致性，如果前置有缓存，那么缓存只能提供高效读并不能保证数据及时一致性，相反的我们还需要对缓存管理有额外的开销。</p><a href=#074-mysql-事务隔离是如何实现的><h3 id=074-mysql-事务隔离是如何实现的><span class=hanchor arialabel=Anchor># </span>074 Mysql 事务隔离是如何实现的？</h3></a><p>隔离的实现主要是读写锁和 MVCC</p><a href=#075-什么是一致性非锁定读和锁定读><h3 id=075-什么是一致性非锁定读和锁定读><span class=hanchor arialabel=Anchor># </span>075 什么是一致性非锁定读和锁定读？</h3></a><p><strong>锁定读</strong>
使用到了读写锁
读写锁是最简单直接的的事务隔离实现方式</p><ul><li>每次读操作需要获取一个共享(读)锁，每次写操作需要获取一个写锁。</li><li>共享锁之间不会产生互斥，共享锁和写锁之间、以及写锁与写锁之间会产生互斥。</li><li>当产生锁竞争时，需要等待其中一个操作释放锁后，另一个操作才能获取到锁。
锁机制，解决的就是<strong>多个事务同时更新数据</strong>，此时必须要有一个加锁的机制</li><li>行锁（记录锁）：解决的就是<strong>多个事务同时更新一行数据</strong></li><li>间隙锁：解决的就是<strong>多个事务同时更新多行数据</strong>
下列操作属于锁定读</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>select ... lock in share mode
</span></span><span class=line><span class=cl>select ... for update
</span></span><span class=line><span class=cl>insert、update、delete
</span></span></code></pre></td></tr></table></div></div><p><strong>非锁定读</strong>
v10 -> age=18
v11 ->age=19
v12 ->age=15
使用 mvcc 多版本控制实现</p><a href=#076-说一下-mvcc-内部细节><h3 id=076-说一下-mvcc-内部细节><span class=hanchor arialabel=Anchor># </span>076 说一下 MVCC 内部细节</h3></a><p><a href=https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html rel=noopener>https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html</a>
Multi-Version Concurrency Control 多版本并发控制，<em>MVCC</em> 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问
InnoDB 是一个多版本的存储引擎。它保存有关已更改行的旧版本的信息，以支持并发和回滚等事务特性。这些信息存储在一个称为回滚段的数据结构中的系统表空间或 undo 表空间中。参见第 14.6.3.4 节“撤消表空间”。InnoDB 使用回滚段中的信息来执行事务回滚所需的撤消操作。它还使用这些信息构建行的早期版本，以实现一致的读取
MVCC 的实现依赖于：隐藏字段、Read View、undo log
<strong>隐藏字段</strong></p><ul><li>A 6-byte <code>DB_TRX_ID</code> 用来标识最近一次对本行记录做修改 (insert 、update) 的事务的标识符 ，即最后一次修改本行记录的事务 id。 如果是 delete 操作， 在 InnoDB 存储引擎内部也属于一次 update 操作，即更新行中的一个特殊位 ，将行标识为己删除，并非真正删除。</li><li>A 7-byte <code>DB_ROLL_PTR</code> 回滚指针，指向该行的 undo log 。如果该行未被更新，则为空.</li><li>A 6-byte <code>DB_ROW_ID</code> 如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引.
<strong>Read View</strong>
不同的事务隔离级别中，当有事物在执行过程中修改了数据（更新版本号），在并发事务时需要判断一下版本链中的哪个版本是当前事务可见的。为此 InnoDB 有了 ReadView 的概念，使用 ReadView 来记录和隔离不同事务并发时此记录的哪些版本是对当前访问事物可见的。
<strong>undo log</strong>
除了用来回滚数据，还可以读取可见版本的数据。以此实现非锁定读</li></ul><a href=#077-mysql-事务一致性原子性是如何实现的><h3 id=077-mysql-事务一致性原子性是如何实现的><span class=hanchor arialabel=Anchor># </span>077 Mysql 事务一致性，原子性是如何实现的？</h3></a><p>事务的隔离性由 锁机制 实现。
而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。
REDO LOG 称为 重做日志 ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。
UNDO LOG 称为 回滚日志 ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</p><a href=#078mysql-事务的持久性是如何实现的><h3 id=078mysql-事务的持久性是如何实现的><span class=hanchor arialabel=Anchor># </span>078Mysql 事务的持久性是如何实现的？</h3></a><p>使用 Redo log 保证了事务的持久性。当事务提交时，必须先将事务的所有日志写入日志文件进行持久化，就是我们常说的 WAL(write ahead log)机制，如果出现断电重启便可以从 redolog 中恢复，如果 redolog 写入失败那么也就意味着修改失败整个事务也就直接回滚了。</p><a href=#079-表级锁和行级锁有什么区别><h3 id=079-表级锁和行级锁有什么区别><span class=hanchor arialabel=Anchor># </span>079 表级锁和行级锁有什么区别？</h3></a><p>表级锁：串行化（serializable）时，整表加锁，事务访问表数据时需要申请锁，虽然可分为读锁和写锁，但毕竟是锁住整张表，会导致并发能力下降，一般是做 ddl 处理时使用
行级锁：<strong>除了串行化（serializable）时 InnoDB 使用的都是行级锁</strong>，只锁一行数据，其他行数据不影响，并发能力强。</p><a href=#080-什么是行级锁mysql-如何完成的><h3 id=080-什么是行级锁mysql-如何完成的><span class=hanchor arialabel=Anchor># </span>080 什么是行级锁？Mysql 如何完成的？</h3></a><p><strong>行级锁实现比较复杂不是单纯锁住一行数据，是由 mvcc 完成的。</strong></p><a href=#081-什么是共享锁读锁><h3 id=081-什么是共享锁读锁><span class=hanchor arialabel=Anchor># </span>081 什么是共享锁（读锁）？</h3></a><p>共享锁或 S 锁，其它事务可以继续加共享锁，但不能加排它锁</p><a href=#082-什么是排它锁写锁独占锁><h3 id=082-什么是排它锁写锁独占锁><span class=hanchor arialabel=Anchor># </span>082 什么是排它锁（写锁/独占锁）？</h3></a><p>排它锁或 X 锁，在进行写操作之前要申请并获得，其它事务不能再获得任何锁。</p><a href=#083-什么是意向锁><h3 id=083-什么是意向锁><span class=hanchor arialabel=Anchor># </span>083 什么是意向锁？</h3></a><p>它分为意向共享锁（IS）和意向排他锁（IX）
一个事务对一张表的某行添加共享锁前，必须获得对该表一个 IS 锁或者优先级更高的锁。
一个事务对一张表的某行添加排他锁之前，它必须对该表获取一个 IX 锁。
<strong>意向锁属于表锁，它不与 innodb 中的行锁冲突，任意两个意向锁之间也不会产生冲突，但是会与表锁（S 锁和 X 锁）产生冲突</strong></p><a href=#084-innodb-支持哪几种锁><h3 id=084-innodb-支持哪几种锁><span class=hanchor arialabel=Anchor># </span>084 InnoDB 支持哪几种锁？</h3></a><p>表锁，行锁，间隙锁，Next-Key 锁等
在 Serializable 中读加共享锁，写加排他锁，读写互斥
两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）</p><a href=#085-当前读和快照读分别是什么><h3 id=085-当前读和快照读分别是什么><span class=hanchor arialabel=Anchor># </span>085 当前读和快照读分别是什么？</h3></a><p>当前读 ：在锁定读（使用锁隔离事物）的时候读到的是最新版本的数据
快照读：可重复读（repeatable-read）下 mvcc 生效读取的是数据的快照，并不是最新版本的数据（未提交事物的数据）</p><a href=#086-什么是-xa-协议><h3 id=086-什么是-xa-协议><span class=hanchor arialabel=Anchor># </span>086 什么是 XA 协议？</h3></a><p><a href=https://dev.mysql.com/doc/refman/8.0/en/xa.html rel=noopener>https://dev.mysql.com/doc/refman/8.0/en/xa.html</a>
<img src=https://jieye-ericx.github.io//../../pics/2021110810071449.png width=auto alt=在这里插入图片描述></p><ul><li>AP（Application Program）：应用程序，定义事务边界（定义事务开始和结束）并访问事务边界内的资源。</li><li>RM（Resource Manger）资源管理器: 管理共享资源并提供外部访问接口。供外部程序来访问数据库等共享资源。此外，RM 还具有事务的回滚能力。</li><li>TM（Transaction Manager）事务管理器：TM 是分布式事务的协调者，TM 与每个 RM 进行通信，负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等。</li><li>应用程序 AP 向事务管理器 TM 发起事务请求</li><li>TM 调用 xa_open()建立同资源管理器的会话</li><li>TM 调用 xa_start()标记一个事务分支的开头</li><li>AP 访问资源管理器 RM 并定义操作，比如插入记录操作</li><li>TM 调用 xa_end()标记事务分支的结束</li><li>TM 调用 xa_prepare()通知 RM 做好事务分支的提交准备工作。其实就是二阶段提交的提交请求阶段。</li><li>TM 调用 xa_commit()通知 RM 提交事务分支，也就是二阶段提交的提交执行阶段。</li><li>TM 调用 xa_close 管理与 RM 的会话。</li><li>这些接口一定要按顺序执行，比如 xa_start 接口一定要在 xa_end 之前。此外，这里千万要注意的是事务管理器只是标记事务分支并不执行事务，事务操作最终是由应用程序通知资源管理器完成的。另外，我们来总结下 XA 的接口</li><li>xa_start:负责开启或者恢复一个事务分支，并且管理 XID 到调用线程</li><li>xa_end:负责取消当前线程与事务分支的关系</li><li>xa_prepare:负责询问 RM 是否准备好了提交事务分支 xa_commit:通知 RM 提交事务分支</li><li>xa_rollback:通知 RM 回滚事务分支</li></ul><a href=#087-什么是-mysql-xa-事务><h3 id=087-什么是-mysql-xa-事务><span class=hanchor arialabel=Anchor># </span>087 什么是 mysql xa 事务？</h3></a><p>mysql 的 xa 事务分为两部分：</p><ol><li>InnoDB 内部本地普通事务操作协调数据写入与 log 写入两阶段提交</li><li>外部分布式事务</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>5.7 SHOW VARIABLES LIKE &#39;%innodb_support_xa%&#39;;
</span></span><span class=line><span class=cl>8.0 默认开启无法关闭
</span></span></code></pre></td></tr></table></div></div><p>XA 事务语法示例如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>XA START &#39;自定义事务id&#39;;
</span></span><span class=line><span class=cl>SQL语句...
</span></span><span class=line><span class=cl>XA END &#39;自定义事务id&#39;;
</span></span><span class=line><span class=cl>XA PREPARE &#39;自定义事务id&#39;;
</span></span><span class=line><span class=cl>XA COMMIT\ROLLBACK &#39;自定义事务id&#39;;
</span></span></code></pre></td></tr></table></div></div><p>XA PREPARE 执行成功后，事务信息将被持久化。即使会话终止甚至应用服务宕机，只要我们将【自定义事务 id】记录下来，后续仍然可以使用它对事务进行 rollback 或者 commit。</p><a href=#088-xa-事务与普通事务区别是什么><h3 id=088-xa-事务与普通事务区别是什么><span class=hanchor arialabel=Anchor># </span>088 xa 事务与普通事务区别是什么？</h3></a><p>xa 事务可以跨库或跨服务器，属于分布式事务，同时 xa 事务还支撑了 InnoDB 内部日志两阶段记录
普通事务只能在单库中执行</p><a href=#089-什么是-2pc-3pc><h3 id=089-什么是-2pc-3pc><span class=hanchor arialabel=Anchor># </span>089 什么是 2pc 3pc？</h3></a><p>两阶段提交协议与 3 阶段提交协议，额外增加了参与的角色保证分布式事务完成更完善</p><a href=#090-是否使用过-select-for-update会产生哪些操作><h3 id=090-是否使用过-select-for-update会产生哪些操作><span class=hanchor arialabel=Anchor># </span>090 是否使用过 select for update？会产生哪些操作？</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>查询库存 = 100 0 扣减库存 = -1 99
</span></span><span class=line><span class=cl>记录日志 = log
</span></span><span class=line><span class=cl>提交 commit
</span></span></code></pre></td></tr></table></div></div><p>select 本身是一个查询语句，查询语句是不会产生冲突的一种行为，一般情况下是没有锁的，用 select for update 会让 select 语句产生一个排它锁(X), 这个锁和 update 的效果一样，会使两个事务无法同时更新一条记录。
<a href=https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html rel=noopener>https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html</a>
<a href=https://dev.mysql.com/doc/refman/8.0/en/select.html rel=noopener>https://dev.mysql.com/doc/refman/8.0/en/select.html</a></p><ul><li>for update 仅适用于 InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。</li><li>在进行事务操作时，通过“for update”语句，MySQL 会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。</li><li><strong>InnoDB 默认是行级别的锁，在筛选条件中当有明确指定主键或唯一索引列的时候，是行级锁。否则是表级别。</strong>
示例</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SELECT … FOR UPDATE [OF column_list][WAIT n|NOWAIT][SKIP LOCKED];
</span></span><span class=line><span class=cl>select * from t for update 会等待行锁释放之后，返回查询结果。
</span></span><span class=line><span class=cl>select * from t for update nowait 不等待行锁释放，提示锁冲突，不返回结果
</span></span><span class=line><span class=cl>select * from t for update wait 5 等待5秒，若行锁仍未释放，则提示锁冲突，不返回结果
</span></span><span class=line><span class=cl>select * from t for update skip locked 查询返回查询结果，但忽略有行锁的记录
</span></span></code></pre></td></tr></table></div></div><a href=#091-说一下-mysql-死锁的原因和处理方法><h3 id=091-说一下-mysql-死锁的原因和处理方法><span class=hanchor arialabel=Anchor># </span>091 说一下 mysql 死锁的原因和处理方法</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>事务 a
</span></span><span class=line><span class=cl>表 t id=100 更新 加行锁
</span></span><span class=line><span class=cl>表 t id=200 更新 已加锁
</span></span><span class=line><span class=cl>事务 b
</span></span><span class=line><span class=cl>表 t id=200 更新 加行锁
</span></span><span class=line><span class=cl>表 t id=100 更新 已加锁
</span></span></code></pre></td></tr></table></div></div><ul><li>死锁与锁等待是两个概念</li><li>如未开启事务，多个客户端执行的 insert 操作</li><li>当多个事务同时持有和请求同一资源上的锁而产生循环依赖的时候就产生了死锁。
排查：</li><li>正在运行的任务</li><li>show full processlist; 找到卡主的进程</li><li>解开死锁</li><li>UNLOCK TABLES ；</li><li>查看当前运行的事务</li><li>SELECT * FROM information_schema.INNODB_TRX;</li><li>当前出现的锁</li><li>SELECT * FROM information_schema.INNODB_LOCKS;</li><li>观察错误日志</li><li>查看 InnoDB 锁状态</li><li><code>show status like "innodb_row_lock%";</code>
lnnodb_row_lock_current_waits:当前正在等待锁定的数量;
lnnodb_row_lock_time :从系统启动到现在锁定的总时间长度，单位 ms;
Innodb_row_lock_time_avg :每次等待所花平均时间;
Innodb_row_lock_time_max:从系统启动到现在等待最长的一次所花的时间;
lnnodb_row_lock_waits :从系统启动到现在总共等待的次数。</li><li>kill id 杀死进程
解决：</li><li>死锁无法避免，上线前要进行严格的压力测试</li><li>快速失败</li><li>innodb_lock_wait_timeout 行锁超时时间</li><li>拆分 sql，严禁大事务</li><li>充分利用索引，优化索引，尽量把有风险的事务 sql 使用上覆盖索，优化 where 条件前缀匹配，提升查询速度，引减少表锁</li><li>无法避免时：</li><li>操作多张表时，尽量以相同的顺序来访问避免形成等待环路</li><li>单张表时先排序再操作</li><li>使用排它锁 比如 for update</li></ul><a href=#092-mysql-会产生几种日志><h3 id=092-mysql-会产生几种日志><span class=hanchor arialabel=Anchor># </span>092 Mysql 会产生几种日志？</h3></a><ul><li><strong>错误日志（error log）</strong>
error log 主要记录 MySQL 在启动、关闭或者运行过程中的错误信息，在 MySQL 的配置文件 my.cnf 中，可以通过 log-error=/var/log/mysqld.log 执行 mysql 错误日志的位置。</li><li><strong>慢查询日志（slow query log）</strong>
0.1 秒</li></ul><ul><li>MySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阀值的语句，具体指运行时间超过 long_query_time 值的 SQL，则会被记录到慢查询日志中。</li><li>long_query_time 的默认值为 10，意思是运行 10 秒以上的语句。</li><li>由他来查看哪些 SQL 超出了我们的最大忍耐时间值，比如一条 sql 执行超过 5 秒钟，我们就算慢 SQL，希望能收集超过 5 秒的 sql，结合之前 explain 进行全面分析。</li><li>默认情况下，MySQL 数据库没有开启慢查询日志，需要我们手动来设置这个参数。</li><li>当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询<strong>日志支持将日志记录写入文件</strong>。
在生产环境中，如果要手工分析日志，查找、分析 SQL，显然是个体力活，MySQL 提供了日志分析工具 mysqldumpslow。</li></ul><ul><li><strong>一般查询日志（general log）</strong>
general log 记录了客户端连接信息以及执行的 SQL 语句信息，通过 MySQL 的命令</li><li><strong>重写日志（redo log）</strong></li><li><strong>回滚日志（undo log）</strong></li><li><strong>二进制日志（bin log）</strong></li></ul><a href=#093-bin-log-作用是什么><h3 id=093-bin-log-作用是什么><span class=hanchor arialabel=Anchor># </span>093 bin log 作用是什么？</h3></a><p>MySQL 的 bin log 日志是用来记录 MySQL 中增删改时的记录日志。
当你的一条 sql 操作对数据库中的内容进行了更新，就会增加一条 bin log 日志。查询操作不会记录到 bin log 中。
bin log 最大的用处就是进行<strong>主从复制，以及数据库的恢复。</strong></p><a href=#094-redo-log-作用是什么><h3 id=094-redo-log-作用是什么><span class=hanchor arialabel=Anchor># </span>094 redo log 作用是什么？</h3></a><p>redo log 是一种基于磁盘的数据结构，用来在 MySQL 宕机情况下将不完整的事务执行数据纠正，redo 日志记录事务执行后的状态。
当事务开始后，redo log 就开始产生，并且随着事务的执行不断写入 redo log file 中。redo log file 中记录了 xxx 页做了 xx 修改的信息，我们都知道数据库的更新操作会在内存中先执行，最后刷入磁盘。
redo log 就是为了恢复更新了内存但是由于宕机等原因没有刷入磁盘中的那部分数据。</p><a href=#095-undo-log-作用是什么><h3 id=095-undo-log-作用是什么><span class=hanchor arialabel=Anchor># </span>095 undo log 作用是什么？</h3></a><p>undo log 主要用来回滚到某一个版本，是一种逻辑日志。
undo log 记录的是修改之前的数据，比如：当 delete 一条记录时，undolog 中会记录一条对应的 insert 记录，从而保证能恢复到数据修改之前。在执行事务回滚的时候，就可以通过 undo log 中的记录内容并以此进行回滚。
undo log 还可以提供多版本并发控制下的读取（MVCC）。</p><a href=#096-mysql-日志是否实时写入磁盘-097-bin-log-刷盘机制是如何实现的098-redo-log-刷盘机制是如何实现的-099-undo-log-刷盘机制是如何实现的><h3 id=096-mysql-日志是否实时写入磁盘-097-bin-log-刷盘机制是如何实现的098-redo-log-刷盘机制是如何实现的-099-undo-log-刷盘机制是如何实现的><span class=hanchor arialabel=Anchor># </span>096 Mysql 日志是否实时写入磁盘？ 097 bin log 刷盘机制是如何实现的？098 redo log 刷盘机制是如何实现的？ 099 undo log 刷盘机制是如何实现的？</h3></a><p>磁盘写入固然是比较慢的。
参数：sync_binlog
binlog 写入策略：
<strong>1、sync_binlog=0</strong> 的时候，表示每次提交事务 binlog 不会马上写入到磁盘，而是先写到 page cache,相对于磁盘写入来说写 page cache 要快得多,不过在 Mysql 崩溃的时候会有丢失日志的风险。
<strong>2、sync_binlog=1</strong> 的时候，表示每次提交事务都会执行 fsync 写入到磁盘 ；
<strong>3、sync_binlog 的值大于 1</strong> 的时候，表示每次提交事务都 先写到 page cach，只有等到积累了 N 个事务之后才 fsync 写入到磁盘，同样在此设置下 Mysql 崩溃的时候会有丢失 N 个事务日志的风险。
很显然三种模式下，sync_binlog=1 是强一致的选择，选择 0 或者 N 的情况下在极端情况下就会有丢失日志的风险，具体选择什么模式还是得看系统对于一致性的要求。
<img src=https://jieye-ericx.github.io//../../pics/16701032-f8547d110ba34135.png width=auto alt=img>
<strong>innodb_flush_log_at_trx_commit</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>取值0：每秒（一秒钟内提交的事务）写入磁盘 每秒触发一次缓存日志回写磁盘操作，并调用操作系统fsync刷新IO缓存。
</span></span><span class=line><span class=cl>取值1：有事务提交就立即刷盘 每次提交事务都立即调用操作系统fsync刷新IO缓存。
</span></span><span class=line><span class=cl>取值2：每次事务提交 都写给操作系统 由系统接管什么时候写入磁盘 每次都把redo log写到系统的page cache中，由系统接管什么时候写入磁盘
</span></span></code></pre></td></tr></table></div></div><p>时机顺序：</p><ul><li>1 开启事务</li><li>2 查询数据库中需要更新的字段，加载到内存中 形成数据<strong>脏页</strong></li><li>3 记录 undo log 到内存缓冲区（用于回滚和 mvcc）并关联 redo log -> 可刷盘</li><li>4 记录 redo log 到内存缓冲区 （用于失败重放）准备提交事务 -> 可刷盘</li><li>5 修改内存中的脏页数据</li><li>6 提交事务触发 redolog 刷盘</li><li>7 undo log 和脏页 刷盘</li><li>8 事务成功
<strong>redo log 与 binlog 的两阶段提交</strong>
redo log 的写入拆成了两个步骤：prepare 和 commit</li><li><strong>prepare</strong>：redolog 写入 log buffer，并 fsync 持久化到磁盘，在 redolog 事务中记录 2PC 的 XID，在 redolog 事务打上 prepare 标识</li><li><strong>commit</strong>：binlog 写入 log buffer，并 fsync 持久化到磁盘，在 binlog 事务中记录 2PC 的 XID，同时在 redolog 事务打上 commit 标识
<img src=https://jieye-ericx.github.io//../../pics/v2-a48d01fd3478ba4d68207fc7ce757658_r.jpg width=auto alt=img></li></ul><a href=#100-mysql-的-binlog-有有几种录入格式分别有什么区别><h3 id=100-mysql-的-binlog-有有几种录入格式分别有什么区别><span class=hanchor arialabel=Anchor># </span>100 MySQL 的 binlog 有有几种录入格式？分别有什么区别？</h3></a><p>logbin 格式：</p><ul><li>binlog_format=STATEMENT（默认）：数据操作的时间，同步时不一致 每一条会修改数据的 sql 语句会记录到 binlog 中。优点是并不需要记录每一条 sql 语句和每一行的数据变化，减少了 binlog 日志量，节约 IO，提高性能。缺点是在某些情况下会导致 master-slave 中的数据不一致( 如 sleep()函数， last_insert_id()，以及 user-defined functions(udf)等会 出 现 问题)</li><li>binlog_format=ROW：批量数据操作时，效率低 不记录每条 sql 语句的上下文信息，仅需记录哪条数据被修改了，修改成什么样了。而且不会出现某些特定情况下的存储过程、或 function、或 trigger 的调用和触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是 alter table 的时候会让日志暴涨。</li><li>binlog_format=MIXED：是以上两种 level 的混合使用，有函数用 ROW，没函数用 STATEMENT，但是无法识别系统变量</li></ul><a href=#101-mysql-集群同步时为什么使用-binlog优缺点是什么><h3 id=101-mysql-集群同步时为什么使用-binlog优缺点是什么><span class=hanchor arialabel=Anchor># </span>101 Mysql 集群同步时为什么使用 binlog？优缺点是什么？</h3></a><ul><li>binlog 是 mysql 提供的日志，所有存储引擎都可用。</li><li>支持增量同步</li><li>binlog 还可以供其他中间件读取，比如同步到 hdfs 中</li><li>如果复制表数据：</li><li>不支持某个阶段回放</li><li>直接复制数据过程中一旦中断复制（比如断网），很难确定复制的 offset</li></ul><a href=#四-mysql-开发><h2 id=四-mysql-开发><span class=hanchor arialabel=Anchor># </span>四 Mysql 开发</h2></a><a href=#102-可以使用-mysql-直接存储文件吗><h3 id=102-可以使用-mysql-直接存储文件吗><span class=hanchor arialabel=Anchor># </span>102 可以使用 MySQL 直接存储文件吗？</h3></a><p>可以使用 BLOB (binary large object)，用来存储二进制大对象的字段类型。
TinyBlob 255 值的长度加上用于记录长度的 1 个字节(8 位)
Blob 65K 值的长度加上用于记录长度的 2 个字节(16 位)
MediumBlob 16M 值的长度加上用于记录长度的 3 个字节(24 位)
LongBlob 4G 值的长度加上用于记录长度的 4 个字节(32 位)。</p><a href=#103-什么时候存什么时候不存><h3 id=103-什么时候存什么时候不存><span class=hanchor arialabel=Anchor># </span>103 什么时候存，什么时候不存？</h3></a><p>存：需要高效查询并且文件很小的时候
不存：文件比较大，数据量多或变更频繁的时候</p><a href=#104-存储的时候有遇到过什么问题吗><h3 id=104-存储的时候有遇到过什么问题吗><span class=hanchor arialabel=Anchor># </span>104 存储的时候有遇到过什么问题吗？</h3></a><ol><li>上传数据过大 sql 执行失败 调整 max_allowed_packet</li><li>主从同步数据时比较慢</li><li>应用线程阻塞</li><li>占用网络带宽</li><li>高频访问的图片无法使用浏览器缓存</li></ol><a href=#105-emoji-乱码怎么办><h3 id=105-emoji-乱码怎么办><span class=hanchor arialabel=Anchor># </span>105 Emoji 乱码怎么办？</h3></a><p>使用 utf8mb4
MySQL 在 5.5.3 之后增加了这个 utf8mb4 的编码，mb4 就是 most bytes 4 的意思，专门用来兼容四字节的 unicode。好在 utf8mb4 是 utf8 的超集，除了将编码改为 utf8mb4 外不需要做其他转换。当然，一般情况下使用 utf8 也就够了。</p><a href=#106-如何存储-ip-地址><h3 id=106-如何存储-ip-地址><span class=hanchor arialabel=Anchor># </span>106 如何存储 ip 地址？</h3></a><ol><li>使用字符串</li><li>使用无符号整型</li></ol><ul><li>4个字节即解决问题</li><li>可以支持范围查询</li><li><strong>INET_ATON()</strong> 和 <strong>INET_NTOA()</strong> ipv6 使用 <strong>INET6_ATON()</strong> 和 <strong>INET6_NTOA()</strong></li></ul><a href=#107-长文本如何存储><h3 id=107-长文本如何存储><span class=hanchor arialabel=Anchor># </span>107 长文本如何存储？</h3></a><p>可以使用 Text 存储
<strong>TINYTEXT(255 长度)</strong>
<strong>TEXT(65535)</strong>
<strong>MEDIUMTEXT（int 最大值 16M）</strong>
<strong>LONGTEXT(long 最大值 4G)</strong></p><a href=#108-大段文本如何设计表结构><h3 id=108-大段文本如何设计表结构><span class=hanchor arialabel=Anchor># </span>108 大段文本如何设计表结构？</h3></a><ol><li>或将大段文本同时存储到搜索引擎</li><li>分表存储</li><li>分表后多段存储</li></ol><a href=#109-大段文本查找时如何建立索引><h3 id=109-大段文本查找时如何建立索引><span class=hanchor arialabel=Anchor># </span>109 大段文本查找时如何建立索引？</h3></a><ol><li>全文检索，模糊匹配最好存储到搜索引擎中</li><li>指定索引长度</li><li>分段存储后创建索引</li></ol><a href=#110-有没有在开发中使用过-textblob-数据类型><h3 id=110-有没有在开发中使用过-textblob-数据类型><span class=hanchor arialabel=Anchor># </span>110 有没有在开发中使用过 TEXT,BLOB 数据类型</h3></a><p>BLOB 之前做 ERP 的时候使用过，互联网项目一般不用 BLOB
TEXT 文献，文章，小说类，新闻，会议内容 等</p><a href=#111-日期时间如何存取><h3 id=111-日期时间如何存取><span class=hanchor arialabel=Anchor># </span>111 日期，时间如何存取？</h3></a><ol><li>使用 TIMESTAMP，DATETIME</li><li>使用字符串</li></ol><a href=#112-timestampdatetime-的区别是什么><h3 id=112-timestampdatetime-的区别是什么><span class=hanchor arialabel=Anchor># </span>112 TIMESTAMP，DATETIME 的区别是什么？</h3></a><p>跨时区的业务使用 TIMESTAMP，TIMESTAMP 会有时区转换
1、两者的存储方式不一样:
对于 TIMESTAMP，它把客户端插入的时间从当前时区转化为 UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。
而对于 DATETIME，不做任何改变，基本上是原样输入和输出。
2、存储字节大小不同</p><table><thead><tr><th>数据类型</th><th>MySQL 5.6.4 之前需要存储</th><th>MySQL 5.6.4 之后需要存储</th></tr></thead><tbody><tr><td>DATETIME</td><td>8 bytes</td><td>5 bytes + 小数秒存储</td></tr><tr><td>TIMESTAMP</td><td>4 bytes</td><td>4 bytes + 小数秒存储</td></tr><tr><td>分秒数精度</td><td>存储字节大小</td><td></td></tr><tr><td>&mdash;&mdash;&mdash;-</td><td>&mdash;&mdash;&mdash;&mdash;</td><td></td></tr><tr><td>0</td><td>0 bytes</td><td></td></tr><tr><td>1,2</td><td>1 bytes</td><td></td></tr><tr><td>3,4</td><td>2 bytes</td><td></td></tr><tr><td>5,6</td><td>3 bytes</td><td></td></tr><tr><td>3、两者所能存储的时间范围不一样:</td><td></td><td></td></tr><tr><td>timestamp 所能存储的时间范围为：&lsquo;1970-01-01 00:00:01.000000&rsquo; 到 &lsquo;2038-01-19 03:14:07.999999&rsquo;。</td><td></td><td></td></tr><tr><td>datetime 所能存储的时间范围为：&lsquo;1000-01-01 00:00:00.000000&rsquo; 到 &lsquo;9999-12-31 23:59:59.999999&rsquo;。</td><td></td><td></td></tr></tbody></table><a href=#113-为什么不使用字符串存储日期><h3 id=113-为什么不使用字符串存储日期><span class=hanchor arialabel=Anchor># </span>113 为什么不使用字符串存储日期？</h3></a><p>字符串无法完成数据库内部的范围筛选
在大数据量存储优化索引时，查询必须加上时间范围</p><a href=#114-如果需要使用时间戳-timestamp-和-int-该如何选择><h3 id=114-如果需要使用时间戳-timestamp-和-int-该如何选择><span class=hanchor arialabel=Anchor># </span>114 如果需要使用时间戳 timestamp 和 int 该如何选择？</h3></a><p><strong>int</strong> 存储空间小，运算查询效率高，不受时区影响，精度低
<strong>timestamp</strong> 存储空间小，可以使用数据库内部时间函数比如更新，精度高，需要注意时区转换，timestamp 更易读
一般选择 timestamp，两者性能差异不明显，本质上存储都是使用的 int</p><a href=#115-char-与-varchar-的区别如何选择><h3 id=115-char-与-varchar-的区别如何选择><span class=hanchor arialabel=Anchor># </span>115 char 与 varchar 的区别？如何选择？</h3></a><p>1.char 的优点是存储空间固定（最大 255），没有碎片，尤其更新比较频繁的时候，方便数据文件指针的操作，所以存储读取速度快。缺点是空间冗余，对于数据量大的表，非固定长度属性使用 char 字段，空间浪费。
2.varchar 字段，存储的空间根据存储的内容变化，空间长度为 L+size，存储内容长度加描述存储内容长度信息，优点就是空间节约，缺点就是读取和存储时候，需要读取信息计算下标，才能获取完整内容。</p><a href=#116-财务计算有没有出现过错乱><h3 id=116-财务计算有没有出现过错乱><span class=hanchor arialabel=Anchor># </span>116 财务计算有没有出现过错乱？</h3></a><p>第一类：锁包括多线程，数据库，UI 展示后超时提交等
第二类：应用与数据库浮点运算精度丢失</p><ol><li>应用开发问题：多线程共享数据读写，</li><li>之前有过丢失精度的问题，使用 <strong>decimal</strong> 解决</li><li>使用乘法替换除法</li><li>使用事务保证 acid 特性</li><li>更新时使用悲观锁 SELECT … FOR UPDATE</li><li>数据只有标记删除</li><li>记录详细日志方便溯源</li></ol><a href=#117-decimal-与-floatdouble-的区别是什么><h3 id=117-decimal-与-floatdouble-的区别是什么><span class=hanchor arialabel=Anchor># </span>117 decimal 与 float,double 的区别是什么？</h3></a><p>float：浮点型，4 字节，32bit。
double：双精度实型，8 字节，64 位
decimal：数字型，128bit，不存在精度损失
对于声明语法 DECIMAL(M,D)，自变量的值范围如下：</p><ul><li>M 是最大位数（精度），范围是 1 到 65。可不指定，默认值是 10。</li><li>D 是小数点右边的位数（小数位）。范围是 0 到 30，并且不能大于 M，可不指定，默认值是 0。
例如字段 salary DECIMAL(5,2)，能够存储具有五位数字和两位小数的任何值，因此可以存储在 salary 列中的值的范围是从-999.99 到 999.99。</li></ul><a href=#118-浮点类型如何选型为什么><h3 id=118-浮点类型如何选型为什么><span class=hanchor arialabel=Anchor># </span>118 浮点类型如何选型？为什么？</h3></a><ul><li>需要不丢失精度的计算使用 DECIMAL</li><li>仅用于展示没有计算的小数存储可以使用字符串存储</li><li>低价值数据允许计算后丢失精度可以使用 float double</li><li>整型记录不会出现小数的不要使用浮点类型</li></ul><a href=#119-预编译-sql-是什么><h3 id=119-预编译-sql-是什么><span class=hanchor arialabel=Anchor># </span>119 预编译 sql 是什么？</h3></a><p>完整解释：https://dev.mysql.com/doc/refman/8.0/en/prepare.html
PreparedStatement</p><a href=#120-预编译-sql-有什么好处><h3 id=120-预编译-sql-有什么好处><span class=hanchor arialabel=Anchor># </span>120 预编译 sql 有什么好处？</h3></a><ul><li>预编译 sql 会被 mysql 缓存下来</li><li>作用域是每个 session，对其他 session 无效，重新连接也会失效</li><li>提高安全性防止 sql 注入</li><li>select * from user where id =?</li><li>&ldquo;1;delete from user where id = 1&rdquo;;</li><li>编译语句有可能被重复调用，也就是说 sql 相同参数不同在同一 session 中重复查询执行效率明显比较高</li><li>mysql 5,8 支持服务器端的预编译</li></ul><a href=#121-子查询与-join-哪个效率高><h3 id=121-子查询与-join-哪个效率高><span class=hanchor arialabel=Anchor># </span>121 子查询与 join 哪个效率高？</h3></a><p>子查询虽然很灵活，但是执行效率并不高。</p><a href=#122-为什么子查询效率低><h3 id=122-为什么子查询效率低><span class=hanchor arialabel=Anchor># </span>122 为什么子查询效率低？</h3></a><p>在执行子查询的时候，MYSQL 创建了临时表，查询完毕后再删除这些临时表
子查询的速度慢的原因是多了一个创建和销毁临时表的过程。
而 join 则不需要创建临时表 所以会比子查询快一点</p><a href=#123-join-查询可以无限叠加吗mysql-对-join-查询有什么限制吗><h3 id=123-join-查询可以无限叠加吗mysql-对-join-查询有什么限制吗><span class=hanchor arialabel=Anchor># </span>123 join 查询可以无限叠加吗？Mysql 对 join 查询有什么限制吗？</h3></a><p>建议 join 不超过 3 张表关联，mysql 对内存敏感，关联过多会占用更多内存空间，使性能下降
Too many tables; MySQL can only use 61 tables in a join；
系统限制最多关联 61 个表</p><a href=#124-join-查询算法了解吗><h3 id=124-join-查询算法了解吗><span class=hanchor arialabel=Anchor># </span>124 join 查询算法了解吗？</h3></a><ul><li>Simple Nested-Loop Join：SNLJ，简单嵌套循环连接</li><li>Index Nested-Loop Join：INLJ，索引嵌套循环连接</li><li>Block Nested-Loop Join：BNLJ，缓存块嵌套循环连接</li></ul><a href=#125-如何优化过多-join-查询关联><h3 id=125-如何优化过多-join-查询关联><span class=hanchor arialabel=Anchor># </span>125 如何优化过多 join 查询关联？</h3></a><ul><li>适当使用冗余字段减少多表关联查询</li><li>驱动表和被驱动表（小表 join 大表）</li><li>业务允许的话 尽量使用 inner join 让系统帮忙自动选择驱动表</li><li>关联字段一定创建索引</li><li>调整 JOIN BUFFER 大小</li></ul><a href=#126-是否有过-mysql-调优经验><h3 id=126-是否有过-mysql-调优经验><span class=hanchor arialabel=Anchor># </span>126 是否有过 mysql 调优经验？</h3></a><p>调优：</p><ol><li>sql 调优</li><li>表（结构）设计调优</li><li>索引调优</li><li>慢查询调优</li><li>操作系统调优</li><li>数据库参数调优</li></ol><a href=#127-开发中使用过哪些调优工具><h3 id=127-开发中使用过哪些调优工具><span class=hanchor arialabel=Anchor># </span>127 开发中使用过哪些调优工具？</h3></a><p>官方自带：</p><ul><li>EXPLAIN</li><li>mysqldumpslow</li><li>show profiles 时间</li><li>optimizer_trace
第三方：性能诊断工具，参数扫描提供建议，参数辅助优化</li></ul><a href=#128-如何监控线上环境中执行比较慢的-sql-129-如何分析一条慢-sql><h3 id=128-如何监控线上环境中执行比较慢的-sql-129-如何分析一条慢-sql><span class=hanchor arialabel=Anchor># </span>128 如何监控线上环境中执行比较慢的 sql？ 129 如何分析一条慢 sql？</h3></a><p>开启慢查询日志，收集 sql
默认情况下，MySQL 数据库没有开启慢查询日志，需要我们手动来设置这个参数。
当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询<strong>日志支持将日志记录写入文件</strong>。
<strong>查看及开启</strong></p><ol><li>默认关闭
<code>SHOW VARIABLES LIKE '%slow_query_log%';</code>
默认情况下 slow_query_log 的值为 OFF，表示慢查询日志是禁用的，</li><li>开启：<code>set global slow_query_log=1;</code> 只对窗口生效，重启服务失效</li><li>慢查询日志记录 long_query_time 时间</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SHOW</span><span class=w> </span><span class=n>VARIABLES</span><span class=w> </span><span class=k>LIKE</span><span class=w> </span><span class=s1>&#39;%long_query_time%&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SHOW</span><span class=w> </span><span class=k>GLOBAL</span><span class=w> </span><span class=n>VARIABLES</span><span class=w> </span><span class=k>LIKE</span><span class=w> </span><span class=s1>&#39;long_query_time&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>全局变量设置，对所有客户端有效。但必须是设置后进行登录的客户端。
SET GLOBAL long_query_time=0.1;
对当前会话连接立即生效，对其他客户端无效。
SET SESSION long_query_time=0.1; #session 可省略
假如运行时间正好等于 long_query_time 的情况，并不会被记录下来。也就是说，
在 mysql 源码里是判断大于 long_query_time，而非大于等于。</p><ol><li>永久生效</li><li><ul><li>修改配置文件 my.cnf（其它系统变量也是如此）</li></ul></li></ol><ul><li>[mysqld]下增加或修改参数</li><li>slow_query_log 和 slow_query_log_file 后，然后重启 MySQL 服务器。也即将如下两行配置进 my.cnf 文件
slow_query_log =1
slow_query_log_file=/var/lib/mysql/localhost-slow.log
long_query_time=3
log_output=FILE</li></ul><ol><li><ul><li>关于慢查询的参数 slow_query_log_file，它指定慢查询日志文件的存放路径，如果不设置，系统默认文件：[host_name]-slow.log
<strong>case</strong>
记录慢 SQL 并后续分析
SELECT * FROM emp;
SELECT * FROM emp WHERE deptid > 1;
查询当前系统中有多少条慢查询记录或者直接看慢查询日志
/var/lib/mysql/localhost-slow.log
SHOW GLOBAL STATUS LIKE &lsquo;%Slow_queries%&rsquo;;
<strong>日志分析工具 mysqldumpslow</strong></li></ul></li><li>在生产环境中，如果要手工分析日志，查找、分析 SQL，显然是个体力活，MySQL 提供了日志分析工具 mysqldumpslow。</li><li>查看 mysqldumpslow 的帮助信息</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>a) mysqldumpslow --help
</span></span><span class=line><span class=cl>· -a: 将数字抽象成N，字符串抽象成S
</span></span><span class=line><span class=cl>· -s: 是表示按照何种方式排序；
</span></span><span class=line><span class=cl>c: 访问次数
</span></span><span class=line><span class=cl>l: 锁定时间
</span></span><span class=line><span class=cl>r: 返回记录
</span></span><span class=line><span class=cl>**t:** **查询时间*
</span></span><span class=line><span class=cl>al:平均锁定时间
</span></span><span class=line><span class=cl>ar:平均返回记录数
</span></span><span class=line><span class=cl>at:平均查询时间
</span></span><span class=line><span class=cl>· -t: 即为返回前面多少条的数据；
</span></span><span class=line><span class=cl>· -g: 后边搭配一个正则匹配模式，大小写不敏感的；
</span></span><span class=line><span class=cl>得到返回记录集最多的10个SQL mysqldumpslow -s r -t 10 /var/lib/mysql/localhost-slow.log 得到访问次数最多的10个SQL mysqldumpslow -s c -t 10 /var/lib/mysql/localhost-slow.log 得到按照时间排序的前10条里面含有左连接的查询语句 mysqldumpslow -s t -t 10 -g &#34;left join&#34; /var/lib/mysql/localhost-slow.log 另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况 mysqldumpslow -s r -t 10 /var/lib/mysql/localhost-slow.log | more
</span></span></code></pre></td></tr></table></div></div><a href=#130-如何查看当前-sql-使用了哪个索引><h3 id=130-如何查看当前-sql-使用了哪个索引><span class=hanchor arialabel=Anchor># </span>130 如何查看当前 sql 使用了哪个索引？</h3></a><p>可以使用 EXPLAIN，选择索引过程可以使用 optimizer_trace</p><a href=#131-索引如何进行分析和调优><h3 id=131-索引如何进行分析和调优><span class=hanchor arialabel=Anchor># </span>131 索引如何进行分析和调优？</h3></a><a href=#132-explain-关键字中的重要指标有哪些><h3 id=132-explain-关键字中的重要指标有哪些><span class=hanchor arialabel=Anchor># </span>132 EXPLAIN 关键字中的重要指标有哪些？</h3></a><a href=#explain-是什么><h4 id=explain-是什么><span class=hanchor arialabel=Anchor># </span>EXPLAIN 是什么</h4></a><p>使用 EXPLAIN 关键字可以<code>模拟优化器执行SQL查询语句</code>，从而知道 MySQL 是如何处理你的 SQL 语句的。<code>分析你的查询语句或是表结构的性能瓶颈</code>。</p><a href=#explain-的用法><h4 id=explain-的用法><span class=hanchor arialabel=Anchor># </span>EXPLAIN 的用法</h4></a><p><strong>用法：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>SQL语句</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>数据准备：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=n>USE</span><span class=w> </span><span class=n>atguigudb</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>t1</span><span class=p>(</span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=p>,</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>t2</span><span class=p>(</span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=p>,</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>t3</span><span class=p>(</span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=p>,</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>t4</span><span class=p>(</span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=p>,</span><span class=w> </span><span class=n>content1</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w> </span><span class=n>content2</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_content1</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>t4</span><span class=p>(</span><span class=n>content1</span><span class=p>);</span><span class=w> </span><span class=c1>-- 普通索引
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>#</span><span class=w> </span><span class=err>以下新增</span><span class=n>sql多执行几次</span><span class=err>，以便演示</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>t1</span><span class=p>(</span><span class=n>content</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=p>(</span><span class=n>CONCAT</span><span class=p>(</span><span class=s1>&#39;t1_&#39;</span><span class=p>,</span><span class=n>FLOOR</span><span class=p>(</span><span class=mi>1</span><span class=o>+</span><span class=n>RAND</span><span class=p>()</span><span class=o>*</span><span class=mi>1000</span><span class=p>)));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>t2</span><span class=p>(</span><span class=n>content</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=p>(</span><span class=n>CONCAT</span><span class=p>(</span><span class=s1>&#39;t2_&#39;</span><span class=p>,</span><span class=n>FLOOR</span><span class=p>(</span><span class=mi>1</span><span class=o>+</span><span class=n>RAND</span><span class=p>()</span><span class=o>*</span><span class=mi>1000</span><span class=p>)));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>t3</span><span class=p>(</span><span class=n>content</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=p>(</span><span class=n>CONCAT</span><span class=p>(</span><span class=s1>&#39;t3_&#39;</span><span class=p>,</span><span class=n>FLOOR</span><span class=p>(</span><span class=mi>1</span><span class=o>+</span><span class=n>RAND</span><span class=p>()</span><span class=o>*</span><span class=mi>1000</span><span class=p>)));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>t4</span><span class=p>(</span><span class=n>content1</span><span class=p>,</span><span class=w> </span><span class=n>content2</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=p>(</span><span class=n>CONCAT</span><span class=p>(</span><span class=s1>&#39;t4_&#39;</span><span class=p>,</span><span class=n>FLOOR</span><span class=p>(</span><span class=mi>1</span><span class=o>+</span><span class=n>RAND</span><span class=p>()</span><span class=o>*</span><span class=mi>1000</span><span class=p>)),</span><span class=w> </span><span class=n>CONCAT</span><span class=p>(</span><span class=s1>&#39;t4_&#39;</span><span class=p>,</span><span class=n>FLOOR</span><span class=p>(</span><span class=mi>1</span><span class=o>+</span><span class=n>RAND</span><span class=p>()</span><span class=o>*</span><span class=mi>1000</span><span class=p>)));</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><a href=#各字段解释><h4 id=各字段解释><span class=hanchor arialabel=Anchor># </span>各字段解释</h4></a><a href=#table><h5 id=table><span class=hanchor arialabel=Anchor># </span>table</h5></a><ul><li>单表：显示这一行的数据是关于哪张表的</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710101402666.png width=auto alt=image-20220710101402666></p><ul><li>多表关联：t1 为驱动表，t2 为被驱动表。
<code>注意：</code>内连接时，MySQL 性能优化器会自动判断哪个表是驱动表，哪个表示被驱动表，和书写的顺序无关</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>INNER</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>t2</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220711122444380.png width=auto alt=image-20220711122444380></p><a href=#id><h5 id=id><span class=hanchor arialabel=Anchor># </span>id</h5></a><p>表示查询中执行 select 子句或操作表的顺序</p><ul><li>id 相同：执行顺序由上至下</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=p>,</span><span class=w> </span><span class=n>t2</span><span class=p>,</span><span class=w> </span><span class=n>t3</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710000757241.png width=auto alt=image-20220710000757241></p><ul><li>id 不同：如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>t1</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>t1</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>t2</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t2</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>t2</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>t3</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t3</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>t3</span><span class=p>.</span><span class=n>content</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;t3_434&#39;</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710000950098.png width=auto alt=image-20220710000950098>
<code>注意：</code>查询优化器可能对涉及子查询的语句进行优化，<code>转为连接查询</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t2</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;a&#39;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220711123408605.png width=auto alt=image-20220711123408605></p><ul><li>id 为 NULL：最后执行</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>UNION</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t2</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710001512891.png width=auto alt=image-20220710001512891>
<strong>小结：</strong></p><ul><li>id 如果相同，可以认为是一组，从上往下顺序执行</li><li>在所有组中，id 值越大，优先级越高，越先执行</li><li>关注点：id 号每个号码，表示一趟独立的查询, 一个 sql 的查询趟数越少越好</li></ul><a href=#select_type><h5 id=select_type><span class=hanchor arialabel=Anchor># </span>select_type</h5></a><p>查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。</p><ul><li>SIMPLE：简单查询。查询中不包含子查询或者 UNION。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710001930811.png width=auto alt=image-20220710001930811></p><ul><li>PRIMARY：主查询。查询中若包含子查询，则最外层查询被标记为 PRIMARY。</li><li>UBQUERY：子查询。在 SELECT 或 WHERE 列表中包含了子查询。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t3</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t2</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>content</span><span class=o>=</span><span class=w> </span><span class=s1>&#39;a&#39;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710002145309.png width=auto alt=image-20220710002145309></p><ul><li>DEPENDENT SUBQUREY：如果包含了子查询，并且查询语句不能被优化器转换为连接查询，并且子查询是<code>相关子查询（子查询基于外部数据列）</code>，则子查询就是 DEPENDENT SUBQUREY。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t3</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t2</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>t3</span><span class=p>.</span><span class=n>content</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710002444782.png width=auto alt=image-20220710002444782></p><ul><li>UNCACHEABLE SUBQUREY：表示这个 subquery 的查询要受到外部系统变量的影响</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t2</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>@@</span><span class=n>character_set_server</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710002604613.png width=auto alt=image-20220710002604613></p><ul><li>UNION：对于包含 UNION 或者 UNION ALL 的查询语句，除了最左边的查询是 PRIMARY，其余的查询都是 UNION。</li><li>UNION RESULT：UNION 会对查询结果进行查询去重，MYSQL 会使用临时表来完成 UNION 查询的去重工作，针对这个临时表的查询就是"UNION RESULT"。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t3</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UNION</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t2</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710003049587.png width=auto alt=image-20220710003049587></p><ul><li>**DEPENDENT UNION：**子查询中的 UNION 或者 UNION ALL，除了最左边的查询是 DEPENDENT SUBQUREY，其余的查询都是 DEPENDENT UNION。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=k>IN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UNION</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710110732730.png width=auto alt=image-20220710110732730></p><ul><li>DERIVED：在包含<code>派生表（子查询在from子句中）</code>的查询中，MySQL 会递归执行这些子查询，把结果放在临时表里。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>content</span><span class=p>,</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=k>c</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>content</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>derived_t1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=k>c</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这里的<code>&lt;derived2></code>就是在 id 为 2 的查询中产生的派生表。
<img src=https://jieye-ericx.github.io//../../pics/image-20220710153504037.png width=auto alt=image-20220710153504037>
补充：MySQL 在处理带有派生表的语句时，优先尝试把派生表和外层查询进行合并，如果不行，再把派生表<code>物化掉（执行子查询，并把结果放入临时表）</code>，然后执行查询。下面的例子就是就是将派生表和外层查询进行合并的例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;t1_832&#39;</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>derived_t1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710153921679.png width=auto alt=image-20220710153921679></p><ul><li>MATERIALIZED：优化器对于包含子查询的语句，<code>如果选择将子查询物化后再与外层查询连接查询</code>，该子查询的类型就是 MATERIALIZED。如下的例子中，查询优化器先将子查询转换成物化表，然后将 t1 和物化表进行连接查询。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t2</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710155650935.png width=auto alt=image-20220710155650935></p><a href=#partitions><h4 id=partitions><span class=hanchor arialabel=Anchor># </span>partitions</h4></a><p>代表分区表中的命中情况，非分区表，该项为 NULL</p><a href=#type-><h4 id=type-><span class=hanchor arialabel=Anchor># </span>type <strong>☆</strong></h4></a><blockquote><p><strong>说明：</strong>
结果值从最好到最坏依次是：
<code>system > const > eq_ref > ref</code> > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > <code>range > index > ALL</code>
<code>比较重要的包含：system、const 、eq_ref 、ref、range > index > ALL</code>
SQL 性能优化的目标：至少要达到 <code>range</code> 级别，要求是 <code>ref</code> 级别，最好是 <code>consts</code>级别。（阿里巴巴开发手册要求）</p></blockquote><ul><li>ALL：全表扫描。Full Table Scan，将遍历全表以找到匹配的行</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220712065946659.png width=auto alt=image-20220712065946659></p><ul><li>index：当使用<code>覆盖索引</code>，但需要扫描全部的索引记录时
<code>覆盖索引：</code>如果能通过读取索引就可以得到想要的数据，那就不需要读取用户记录，或者不用再做回表操作了。一个索引包含了满足查询结果的数据就叫做覆盖索引。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 只需要读取聚簇索引部分的非叶子节点，就可以得到id的值，不需要查询叶子节点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220712065815768.png width=auto alt=image-20220712065815768></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 只需要读取二级索引，就可以在二级索引中获取到想要的数据，不需要再根据叶子节点中的id做回表操作
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>deptId</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t_emp</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220712065922882.png width=auto alt=image-20220712065922882></p><ul><li>range：只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的 where 语句中出现了 between、&lt;、>、in 等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220712070042666.png width=auto alt=image-20220712070042666></p><ul><li>ref：通过普通二级索引列与常量进行等值匹配时</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t_emp</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>deptId</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220712070727963.png width=auto alt=image-20220712070727963></p><ul><li>**eq_ref：**连接查询时通过主键或不允许 NULL 值的唯一二级索引列进行等值匹配时</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=p>,</span><span class=w> </span><span class=n>t2</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>t1</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>t2</span><span class=p>.</span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220712070851089.png width=auto alt=image-20220712070851089></p><ul><li>**const：**根据<code>主键</code>或者<code>唯一二级索引</code>列与<code>常数</code>进行匹配时</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220712070944090.png width=auto alt=image-20220712070944090></p><ul><li>system：MyISAM 引擎中，当表中只有一条记录时。<code>（这是所有type的值中性能最高的场景）</code></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>t</span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=nb>int</span><span class=p>)</span><span class=w> </span><span class=n>Engine</span><span class=o>=</span><span class=n>MyISAM</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=k>VALUES</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220711125730163.png width=auto alt=image-20220711125730163>
<strong>其他不太常见的类型（了解）：</strong></p><ul><li><strong>index_subquery</strong>：利用<code>普通索引</code>来关联子查询，针对包含有 IN 子查询的查询语句。<code>content1是普通索引字段</code></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>content1</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t4</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>t1</span><span class=p>.</span><span class=n>content</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>t4</span><span class=p>.</span><span class=n>content2</span><span class=p>)</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;a&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220712071057817.png width=auto alt=image-20220712071057817></p><ul><li><strong>unique_subquery</strong>：类似于 index_subquery，利用<code>唯一索引</code>来关联子查询。`t2的id是主键，也可以理解为唯一的索引字段</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t2</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>t1</span><span class=p>.</span><span class=n>content</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>t2</span><span class=p>.</span><span class=n>content</span><span class=p>)</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;a&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220712071138320.png width=auto alt=image-20220712071138320></p><ul><li><strong>index_merge</strong>：在查询过程中需要<code>多个索引组合使用</code>，通常出现在有 or 的关键字的 sql 中。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t_emp</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>deptId</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220711132125501.png width=auto alt=image-20220711132125501></p><ul><li><strong>ref_or_null</strong>：当对普通二级索引进行等值匹配，且该索引列的值也可以是 NULL 值时。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t_emp</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>deptId</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=n>deptId</span><span class=w> </span><span class=k>IS</span><span class=w> </span><span class=k>NULL</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220711131831315.png width=auto alt=image-20220711131831315></p><ul><li>fulltext：全文索引。<code>一般通过搜索引擎实现，这里我们不展开。</code></li></ul><a href=#possible_keys-和-keys-><h4 id=possible_keys-和-keys-><span class=hanchor arialabel=Anchor># </span>possible_keys 和 keys <strong>☆</strong></h4></a><ul><li><code>possible_keys</code>表示执行查询时可能用到的索引，一个或多个。 查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用</strong>。</li><li><code>keys</code>表示实际使用的索引。如果为 NULL，则没有使用索引。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710142152514.png width=auto alt=image-20220710142152514></p><a href=#key_len-><h4 id=key_len-><span class=hanchor arialabel=Anchor># </span>key_len <strong>☆</strong></h4></a><p>表示索引使用的字节数，根据这个值可以判断索引的使用情况，<code>检查是否充分利用了索引，针对联合索引值越大越好。</code>
<strong>如何计算：</strong></p><ol><li>先看索引上字段的类型+长度。比如：int=4 ; varchar(20) =20 ; char(20) =20</li><li>如果是 varchar 或者 char 这种字符串字段，视字符集要乘不同的值，比如 utf8 要乘 3，如果是 utf8mb4 要乘 4，GBK 要乘 2</li><li>varchar 这种动态字符串要加 2 个字节</li><li>允许为空的字段要加 1 个字节</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 创建索引
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_age_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>t_emp</span><span class=p>(</span><span class=n>age</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>name</span><span class=o>`</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 测试1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t_emp</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>30</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=o>`</span><span class=n>name</span><span class=o>`</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;ab%&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 测试2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t_emp</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>30</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710130548971.png width=auto alt=image-20220710130548971></p><a href=#ref><h4 id=ref><span class=hanchor arialabel=Anchor># </span>ref</h4></a><p>显示与 key 中的索引进行比较的列或常量。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- ref=atguigudb.t1.id 关联查询时出现，t2表和t1表的哪一列进行关联
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=p>,</span><span class=w> </span><span class=n>t2</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>t1</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>t2</span><span class=p>.</span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- ref=const 与索引列进行等值比较的东西是啥，const表示一个常数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t_emp</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>30</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220709211819944.png width=auto alt=image-20220709211819944></p><a href=#rows-><h4 id=rows-><span class=hanchor arialabel=Anchor># </span>rows <strong>☆</strong></h4></a><p>MySQL 认为它执行查询时必须检查的行数。值越小越好。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 如果是全表扫描，rows的值就是表中数据的估计行数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t_emp</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>empno</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;10001&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 如果是使用索引查询，rows的值就是预计扫描索引记录行数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t_emp</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>deptId</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710131916240.png width=auto alt=image-20220710131916240></p><a href=#filtered><h4 id=filtered><span class=hanchor arialabel=Anchor># </span>filtered</h4></a><p>最后查询出来的数据占所有服务器端检查行数（rows）的<code>百分比</code>。值越大越好。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 先根据二级索引deptId找到数据的主键，有3条记录满足条件，
</span></span></span><span class=line><span class=cl><span class=c1>-- 再根据主键进行回表，最终找到3条记录，有100%的记录满足条件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t_emp</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>deptId</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 这个例子如果name列是索引列则 filtered = 100 否则filtered = 10(全表扫描)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t_emp</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=o>`</span><span class=n>name</span><span class=o>`</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;风清扬&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220709212722601.png width=auto alt=image-20220709212722601></p><a href=#extra-><h4 id=extra-><span class=hanchor arialabel=Anchor># </span>Extra <strong>☆</strong></h4></a><p>包含不适合在其他列中显示但十分重要的额外信息。通过这些额外信息来<code>理解MySQL到底将如何执行当前的查询语句</code>。MySQL 提供的额外信息有好几十个，这里只挑介绍比较重要的介绍。</p><ul><li><strong>Impossible WHERE</strong>：where 子句的值总是 false</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t_emp</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220709231638201.png width=auto alt=image-20220709231638201></p><ul><li>**Using where：**使用了 where，但在 where 上有字段没有创建索引</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t_emp</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=o>`</span><span class=n>name</span><span class=o>`</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;风清扬&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220709215122017.png width=auto alt=image-20220709215122017></p><ul><li>**Using temporary：**使了用临时表保存中间结果</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=k>DISTINCT</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710181100102.png width=auto alt=image-20220710181100102></p><ul><li><strong>Using filesort：</strong>
在对查询结果中的记录进行排序时，是可以使用索引的，如下所示：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710172607190.png width=auto alt=image-20220710172607190>
如果排序操作无法使用到索引，只能在内存中（记录较少时）或者磁盘中（记录较多时）进行排序（filesort），如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>content</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710172926396.png width=auto alt=image-20220710172926396></p><ul><li>Using index：使用了覆盖索引，表示直接访问索引就足够获取到所需要的数据，不需要通过索引回表</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>content1</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t4</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220712071716131.png width=auto alt=image-20220712071716131></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220712072055566.png width=auto alt=image-20220712072055566></p><ul><li>Using index condition：叫作 <code>Index Condition Pushdown Optimization （索引下推优化）</code></li><li><code>如果没有索引下推（ICP）</code>，那么 MySQL 在存储引擎层找到满足<code>content1 > 'z'</code>条件的第一条二级索引记录。<code>主键值进行回表</code>，返回完整的记录给 server 层，server 层再判断其他的搜索条件是否成立。如果成立则保留该记录，否则跳过该记录，然后向存储引擎层要下一条记录。</li><li><code>如果使用了索引下推（ICP</code>），那么 MySQL 在存储引擎层找到满足<code>content1 > 'z'</code>条件的第一条二级索引记录。<code>不着急执行回表</code>，而是在这条记录上先判断一下所有关于<code>idx_content1</code>索引中包含的条件是否成立，也就是<code>content1 > 'z' AND content1 LIKE '%a'</code>是否成立。如果这些条件不成立，则直接跳过该二级索引记录，去找下一条二级索引记录；如果这些条件成立，则执行回表操作，返回完整的记录给 server 层。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- content1列上有索引idx_content1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t4</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>content1</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=s1>&#39;z&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>content1</span><span class=w> </span><span class=k>LIKE</span><span class=w> </span><span class=s1>&#39;%a&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710180257692.png width=auto alt=image-20220710180257692>
注意：如果这里的查询条件<code>只有content1 > 'z'</code>，那么找到满足条件的索引后也会进行一次索引下推的操作，判断 content1 > &lsquo;z&rsquo;是否成立（这是源码中为了编程方便做的冗余判断）
<img src=https://jieye-ericx.github.io//../../pics/image-20220712012108900.png width=auto alt=image-20220712012108900></p><ul><li>Using join buffer：在连接查询时，当被驱动表不能有效的利用索引时，MySQL 会为其分配一块名为连接缓冲区（join buffer）的内存来加快查询速度</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=p>,</span><span class=w> </span><span class=n>t2</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>t1</span><span class=p>.</span><span class=n>content</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>t2</span><span class=p>.</span><span class=n>content</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710182356817.png width=auto alt=image-20220710182356817>
下面这个例子就是被驱动表使用了索引：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t_emp</span><span class=p>,</span><span class=w> </span><span class=n>t_dept</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>t_dept</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>t_emp</span><span class=p>.</span><span class=n>deptId</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://jieye-ericx.github.io//../../pics/image-20220710182524371.png width=auto alt=image-20220710182524371></p><a href=#133-mysql-数据库-cpu-飙升的话你会如何分析><h3 id=133-mysql-数据库-cpu-飙升的话你会如何分析><span class=hanchor arialabel=Anchor># </span>133 MySQL 数据库 cpu 飙升的话你会如何分析</h3></a><p>重点是定位问题
<strong>1 使用 top 观察 mysqld 的 cpu 利用率</strong></p><ol><li>切换到常用的数据库</li><li>使用 show full processlist;查看会话</li><li>观察是哪些 sql 消耗了资源，其中重点观察 state 指标</li><li>定位到具体 sql
<strong>2 pidstat</strong></li><li>定位到线程</li><li>在 PERFORMANCE_SCHEMA.THREADS 中记录了 thread_os_id 找到线程执行的 sql</li><li>根据操作系统 id 可以到 processlist 表找到对应的会话</li><li>在会话中即可定位到问题 sql
<strong>3 使用 show profile 观察 sql 各个阶段耗时</strong>
<strong>4 服务器上是否运行了其他程序</strong>
<strong>5 检查一下是否有慢查询</strong>
<strong>6 pref top</strong>
使用 pref 工具分析哪些函数引发的 cpu 过高来追踪定位
<img src=https://jieye-ericx.github.io//../../pics/image-20221106160437906.png width=auto alt=image-20221106160437906></li></ol><a href=#134-有没有进行过分库分表><h3 id=134-有没有进行过分库分表><span class=hanchor arialabel=Anchor># </span>134 有没有进行过分库分表？</h3></a><a href=#135-什么是分库分表><h3 id=135-什么是分库分表><span class=hanchor arialabel=Anchor># </span>135 什么是分库分表？</h3></a><p><strong>垂直分库</strong>
一个数据库由很多表的构成，每个表对应着<strong>不同的业务</strong>，垂直切分是指按照业务将表进行分类，分布到不同的数据库上面，这样也就将数据或者说压力分担到不同的库上面，如下图：
<img src=https://jieye-ericx.github.io//../../pics/111.jpg width=auto alt>
系统被切分成了，用户，订单交易，支付几个模块。
<strong>水平分表</strong>
把一张表里的内容按照不同的规则 写到不同的库里
相对于垂直拆分，水平拆分不是将表做分类，而是按照某个字段的某种规则来分散到多个库之中，每个表中包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行的切分，就是将表中的某些行切分到一个数据库，而另外的某些行又切分到其他的数据库中，如图：
<img src=https://jieye-ericx.github.io//../../pics/222.jpg width=auto alt></p><a href=#136-什么时候进行分库分表有没有配合-es-使用经验><h3 id=136-什么时候进行分库分表有没有配合-es-使用经验><span class=hanchor arialabel=Anchor># </span>136 什么时候进行分库分表？有没有配合 es 使用经验？</h3></a><ol><li>能不分就不分</li><li>单机性能下降明显的时候</li><li>增加缓存（通常查询量比较大），细分业务</li><li>首先尝试主被集群，读写分离</li><li>尝试分库</li><li>尝试分表 -> 冷热数据分离
大数据量下可以配合 es 完成高效查询</li></ol><a href=#137-说一下实现分库分表工具的实现思路><h3 id=137-说一下实现分库分表工具的实现思路><span class=hanchor arialabel=Anchor># </span>137 说一下实现分库分表工具的实现思路</h3></a><ol><li>伪装成 mysql 服务器，代理用户请求转发到真实服务器</li><li>基于本地 aop 实现，拦截 sql，改写，路由和结果归集处理。</li></ol><a href=#138-用过哪些分库分表工具><h3 id=138-用过哪些分库分表工具><span class=hanchor arialabel=Anchor># </span>138 用过哪些分库分表工具？</h3></a><p><img src=https://jieye-ericx.github.io//../../pics/25723371_16499183725J8d.png width=auto alt=img></p><a href=#139-分库分表后可能会有哪些问题><h3 id=139-分库分表后可能会有哪些问题><span class=hanchor arialabel=Anchor># </span>139 分库分表后可能会有哪些问题？</h3></a><p>经典的问题</p><ol><li>执行效率明显降低</li><li>表结构很难再次调整</li><li>引发分布式 id 问题</li><li>产生跨库 join</li><li>代理类中间件网络 io 成为瓶颈</li></ol><a href=#140-说一下读写分离常见方案><h3 id=140-说一下读写分离常见方案><span class=hanchor arialabel=Anchor># </span>140 说一下读写分离常见方案？</h3></a><p><img src=https://jieye-ericx.github.io//../../pics/image-20221106171251532.png width=auto alt=image-20221106171251532>
<img src=https://jieye-ericx.github.io//../../pics/image-20221106171945037.png width=auto alt=image-20221106171945037></p><a href=#141-为什么要使用视图-什么是视图><h3 id=141-为什么要使用视图-什么是视图><span class=hanchor arialabel=Anchor># </span>141 为什么要使用视图？ 什么是视图？</h3></a><p>视图定义：
1、视图是一个虚表，是从一个或几个基本表（或视图）导出的表。
2、只存放视图的定义，不存放视图对应的数据。
3、基表中的数据发生变化，从视图中查询出的数据也随之改变。
视图的作用：
1、视图能够简化用户的操作
2、视图使用户能以多种角度看待同一数据
3、视图对重构数据库提供了一定程度的逻辑独立性
4、视图能够对机密数据提供安全保护
5、适当的利用视图可以更清晰的表达查询</p><a href=#142-什么是存储过程有没有使用过><h3 id=142-什么是存储过程有没有使用过><span class=hanchor arialabel=Anchor># </span>142 什么是存储过程？有没有使用过？</h3></a><p>项目中禁止使用存储过程，存储过程难以调试和扩展，更没有移植性</p><a href=#143-有没有使用过外键有什么需要注意的地方><h3 id=143-有没有使用过外键有什么需要注意的地方><span class=hanchor arialabel=Anchor># </span>143 有没有使用过外键？有什么需要注意的地方？</h3></a><p>不得使用外键与级联，一切外键概念必须在应用层解决。
说明：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为 级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻 塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p><a href=#144-用过-processlist-吗><h3 id=144-用过-processlist-吗><span class=hanchor arialabel=Anchor># </span>144 用过 processlist 吗？</h3></a><p>关键的就是 state 列，mysql 列出的状态主要有以下几种：</p><ul><li>Checking table 正在检查数据表（这是自动的）。</li><li>Closing tables
正在将表中修改的数据刷新到磁盘中，同时正在关闭已经用完的表。这是一个很快的操作，如果不是这样的话，就应该确认磁盘空间是否已经满了或者磁盘是否正处于重负中。</li><li>Connect Out
复制从服务器正在连接主服务器。</li><li>Copying to tmp table on disk
由于临时结果集大于 tmp_table_size，正在将临时表从内存存储转为磁盘存储以此节省内存。</li><li>Creating tmp table
正在创建临时表以存放部分查询结果。</li><li>deleting from main table
服务器正在执行多表删除中的第一部分，刚删除第一个表。</li><li>deleting from reference tables
服务器正在执行多表删除中的第二部分，正在删除其他表的记录。</li><li>Flushing tables
正在执行 FLUSH TABLES，等待其他线程关闭数据表。</li><li>Killed
发送了一个 kill 请求给某线程，那么这个线程将会检查 kill 标志位，同时会放弃下一个 kill 请求。MySQL 会在每次的主循环中检查 kill 标志位，不过有些情况下该线程可能会过一小段才能死掉。如果该线程程被其他线程锁住了，那么 kill 请求会在锁释放时马上生效。</li><li>Locked 被其他查询锁住了。</li><li>Sending data
正在处理 Select 查询的记录，同时正在把结果发送给客户端。Sending data”状态的含义，原来这个状态的名称很具有误导性，所谓的“Sending data”并不是单纯的发送数据，而是包括“收集 + 发送 数据”。</li><li>Sorting for group
正在为 GROUP BY 做排序。</li><li>Sorting for order
正在为 ORDER BY 做排序。</li><li>Opening tables
这个过程应该会很快，除非受到其他因素的干扰。例如，在执 Alter TABLE 或 LOCK TABLE 语句行完以前，数据表无法被其他线程打开。正尝试打开一个表。</li><li>Removing duplicates
正在执行一个 Select DISTINCT 方式的查询，但是 MySQL 无法在前一个阶段优化掉那些重复的记录。因此，MySQL 需要再次去掉重复的记录，然后再把结果发送给客户端。</li><li>Reopen table
获得了对一个表的锁，但是必须在表结构修改之后才能获得这个锁。已经释放锁，关闭数据表，正尝试重新打开数据表。</li><li>Repair by sorting
修复指令正在排序以创建索引。</li><li>Repair with keycache
修复指令正在利用索引缓存一个一个地创建新索引。它会比 Repair by sorting 慢些。</li><li>Searching rows for update
正在讲符合条件的记录找出来以备更新。它必须在 Update 要修改相关的记录之前就完成了。</li><li>Sleeping
正在等待客户端发送新请求.</li><li>System lock
正在等待取得一个外部的系统锁。如果当前没有运行多个 mysqld 服务器同时请求同一个表，那么可以通过增加&ndash;skip-external-locking 参数来禁止外部系统锁。</li><li>Upgrading lock
Insert DELAYED 正在尝试取得一个锁表以插入新记录。=</li><li>Updating
正在搜索匹配的记录，并且修改它们。</li><li>User Lock
正在等待 GET_LOCK()。</li><li>Waiting for tables
该线程得到通知，数据表结构已经被修改了，需要重新打开数据表以取得新的结构。然后，为了能的重新打开数据表，必须等到所有其他线程关闭这个表。以下几种情况下会产生这个通知：FLUSH TABLES tbl_name, Alter TABLE, RENAME TABLE, REPAIR TABLE, ANALYZE TABLE,或 OPTIMIZE TABLE。</li><li>waiting for handler insert
Insert DELAYED 已经处理完了所有待处理的插入操作，正在等待新的请求。</li></ul><a href=#145-某个表有数千万数据查询比较慢如何优化说一下思路><h3 id=145-某个表有数千万数据查询比较慢如何优化说一下思路><span class=hanchor arialabel=Anchor># </span>145 某个表有数千万数据，查询比较慢，如何优化？说一下思路</h3></a><ol><li>前端优化 减少查询</li><li>合并请求:多个请求需要的数据尽量一条 sql 拿出来</li><li>会话保存：和用户会话相关的数据尽量一次取出重复使用</li><li>避免无效刷新</li><li>多级缓存 不要触及到数据库</li><li>应用层热点数据高速查询缓存（低一致性缓存）</li><li>高频查询大数据量镜像缓存（双写高一致性缓存）</li><li>入口层缓存（几乎不变的系统常量）</li><li>使用合适的字段类型，比如 varchar 换成 char</li><li>一定要高效使用索引。</li><li>使用 explain 深入观察索引使用情况</li><li>检查 select 字段最好满足索引覆盖</li><li>复合索引注意观察 key_len 索引使用情况</li><li>有分组，排序，注意 file sort，合理配置相应的 buffer 大小</li><li>检查查询是否可以分段查询，避免一次拿出过多无效数据</li><li>多表关联查询是否可以设置冗余字段，是否可以简化多表查询或分批查询</li><li>分而治之：把服务拆分成更小力度的微服务</li><li>冷热数据分库存储</li><li>读写分离，主被集群 然后再考虑分库分表</li></ol><a href=#146-count列名和-count有什么区别><h3 id=146-count列名和-count有什么区别><span class=hanchor arialabel=Anchor># </span>146 count(列名)和 count(*)有什么区别？</h3></a><p>count()是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。
说明：count()会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p><a href=#147-如果有超大分页改怎么处理><h3 id=147-如果有超大分页改怎么处理><span class=hanchor arialabel=Anchor># </span>147 如果有超大分页改怎么处理？</h3></a><ul><li><code>select name from user limit 10000,10;</code>在 使用的时候并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行</li><li>通过索引优化的方案：</li><li>如果主键自增可以 <code>select name from user where id > 10000 limit 10;</code></li><li>延迟关联</li><li>需要 order by 时</li><li>一定注意增加筛选条件，避免全表排序</li><li>where -》 order by -》 limit</li><li>减少 select 字段</li><li>优化相关参数避免 filesort</li></ul><ul><li>一般大分页情况比较少（很少有人跳转到几百万页去查看数据），实际互联网业务中多数还是按顺序翻页，可以使用缓存提升前几页的查询效率，实际上大多数知名互联网项目也都是这么做的
在阿里巴巴《Java 开发手册》中的建议：</li></ul><blockquote><p>【推荐】利用延迟关联或者子查询优化超多分页场景。 说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。 正例：先快速定位需要获取的 id 段，然后再关联： SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</p></blockquote><a href=#148-mysql-服务器毫无规律的异常重启如何排查问题><h3 id=148-mysql-服务器毫无规律的异常重启如何排查问题><span class=hanchor arialabel=Anchor># </span>148 mysql 服务器毫无规律的异常重启如何排查问题？</h3></a><p>首先是查看 mysql 和系统日志来定位错误
<strong>最常见的是关闭 swap 分区后 OOM 问题：</strong>
mysql 分为应用进程和守护进程
当应用进程内存占用过高的时候操作系统可能会 kill 掉进程，此时守护进程又帮我们重启了应用进程，运行一段时间后又出现 OOM 如此反复
可以排查以下几个关键点</p><ul><li>运行时内存占用率</li><li>mysql buffer 相关参数</li><li>mysql 网络连接相关参数
<strong>异常关机或 kill -9 mysql 后导致表文件损坏</strong></li><li>直接使用备份</li><li>配置 innodb_force_recovery 跳过启动恢复过程</li></ul><a href=#149-mysql-线上修改表结构有哪些风险><h3 id=149-mysql-线上修改表结构有哪些风险><span class=hanchor arialabel=Anchor># </span>149 mysql 线上修改表结构有哪些风险?</h3></a><p>针对 ddl 命令，有以下几种方式</p><ul><li>copy table 锁原表，创建临时表并拷贝数据</li><li>inplace 针对索引修改删除的优化，不需要拷贝所有数据</li><li>Online DDL 细分 DDL 命令来决定是否锁表</li><li>可能会锁表，导致无法读写</li><li>ORM 中的映射失效</li><li>索引失效
建议：建个新表，导入数据后重命名</li></ul><a href=#150-什么是-mysql-多实例部署><h3 id=150-什么是-mysql-多实例部署><span class=hanchor arialabel=Anchor># </span>150 什么是 mysql 多实例部署？</h3></a><p>指的是在一台主机上部署多个实例
主要目的是压榨服务器性能
缺点是互相影响</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/Mysql/ data-ctx="045 如果表中有字段为 null，又被经常查询该不该给这个字段创建索引？" data-src=/Mysql class=internal-link>Mysql</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://jieye-ericx.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Jieye ericx using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://jieye-ericx.github.io/>Home</a></li><li><a href=https://github.com/jieye-ericx>Github</a></li></ul></footer></div></div></body></html>