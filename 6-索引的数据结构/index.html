<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="6 索引的数据结构 1. 为什么使用索引 索弓是存储弓|擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分， 通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL 中也是一样的道理， 进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。
 假如给数据使用 二叉树 这样的数据结构进行存储，如下图所示
 二叉搜索树， 采用这种存储结构搜索数据的时间，复杂度是 log2N。
2. 索引及其优缺点 2.1 索引概述 MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。"><meta property="og:title" content="6 索引的数据结构"><meta property="og:description" content="6 索引的数据结构 1. 为什么使用索引 索弓是存储弓|擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分， 通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL 中也是一样的道理， 进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。
 假如给数据使用 二叉树 这样的数据结构进行存储，如下图所示
 二叉搜索树， 采用这种存储结构搜索数据的时间，复杂度是 log2N。
2. 索引及其优缺点 2.1 索引概述 MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。"><meta property="og:type" content="website"><meta property="og:image" content="https://jieye-ericx.github.io/icon.png"><meta property="og:url" content="https://jieye-ericx.github.io/6-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="6 索引的数据结构"><meta name=twitter:description content="6 索引的数据结构 1. 为什么使用索引 索弓是存储弓|擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分， 通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL 中也是一样的道理， 进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。
 假如给数据使用 二叉树 这样的数据结构进行存储，如下图所示
 二叉搜索树， 采用这种存储结构搜索数据的时间，复杂度是 log2N。
2. 索引及其优缺点 2.1 索引概述 MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。"><meta name=twitter:image content="https://jieye-ericx.github.io/icon.png"><title>6 索引的数据结构</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://jieye-ericx.github.io//icon.png><link href=https://jieye-ericx.github.io/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://jieye-ericx.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://jieye-ericx.github.io/js/darkmode.48459b7116d092b4e98d2cab704cad80.min.js></script>
<script src=https://jieye-ericx.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://jieye-ericx.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://jieye-ericx.github.io/",fetchData=Promise.all([fetch("https://jieye-ericx.github.io/indices/linkIndex.2bf6c2e682a064aa22f02334e3211622.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://jieye-ericx.github.io/indices/contentIndex.5c6b3822d647ef882d66726ca5dae3b9.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://jieye-ericx.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://jieye-ericx.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/jieye-ericx.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=jieye-ericx.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://jieye-ericx.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://jieye-ericx.github.io/>jieye の 数字花园</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>6 索引的数据结构</h1><p class=meta>Last updated
Nov 14, 2022</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#1-为什么使用索引>1. 为什么使用索引</a></li><li><a href=#2-索引及其优缺点>2. 索引及其优缺点</a><ol><li><a href=#21-索引概述>2.1 索引概述</a></li><li><a href=#22-优点>2.2 优点</a></li><li><a href=#23-缺点>2.3 缺点</a></li></ol></li><li><a href=#3-innodb-中索引的推演>3. InnoDB 中索引的推演</a><ol><li><a href=#31-索引之前的查找>3.1 索引之前的查找</a></li><li><a href=#32-设计索引>3.2 设计索引</a></li><li><a href=#33-常见索引概念>3.3 常见索引概念</a></li><li><a href=#34-innodb-的-b树索引的注意事项>3.4 InnoDB 的 B+树索引的注意事项</a></li></ol></li><li><a href=#4myisam-中的索引方案>4.MyISAM 中的索引方案</a><ol><li><a href=#43-myisam-与-innodb-对比>4.3 MyISAM 与 InnoDB 对比</a></li></ol></li><li><a href=#5索引的代价>5.索引的代价</a></li></ol></nav></details></aside><a href=#6-索引的数据结构><h1 id=6-索引的数据结构><span class=hanchor arialabel=Anchor># </span>6 索引的数据结构</h1></a><a href=#1-为什么使用索引><h2 id=1-为什么使用索引><span class=hanchor arialabel=Anchor># </span>1. 为什么使用索引</h2></a><p>索弓是存储弓|擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分， 通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL 中也是一样的道理， 进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。</p><p><img src=https://jieye-ericx.github.io//image-20220915190545240.png width=auto alt=image-20220915190545240></p><p>假如给数据使用 二叉树 这样的数据结构进行存储，如下图所示</p><p><img src=https://jieye-ericx.github.io//image-20220915191041693.png width=auto alt=image-20220915191041693></p><p>二叉搜索树， 采用这种存储结构搜索数据的时间，复杂度是 log2N。</p><a href=#2-索引及其优缺点><h2 id=2-索引及其优缺点><span class=hanchor arialabel=Anchor># </span>2. 索引及其优缺点</h2></a><a href=#21-索引概述><h3 id=21-索引概述><span class=hanchor arialabel=Anchor># </span>2.1 索引概述</h3></a><p>MySQL 官方对索引的定义为：<strong>索引（Index）是帮助 MySQL 高效获取数据的数据结构</strong>。</p><p>索引的本质：索引是数据结构。你可以简单理解为“<strong>排好序的快速查找数据结构</strong>”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现<strong>高级查找算法</strong> 。</p><p>索引是在存储引擎中实现的，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时,存储引擎可以定义每个表的最大索引数和最大索引长度。所有存储引擎支持每个表至少 16 个索引，总索引长度至少为 256 字节。有些存储引擎支持更多的索引数和更大的索引长度。</p><a href=#22-优点><h3 id=22-优点><span class=hanchor arialabel=Anchor># </span>2.2 优点</h3></a><ol><li>类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的 IO 成本 ，这也是创建索引最主 要的原因。</li><li>通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 。</li><li>在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。</li><li>在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间 ，降低了 CPU 的消耗。</li></ol><a href=#23-缺点><h3 id=23-缺点><span class=hanchor arialabel=Anchor># </span>2.3 缺点</h3></a><p>增加索引也有许多不利的方面，主要表现在如下几个方面：</p><ol><li>创建索引和维护索引要<strong>耗费时间</strong> ，并且随着数据量的增加，所耗费的时间也会增加。</li><li>索引需要占磁盘空间 ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度 。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</li></ol><p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p><blockquote><p>提示:<br>索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p></blockquote><a href=#3-innodb-中索引的推演><h2 id=3-innodb-中索引的推演><span class=hanchor arialabel=Anchor># </span>3. InnoDB 中索引的推演</h2></a><a href=#31-索引之前的查找><h3 id=31-索引之前的查找><span class=hanchor arialabel=Anchor># </span>3.1 索引之前的查找</h3></a><p>先来看一个精确匹配的例子： <code>SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;</code></p><ol><li><p>在一个页中的查找</p><p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况:</p><ul><li>以主键为搜索条件<br>可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li><li>以其他列作为搜索条件<br>因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录、开始依次遍历单链表中的每条记录,然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</li></ul></li><li><p>在很多页中查找</p><p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤: 1.定位到记录所在的页。 2.从所在的页内中查找相应的记录。</p><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们上面的查找方式去查 找指定的记录。因为要遍历所有的数据页，所以这种方式显然是超级耗时的。如果一个表有一亿条记录 呢？此时索引应运而生。</p></li></ol><a href=#32-设计索引><h3 id=32-设计索引><span class=hanchor arialabel=Anchor># </span>3.2 设计索引</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mysql&gt; CREATE TABLE index_demo<span class=o>(</span>
</span></span><span class=line><span class=cl>-&gt; c1 INT,
</span></span><span class=line><span class=cl>-&gt; c2 INT,
</span></span><span class=line><span class=cl>-&gt; c3 CHAR<span class=o>(</span>1<span class=o>)</span>,
</span></span><span class=line><span class=cl>-&gt; PRIMARY KEY<span class=o>(</span>c1<span class=o>)</span>
</span></span><span class=line><span class=cl>-&gt; <span class=o>)</span> <span class=nv>ROW_FORMAT</span> <span class=o>=</span> Compact<span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>这个新建的 index_demo 表中有 2 个 INT 类型的列，1 个 CHAR(1)类型的列，而且我们规定了 c1 列为主键， 这个表使用 Compact 行格式来实际存储记录的。这里我们简化了 index_demo 表的行格式示意图：
<img src=https://jieye-ericx.github.io//image-20220916191805510.png width=auto alt=image-20220916191805510></p><p>我们只在示意图里展示记录的这几个部分:</p><ul><li>record_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记 录、 3 表示最大记录、 1 暂时还没用过，下面讲。</li><li>next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用 箭头来表明下一条记录是谁。</li><li>各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。</li><li>其他信息 ：除了上述 3 种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p><p><img src=https://jieye-ericx.github.io//image-20220916191926077.png width=auto alt=image-20220916191926077></p><p>把一些记录放到页里的示意图就是：</p><p><img src=https://jieye-ericx.github.io//image-20220916191942056.png width=auto alt=image-20220916191942056></p><a href=#1-一个简单的索引设计方案><h4 id=1-一个简单的索引设计方案><span class=hanchor arialabel=Anchor># </span>1 一个简单的索引设计方案</h4></a><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规 律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果 我们 想快速的定位到需要查找的记录在哪些数据页 中该咋办？我们可以为快速定位记录所在的数据页而 建 立一个目录 ，建这个目录必须完成下边这些事：</p><ul><li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</li><li>给所有的页建立一个目录项。</li></ul><p>所以我们为上边几个页做好的目录就像这样子：</p><p><img src=https://jieye-ericx.github.io//image-20220916215005870.png width=auto alt=image-20220916215005870></p><p>以 页 28 为例，它对应目录项 2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主 键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键 值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步： 1. 先从目录项中根据 二分法 快速确定出主键值为 20 的记录在 目录项 3 中（因为 12 &lt; 20 &lt; 209 ），它对应的页是 页 9 。 2. 再根据前边说的在页中查找记录的方式去 页 9 中定位具体的记录。</p><p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 <strong>索引</strong> 。</p><a href=#2-innodb-中的索引方案><h4 id=2-innodb-中的索引方案><span class=hanchor arialabel=Anchor># </span>2 InnoDB 中的索引方案</h4></a><ol><li><p>迭代 1 次：目录项纪录的页</p><p><img src=https://jieye-ericx.github.io//image-20220916220239279.png width=auto alt=image-20220916220239279></p><p>从图中可以看出来，我们新分配了一个编号为 30 的页来专门存储目录项记录。这里再次强调 目录项记录 和普通的 用户记录 的不同点：</p><ul><li>目录项记录 的 record_type 值是 1，而 普通用户记录 的 record_type 值是 0</li><li>目录项记录<strong>只有 主键值和页的编号 两个列</strong>，而普通的用户记录的列是用户自己定义的，可能包含很多列 ，另外还有 InnoDB 自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫 <code>min_rec_mask</code> 的属性，只有在存储 目录项记录 的页中的主键值 最小的 目录项记录 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0 。</li></ul></li></ol><p>相同点：两者用的是一样的数据页，都会为主键值生成 Page Directory （页目录），从而在按照主键 值进行查找时可以使用 二分法 来加快查询速度。</p><p>现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步： 先到存储 目录项记录 的页，也就是页 30 中通过 二分法 快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页 9。 再到存储用户记录的页 9 中根据 二分法 快速定位到主键值为 20 的用户记录。</p><ol start=2><li><strong>迭代 2 次：多个目录项纪录的页</strong></li></ol><p><img src=https://jieye-ericx.github.io//image-20220916220613162.png width=auto alt=image-20220916220613162></p><p>从图中可以看出，我们插入了一条主键值为 320 的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了 页 31 。</li><li>因为原先存储目录项记录的 页 30 的容量已满 （我们前边假设只能存储 4 条目录项记录），所以不得 不需要一个新的 页 32 来存放 页 31 对应的目录项。</li></ul><p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要 3 个步 骤，以查找主键值为 20 的记录为例：</p><ul><li>确定 目录项记录页</li><li>我们现在的存储目录项记录的页有两个，即 页 30 和 页 32 ，又因为页 30 表示的目录项的主键值的 范围是 [1, 320) ，页 32 表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目 录项记录在 页 30 中。</li><li>通过目录项记录页 确定用户记录真实所在的页 。 在一个存储 目录项记录 的页中通过主键值定位一条目录项记录的方式说过了。</li><li>在真实存储用户记录的页中定位到具体的记录。</li></ul><ol start=3><li><p><strong>迭代 3 次：目录项记录页的目录页</strong></p><p><img src=https://jieye-ericx.github.io//image-20220916221316006.png width=auto alt=image-20220916221316006></p><p>如图，我们生成了一个存储更高级目录项的 页 33 ，这个页中的两条记录分别代表页 30 和页 32，如果用 户记录的主键值在 [1, 320) 之间，则到页 30 中查找更详细的目录项记录，如果主键值 不小于 320 的 话，就到页 32 中查找更详细的目录项记录。</p><p>我们可以用下边这个图来描述它：</p><p><img src=https://jieye-ericx.github.io//image-20220916221606364.png width=auto alt=image-20220916221606364></p></li><li><p>B+Tree</p><p>一个 B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放 3 条记录 ，存放目录项 记录的页 最多存放 4 条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 100 条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 1000 条目录项记录 ，那么：</p><ul><li><p>如果 B+树只有 1 层，也就是只有 1 个用于存放用户记录的节点，最多能存放 100 条记录。</p></li><li><p>如果 B+树有 2 层，最多能存放 1000×100=10,0000 条记录。</p></li><li><p>如果 B+树有 3 层，最多能存放 1000×1000×100=1,0000,0000 条记录。</p></li><li><p>如果 B+树有 4 层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。相当多的记 录！！！</p><p>你的表里能存放 100000000000 条记录吗？所以一般情况下，我们用到的 B+树都不会超过 4 层 ，那我们 通过主键值去查找某条记录最多只需要做 4 个页面内的查找（查找 3 个目录项页和一个用户记录页），又因为在每个页面内有所谓的 Page Directory （页目录），所以在<strong>页面内也可以通过二分法实现快速 定位记录。</strong></p></li></ul></li></ol><a href=#33-常见索引概念><h3 id=33-常见索引概念><span class=hanchor arialabel=Anchor># </span>3.3 常见索引概念</h3></a><ol><li><p>聚簇索引</p><p>特点：</p><ol><li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p><ul><li>页内的记录是<strong>按照主键的大小顺序排成一个单向链表</strong> 。</li><li>各个存放用户记录的页也是<strong>根据页中用户记录的主键大小顺序排成一个双向链表</strong>。</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 双向链表 。</li></ul></li><li><p>B+树的叶子节点存储的是完整的用户记录。</p><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p></li></ol><p>优点：</p><ul><li>数据访问更快 ，因为聚簇索引<strong>将索引和数据保存在同一个 B+树中</strong>，因此从聚簇索引中获取数据比非 聚簇索引更快。</li><li>聚簇索引对于<strong>主键的排序查找和范围查找速度非常快</strong></li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的 io 操作 。</li></ul><p>缺点：</p><ul><li>插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主键</li><li>更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义<strong>主键为不可更新</strong></li><li>二级索引访问需要两次索引查找 ，第一次找到主键值，第二次根据主键值找到行数</li></ul></li><li><p>二级索引（辅助索引、非聚簇索引）</p></li></ol><p><img src=https://jieye-ericx.github.io//image-20220917151332531.png width=auto alt=image-20220917151332531></p><p><strong>回表</strong>：我们根据这个以 c2 列大小排序的 B+树只能确定我们要查找记录的主键值，所以如果我们想根据 c2 列的值查找到完整的用户记录的话，<strong>仍然需要到聚簇索引中再查一遍</strong>，这个过程称为回表，也就是根据 c2 列的值查询一条完整的用户记录需要使用到 2 棵 B+树！</p><ol start=3><li><p>联合索引</p><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让 B+树按 照 c2 和 c3 列 的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照 c2 列进行排序</li><li>在记录的 c2 列相同的情况下，采用 c3 列进行排序</li></ul><p>注意一点，以 c2 和 c3 列的大小为排序规则建立的 B+树称为<strong>联合索引</strong> ，本质上也是一个二级索引。它的意思与分别为 c2 和 c3 列分别建立索引的表述是不同的，不同点如下： 建立联合索引只会建立如上图一样的 1 棵 B+树。 为 c2 和 c3 列分别建立索引会分别以 c2 和 c3 列的大小为排序规则建立 2 棵 B+树。</p></li></ol><a href=#34-innodb-的-b树索引的注意事项><h3 id=34-innodb-的-b树索引的注意事项><span class=hanchor arialabel=Anchor># </span>3.4 InnoDB 的 B+树索引的注意事项</h3></a><ol><li>根页面位置万年不动</li><li>内节点中目录项记录的唯一性</li><li>一个页面最少存储 2 条记录</li></ol><a href=#4myisam-中的索引方案><h2 id=4myisam-中的索引方案><span class=hanchor arialabel=Anchor># </span>4.MyISAM 中的索引方案</h2></a><p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb 和 MyISAM 默认的索引是 Btree 索引；而 Memory 默认的索引是 Hash 索引。</p><p>MyISAM 引擎使用 B+Tree 作为索引结构，叶子节点的 data 域存放的是 数据记录的地址 。<br><img src=https://jieye-ericx.github.io//1ed78e86a4a4539d660cbc7088062cde.png width=auto alt=image-20220917151332531></p><p>如果我们在 Col2 上建立一个二级索引，则此索引的结构如下图所示：<br><img src=https://jieye-ericx.github.io//7124b14c8f4ceda3a22367da6b495817.png width=auto alt=image-20220917151332531></p><a href=#43-myisam-与-innodb-对比><h3 id=43-myisam-与-innodb-对比><span class=hanchor arialabel=Anchor># </span>4.3 MyISAM 与 InnoDB 对比</h3></a><p>MyISAM 的索引方式都是“非聚簇”的，与 InnoDB 包含 1 个聚簇索引是不同的。小结两种引擎中索引的区别：</p><ol><li>在 InnoDB 存储引擎中，我们只需要<strong>根据主键值对聚簇索引进行一次查找就能找到对应的记录</strong>，而在 MyISAM 中却需要进行一次回表操作，<strong>意味着 MyISAM 中建立的索引相当于全部都是二级索引</strong> 。</li><li>InnoDB 的数据文件本身就是索引文件，而 MyISAM 索引文件和数据文件是分离的 ，索引文件仅保存数据记录的地址。</li><li>InnoDB 的非聚簇索引 data 域存储相应记录主键的值 ，而 MyISAM 索引记录的是地址 。换句话说， <strong>InnoDB 的所有非聚簇索引都引用主键作为 data 域</strong>。</li><li>MyISAM 的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观 InnoDB 是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</li><li>InnoDB 要求表必须有主键 （ MyISAM 可以没有 ）。如果没有显式指定，则 MySQL 系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐 含字段作为主键，这个字段长度为 6 个字节，类型为长整型。<br><img src=https://jieye-ericx.github.io//63abc199acbb4281a194563f38a773c1.png width=auto alt=image-20220917151332531></li></ol><a href=#5索引的代价><h2 id=5索引的代价><span class=hanchor arialabel=Anchor># </span>5.索引的代价</h2></a><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p><ol><li>空间上的代价:<br>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用16KB的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</li><li>时间上的代价:<br>每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引。而且我们讲过,B+树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，<strong>所以存储引擎需要额外的时间进行一些记录移位页面分裂、页面回收等操作来维护好节点和记录的排序</strong>。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</li></ol></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/Mysql-%E5%8E%9F%E7%90%86/ data-ctx="6 索引的数据结构" data-src=/Mysql-%E5%8E%9F%E7%90%86 class=internal-link>Mysql 原理</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://jieye-ericx.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Jieye ericx using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://jieye-ericx.github.io/>Home</a></li><li><a href=https://github.com/jieye-ericx>Github</a></li></ul></footer></div></div></body></html>