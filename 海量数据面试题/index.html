<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="1 、海量日志数据，提取出某日访问百度次数最多的那个 IP。 首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法， 比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大 的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。
算法思想：分而治之+Hash
 IP 地址最多有 2^32=4 G 种取值情况，所以不能完全加载到内存中处理； 可以考虑采用“分而治之”的思想，按照 IP 地址的 Hash (IP)%1024 值，把海量 IP 日志分别存储到 1024 个小文件中。这样，每个小文件最多包含 4 MB 个 IP 地址； 对于每一个小文件，可以构建一个 IP 为 key，出现次数为 value 的 Hash map，同时记录当前出现次数最多的那个 IP 地址； 可以得到 1024 个小文件中的出现次数最多的 IP，再依据常规的排序算法得到总体上出现次数最多的 IP；  2 、搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为 1-255 字节。  假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是 1 千万，但如果除去重复后，不超过 3 百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的 10 个查询串，要求使用的内存不能超过 1 G。"><meta property="og:title" content><meta property="og:description" content="1 、海量日志数据，提取出某日访问百度次数最多的那个 IP。 首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法， 比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大 的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。
算法思想：分而治之+Hash
 IP 地址最多有 2^32=4 G 种取值情况，所以不能完全加载到内存中处理； 可以考虑采用“分而治之”的思想，按照 IP 地址的 Hash (IP)%1024 值，把海量 IP 日志分别存储到 1024 个小文件中。这样，每个小文件最多包含 4 MB 个 IP 地址； 对于每一个小文件，可以构建一个 IP 为 key，出现次数为 value 的 Hash map，同时记录当前出现次数最多的那个 IP 地址； 可以得到 1024 个小文件中的出现次数最多的 IP，再依据常规的排序算法得到总体上出现次数最多的 IP；  2 、搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为 1-255 字节。  假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是 1 千万，但如果除去重复后，不超过 3 百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的 10 个查询串，要求使用的内存不能超过 1 G。"><meta property="og:type" content="website"><meta property="og:image" content="https://jieye-ericx.github.io/icon.png"><meta property="og:url" content="https://jieye-ericx.github.io/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E9%A2%98/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="1 、海量日志数据，提取出某日访问百度次数最多的那个 IP。 首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法， 比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大 的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。
算法思想：分而治之+Hash
 IP 地址最多有 2^32=4 G 种取值情况，所以不能完全加载到内存中处理； 可以考虑采用“分而治之”的思想，按照 IP 地址的 Hash (IP)%1024 值，把海量 IP 日志分别存储到 1024 个小文件中。这样，每个小文件最多包含 4 MB 个 IP 地址； 对于每一个小文件，可以构建一个 IP 为 key，出现次数为 value 的 Hash map，同时记录当前出现次数最多的那个 IP 地址； 可以得到 1024 个小文件中的出现次数最多的 IP，再依据常规的排序算法得到总体上出现次数最多的 IP；  2 、搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为 1-255 字节。  假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是 1 千万，但如果除去重复后，不超过 3 百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的 10 个查询串，要求使用的内存不能超过 1 G。"><meta name=twitter:image content="https://jieye-ericx.github.io/icon.png"><title>jieye の 数字花园</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://jieye-ericx.github.io//icon.png><link href=https://jieye-ericx.github.io/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://jieye-ericx.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://jieye-ericx.github.io/js/darkmode.48459b7116d092b4e98d2cab704cad80.min.js></script>
<script src=https://jieye-ericx.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://jieye-ericx.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://jieye-ericx.github.io/",fetchData=Promise.all([fetch("https://jieye-ericx.github.io/indices/linkIndex.d562e04b781c4ee6550d42b2193dcfd6.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://jieye-ericx.github.io/indices/contentIndex.eefd8cc39a4cac99e0063483c8676a57.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://jieye-ericx.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://jieye-ericx.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/jieye-ericx.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=jieye-ericx.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://jieye-ericx.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://jieye-ericx.github.io/>jieye の 数字花园</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#1-海量日志数据提取出某日访问百度次数最多的那个-ip>1 、海量日志数据，提取出某日访问百度次数最多的那个 IP。</a></li><li><a href=#2-搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来每个查询串的长度为-1-255-字节>2 、搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为 1-255 字节。</a></li><li><a href=#3-有一个-1-g-大小的一个文件里面每一行是一个词词的大小不超过-16-字节内存限制大小是-1-m返回频数最高的-100-个词>3 、有一个 1 G 大小的一个文件，里面每一行是一个词，词的大小不超过 16 字节，内存限制大小是 1 M。返回频数最高的 100 个词。</a></li><li><a href=#4-有-10-个文件每个文件-1-g每个文件的每一行存放的都是用户的-query每个文件的-query-都可能重复要求你按照-query-的频度排序>4 、有 10 个文件，每个文件 1 G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求你按照 query 的频度排序。</a></li><li><a href=#5-给定-ab-两个文件各存放-50-亿个-url每个-url-各占-64-字节内存限制是-4-g让你找出-ab-文件共同的-url>5 、给定 a、b 两个文件，各存放 50 亿个 url，每个 url 各占 64 字节，内存限制是 4 G，让你找出 a、b 文件共同的 url？</a></li><li><a href=#6-在-25-亿个整数中找出不重复的整数注内存不足以容纳这-25-亿个整数>6 、在 2.5 亿个整数中找出不重复的整数，注，内存不足以容纳这 2.5 亿个整数。</a></li><li><a href=#7-腾讯面试题给-40-亿个不重复的-unsignedint-的整数没排过序的然后再给一个数如何快速判断这个数是否在那-40-亿个数当中>7 、腾讯面试题：给 40 亿个不重复的 unsigned int 的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那 40 亿个数当中？</a></li><li><a href=#8-怎么在海量数据中找出重复次数最多的一个>8 、怎么在海量数据中找出重复次数最多的一个？</a></li><li><a href=#9-上千万或上亿数据有重复统计其中出现次数最多的前-n-个数据>9 、上千万或上亿数据（有重复），统计其中出现次数最多的前 N 个数据。</a></li><li><a href=#10-一个文本文件大约有一万行每行一个词要求统计出其中最频繁出现的前-10-个词请给出思想给出时间复杂度分析>10 、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前 10 个词，请给出思想，给出时间复杂度分析。</a></li></ol></nav></details></aside><a href=#1-海量日志数据提取出某日访问百度次数最多的那个-ip><h2 id=1-海量日志数据提取出某日访问百度次数最多的那个-ip><span class=hanchor arialabel=Anchor># </span>1 、海量日志数据，提取出某日访问百度次数最多的那个 IP。</h2></a><p>首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法， 比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大 的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。</p><p>算法思想：分而治之+Hash</p><ol><li>IP 地址最多有 2^32=4 G 种取值情况，所以不能完全加载到内存中处理；</li><li>可以考虑采用“分而治之”的思想，按照 IP 地址的 Hash (IP)%1024 值，把海量 IP 日志分别存储到 1024 个小文件中。这样，每个小文件最多包含 4 MB 个 IP 地址；</li><li>对于每一个小文件，可以构建一个 IP 为 key，出现次数为 value 的 Hash map，同时记录当前出现次数最多的那个 IP 地址；</li><li>可以得到 1024 个小文件中的出现次数最多的 IP，再依据常规的排序算法得到总体上出现次数最多的 IP；</li></ol><a href=#2-搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来每个查询串的长度为-1-255-字节><h2 id=2-搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来每个查询串的长度为-1-255-字节><span class=hanchor arialabel=Anchor># </span>2 、搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为 1-255 字节。</h2></a><p>   
   假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是 1 千万，但如果除去重复后，不超过 3 百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的 10 个查询串，要求使用的内存不能超过 1 G。</p><p>   第一步、先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计
   第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。
   即，借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别 和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N&rsquo;*O（logK），（N为1000万，N’为300万）。ok，更多，详情，请参考原文。
    或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p><a href=#3-有一个-1-g-大小的一个文件里面每一行是一个词词的大小不超过-16-字节内存限制大小是-1-m返回频数最高的-100-个词><h2 id=3-有一个-1-g-大小的一个文件里面每一行是一个词词的大小不超过-16-字节内存限制大小是-1-m返回频数最高的-100-个词><span class=hanchor arialabel=Anchor># </span>3 、有一个 1 G 大小的一个文件，里面每一行是一个词，词的大小不超过 16 字节，内存限制大小是 1 M。返回频数最高的 100 个词。</h2></a><p>   方案：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,&mldr;x4999）中。这样每个文件大概是200k左右。</p><p>   如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。
   对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结 点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。</p><a href=#4-有-10-个文件每个文件-1-g每个文件的每一行存放的都是用户的-query每个文件的-query-都可能重复要求你按照-query-的频度排序><h2 id=4-有-10-个文件每个文件-1-g每个文件的每一行存放的都是用户的-query每个文件的-query-都可能重复要求你按照-query-的频度排序><span class=hanchor arialabel=Anchor># </span>4 、有 10 个文件，每个文件 1 G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求你按照 query 的频度排序。</h2></a><p>还是典型的TOP K算法，解决方案如下：</p><ol><li>顺序读取10个文件，按照 hash(query)%10的结果将 query 写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设 hash 函数是随机的）。
   
    找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的 query_cout输出到文件中。这样得到了10个排好序的文件（记为）。</li></ol><p>    对这10个文件进行归并排序（内排序与外排序相结合）。</p><ol start=2><li><p> 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。</p></li><li><p>与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如<strong>MapReduce</strong>），最后再进行合并。</p></li></ol><a href=#5-给定-ab-两个文件各存放-50-亿个-url每个-url-各占-64-字节内存限制是-4-g让你找出-ab-文件共同的-url><h2 id=5-给定-ab-两个文件各存放-50-亿个-url每个-url-各占-64-字节内存限制是-4-g让你找出-ab-文件共同的-url><span class=hanchor arialabel=Anchor># </span>5 、给定 a、b 两个文件，各存放 50 亿个 url，每个 url 各占 64 字节，内存限制是 4 G，让你找出 a、b 文件共同的 url？</h2></a><ol><li>可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。</li></ol><p>    遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,&mldr;,a999）中。这样每个小文件的大约为300M。
    遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记b0,b1,&mldr;,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,&mldr;,a999vsb999）中，<strong>不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的 url即可</strong>。</p><p>    求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的<strong>hash_set</strong>中，如果是，那么就是共同的url，存到文件里面就可以了。</p><ol start=2><li>如果允许有一定的错误率，可以使用 Bloom filter ，4G 内存大概可以表示340亿 bit。将其中一个文件中的 url 使用 Bloom filter 映射为这340亿 bit，然后挨个读取另外一个文件的 url，检查是否与 Bloom filter，如果是，那么该 url 应该是共同的 url（注意会有一定的错误率）。</li></ol><a href=#6-在-25-亿个整数中找出不重复的整数注内存不足以容纳这-25-亿个整数><h2 id=6-在-25-亿个整数中找出不重复的整数注内存不足以容纳这-25-亿个整数><span class=hanchor arialabel=Anchor># </span>6 、在 2.5 亿个整数中找出不重复的整数，注，内存不足以容纳这 2.5 亿个整数。</h2></a><p>方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看 bitmap，把对应位是01的整数输出即可。</p><p>方案2：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。</p><a href=#7-腾讯面试题给-40-亿个不重复的-unsignedint-的整数没排过序的然后再给一个数如何快速判断这个数是否在那-40-亿个数当中><h2 id=7-腾讯面试题给-40-亿个不重复的-unsignedint-的整数没排过序的然后再给一个数如何快速判断这个数是否在那-40-亿个数当中><span class=hanchor arialabel=Anchor># </span>7 、腾讯面试题：给 40 亿个不重复的 unsigned int 的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那 40 亿个数当中？</h2></a><p>与上第6题类似，我的第一反应时快速排序+二分查找。以下是其它更好的方法：</p><ol><li>位图法 申请512M 的内存，一个 bit 位代表一个 unsigned int 值。读入40亿个数，设置相应的 bit 位，读入要查询的数，查看相应 bit 位是否为1，为1表示存在，为0表示不存在。</li><li>这个问题在《编程珠玑》里有很好的描述，大家可以参考下面的思路，探讨一下：又因为 2^32 为 40 亿多，所以给定一个数可能在，也可能不在其中；这里我们把 40 亿个数中的每一个用 32 位的二进制来表示假设这 40 亿个数开始放在一个文件中。然后将这40亿个数分成两类: 1.最高位为0。2.最高位为1。
    并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=20亿，而另一个>=20亿（这相当于折半了）；与要查找的数的最高位比较并接着进入相应的文件再查找再然后把这个文件为又分成两类: 1.次最高位为0。2.次最高位为1。并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=10亿，而另一个>=10亿（这相当于折半了）；与要查找的数的次最高位比较并接着进入相应的文件再查找。&mldr;&mldr;.
    以此类推，就可以找到了,而且时间复杂度为O(logn)，方案2完。</li></ol><a href=#8-怎么在海量数据中找出重复次数最多的一个><h2 id=8-怎么在海量数据中找出重复次数最多的一个><span class=hanchor arialabel=Anchor># </span>8 、怎么在海量数据中找出重复次数最多的一个？</h2></a><p>感觉就是 Top 1？</p><p>方案1：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p><a href=#9-上千万或上亿数据有重复统计其中出现次数最多的前-n-个数据><h2 id=9-上千万或上亿数据有重复统计其中出现次数最多的前-n-个数据><span class=hanchor arialabel=Anchor># </span>9 、上千万或上亿数据（有重复），统计其中出现次数最多的前 N 个数据。</h2></a><p>方案1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第2题提到的堆机制完成。</p><a href=#10-一个文本文件大约有一万行每行一个词要求统计出其中最频繁出现的前-10-个词请给出思想给出时间复杂度分析><h2 id=10-一个文本文件大约有一万行每行一个词要求统计出其中最频繁出现的前-10-个词请给出思想给出时间复杂度分析><span class=hanchor arialabel=Anchor># </span>10 、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前 10 个词，请给出思想，给出时间复杂度分析。</h2></a><p>方案1：这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n<em>le)（le表示单词的平准长度）。然后是找出出现最频繁的前10 个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n</em>lg10)。所以总的时间复杂度，是O(n<em>le)与O(n</em>lg10)中较大的哪一 个。</p><p>第二部分、十个海量数据处理方法大总结</p><p>    ok，看了上面这么多的面试题，是否有点头晕。是的，需要一个总结。接下来，本文将简单总结下一些处理海量数据问题的常见方法，而日后，本BLOG内会具体阐述这些方法。</p><p>    下面的方法全部来自 http://hi.baidu.com/yanxionglu/blog/博客，对海量数据的处理方法进行了一个一般性的总结，当然这些方法可能并不能完全覆盖所有的问题，但是这样的一些方法也基本可以处理绝大多数遇到的问题。下面的一些问题基本直接来源于公司的面试笔试题目，方法不一定最优，如果你有更好的处理方法，欢迎讨论。</p><p>一、Bloom filter</p><p>　　适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集</p><p>　　基本原理及要点：
　　对于原理来说很简单，位数组+k 个独立 hash 函数。将 hash 函数对应的值的位数组置 1，查找时如果发现所有 hash 函数对应位都是 1 说明存在，很明显这个过程并不保证查找的结果是 100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个 counter 数组代替位数组，就可以支持删除了。</p><p>　　还有一个比较重要的问题，如何根据输入元素个数 n，确定位数组 m 的大小及 hash 函数个数。当 hash 函数个数 k=(ln 2)<em>(m/n)时错误率最小。在错误率不大于 E 的情况下，m 至少要等于 n</em>lg (1/E)才能表示任意 n 个元素的集合。但 m 还应该更大些，因为还要保证 bit 数组里至少一半为 0，则 m 应该>=nlg (1/E)*lge 大概就是 nlg (1/E)1.44倍(lg 表示以2为底的对数)。</p><p>　　举个例子我们假设错误率为 0.01，则此时 m 应大概是 n 的 13 倍。这样 k 大概是8个。</p><p>　　注意这里 m 与 n 的单位不同，m 是 bit 为单位，而 n 则是以元素个数为单位 (准确的说是不同元素的个数)。通常单个元素的长度都是有很多 bit 的。所以使用 bloom filter 内存上通常都是节省的。</p><p>　　扩展：
　　Bloom filter 将集合中的元素映射到位数组中，用 k（k 为哈希函数个数）个映射位是否全 1 表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个 counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF 采用 counter 中的最小值来近似表示元素的出现频率。</p><p>　　问题实例：给你 A, B 两个文件，各存放 50 亿条 URL，每条 URL 占用 64 字节，内存限制是 4 G，让你找出 A, B 文件共同的 URL。如果是三个乃至 n 个文件呢？</p><p>　　根据这个问题我们来计算下内存的占用，4 G=2^32 大概是 40 亿*8 大概是 340 亿，n=50 亿，如果按出错率 0.01 算需要的大概是 650 亿个 bit。现在可用的是 340 亿，相差并不多，这样可能会使出错率上升些。另外如果这些 urlip 是一一对应的，就可以转换成 ip，则大大简单了。</p><p>二、Hashing</p><p>　　适用范围：快速查找，删除的基本数据结构，通常需要总数据量可以放入内存</p><p>　　基本原理及要点：
　　Hash 函数选择，针对字符串，整数，排列，具体相应的 hash 方法。
　　碰撞处理，一种是 open hashing，也称为拉链法；另一种就是 closed hashing，也称开地址法，opened addressing。</p><p>      扩展：
　　 d-left hashing 中的 d 是多个的意思，我们先简化这个问题，看一看 2-left hashing。2-left hashing 指的是将一个哈希表分成长度相等的两半，分别叫做 T 1 和 T 2，给 T 1 和 T 2 分别配备一个哈希函数，h 1 和 h 2。在存储一个新的 key 时，同时用两个哈希函数进行计算，得出两个地址 h 1[key]和 h 2[key]。这时需要检查 T 1 中的 h 1[key]位置和 T 2 中的 h 2[key]位置，哪一个位置已经存储的（有碰撞的）key 比较多，然后将新 key 存储在负载少的位置。如果两边一样多，比如两个位置都为空或者都存储了一个 key，就把新 key 存储在左边的 T 1 子表中，2-left 也由此而来。在查找一个 key 时，必须进行两次 hash，同时查找两个位置。</p><p>　　问题实例：
　　1). 海量日志数据，提取出某日访问百度次数最多的那个 IP。
　　IP 的数目还是有限的，最多 2^32 个，所以可以考虑使用 hash 将 ip 直接存入内存，然后进行统计。</p><p>三、bit-map</p><p>　　适用范围：可进行数据的快速查找，判重，删除，一般来说数据范围是 int 的 10 倍以下</p><p>　　基本原理及要点：使用 bit 数组来表示某些元素是否存在，比如 8 位电话号码</p><p>　　扩展：bloom filter 可以看做是对 bit-map 的扩展</p><p>　　问题实例：
　　1)已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。
　　8 位最多 99 999 999，大概需要 99 m 个 bit，大概 10 几 m 字节的内存即可。
　　2) 2.5 亿个整数中找出不重复的整数的个数，内存空间不足以容纳这 2.5 亿个整数。</p><p>　　将 bit-map 扩展一下，用 2 bit 表示一个数即可，0 表示未出现，1 表示出现一次，2 表示出现 2 次及以上。或者我们不用 2 bit 来进行表示，我们用两个 bit-map 即可模拟实现这个 2 bit-map。</p><p>四、堆</p><p>　　适用范围：海量数据前 n 大，并且 n 比较小，堆可以放入内存</p><p>　　基本原理及要点：最大堆求前 n 小，最小堆求前 n 大。方法，比如求前 n 小，我们比较当前元素与最大堆里的最大元素，如果它小于最大元素，则应该替换那个最大元素。这样最后得到的 n 个元素就是最小的 n 个。适合大数据量，求前 n 小，n 的大小比较小的情况，这样可以扫描一遍即可得到所有的前 n 元素，效率很高。</p><p>　　扩展：双堆，一个最大堆与一个最小堆结合，可以用来维护中位数。</p><p>　　问题实例：
　　1) 100 w 个数中找最大的前 100 个数。
　　用一个 100 个元素大小的最小堆即可。</p><p> </p><p>五、双层桶划分&mdash;-其实本质上就是【分而治之】的思想，重在“分”的技巧上！</p><p>　　适用范围：第 k 大，中位数，不重复或重复的数字
　　基本原理及要点：因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。可以通过多次缩小，双层只是一个例子。</p><p>　　扩展：
　　问题实例：
　　1). 2.5 亿个整数中找出不重复的整数的个数，内存空间不足以容纳这 2.5 亿个整数。
　　有点像鸽巢原理，整数个数为 2^32, 也就是，我们可以将这 2^32 个数，划分为 2^8 个区域 (比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用 bitmap 就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。</p><p>　　2). 5 亿个 int 找它们的中位数。
　　这个例子比上面那个更明显。首先我们将 int 划分为 2^16 个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。</p><p>　　实际上，如果不是 int 是 int 64，我们可以经过 3 次这样的划分即可降低到可以接受的程度。即可以先将 int 64 分成 2^24 个区域，然后确定区域的第几大数，在将该区域分成 2^20 个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有 2^20，就可以直接利用 direct addr table 进行统计了。</p><p>六、数据库索引</p><p>　　适用范围：大数据量的增删改查</p><p>　　基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。</p><p>七、倒排索引 (Inverted index)</p><p>　　适用范围：搜索引擎，关键字查询</p><p>　　基本原理及要点：为何叫倒排索引？一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。</p><p>　以英文为例，下面是要被索引的文本：
    T 0 = &ldquo;it is what it is&rdquo;
    T 1 = &ldquo;what is it&rdquo;
    T 2 = &ldquo;it is a banana&rdquo;</p><p>我们就能得到下面的反向文件索引：</p><p>    &ldquo;a&rdquo;:      {2}
    &ldquo;banana&rdquo;: {2}
    &ldquo;is&rdquo;:     {0, 1, 2}
    &ldquo;it&rdquo;:     {0, 1, 2}
    &ldquo;what&rdquo;:   {0, 1}</p><p>　检索的条件"what",&ldquo;is"和"it"将对应集合的交集。</p><p>　　正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。</p><p>　　扩展：
　　问题实例：文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。</p><p>八、外排序</p><p>　　适用范围：大数据的排序，去重</p><p>　　基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树</p><p>　　扩展：</p><p>　　问题实例：
　　1). 有一个 1 G 大小的一个文件，里面每一行是一个词，词的大小不超过 16 个字节，内存限制大小是 1 M。返回频数最高的 100 个词。</p><p>　　这个数据具有很明显的特点，词的大小为 16 个字节，但是内存只有 1 m 做 hash 有些不够，所以可以用来排序。内存可以当输入缓冲区使用。</p><p>九、trie 树</p><p>　　适用范围：数据量大，重复多，但是数据种类小可以放入内存</p><p>　　基本原理及要点：实现方式，节点孩子的表示方式</p><p>　　扩展：压缩实现。</p><p>　　问题实例：
　　1). 有 10 个文件，每个文件 1 G，每个文件的每一行都存放的是用户的 query，每个文件的 query 都可能重复。要你按照 query 的频度排序。
　　2). 1000 万字符串，其中有些是相同的 (重复), 需要把重复的全部去掉，保留没有重复的字符串。请问怎么设计和实现？
　　3). 寻找热门查询：查询串的重复度比较高，虽然总数是 1 千万，但如果除去重复后，不超过 3 百万个，每个不超过 255 字节。</p><p>十、分布式处理 mapreduce</p><p>　　适用范围：数据量大，但是数据种类小可以放入内存</p><p>　　基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。</p><p>　　扩展：
　　问题实例：
　　1). The canonical example application of MapReduce is a process to count the appearances of
Each different word in a set of documents:
　　2). 海量数据分布在 100 台电脑中，想个办法高效统计出这批数据的 TOP 10。
　　3). 一共有 N 个机器，每个机器上有 N 个数。每个机器最多存 O (N)个数并对它们操作。如何找到 N^2 个数的中数 (median)？</p><p>经典问题分析
　　上千万 or 亿数据（有重复），统计其中出现次数最多的前 N 个数据, 分两种情况：可一次读入内存，不可一次读入。</p><p>　　可用思路：trie 树+堆，数据库索引，划分子集分别统计，hash，分布式计算，近似统计，外排序</p><p>　　所谓的是否能一次读入内存，实际上应该指去除重复后的数据量。如果去重后数据可以放入内存，我们可以为数据建立字典，比如通过 map，hashmap，trie，然后直接进行统计即可。当然在更新每条数据的出现次数的时候，我们可以利用一个堆来维护出现次数最多的前 N 个数据，当然这样导致维护次数增加，不如完全统计后在求前 N 大效率高。</p><p>　　如果数据无法放入内存。一方面我们可以考虑上面的字典方法能否被改进以适应这种情形，可以做的改变就是将字典存放到硬盘上，而不是内存，这可以参考数据库的存储方法。</p><p>　　当然还有更好的方法，就是可以采用分布式计算，基本上就是 map-reduce 过程，首先可以根据数据值或者把数据 hash (md 5)后的值，将数据按照范围划分到不同的机子，最好可以让数据划分后可以一次读入内存，这样不同的机子负责处理各种的数值范围，实际上就是 map。得到结果后，各个机子只需拿出各自的出现次数最多的前 N 个数据，然后汇总，选出所有的数据中出现次数最多的前 N 个数据，这实际上就是 reduce 过程。</p><p>　　实际上可能想直接将数据均分到不同的机子上进行处理，这样是无法得到正确的解的。因为一个数据可能被均分到不同的机子上，而另一个则可能完全聚集到一个机子上，同时还可能存在具有相同数目的数据。比如我们要找出现次数最多的前 100 个，我们将 1000 万的数据分布到 10 台机器上，找到每台出现次数最多的前 100 个，归并之后这样不能保证找到真正的第 100 个，因为比如出现次数最多的第 100 个可能有 1 万个，但是它被分到了 10 台机子，这样在每台上只有 1 千个，假设这些机子排名在 1000 个之前的那些都是单独分布在一台机子上的，比如有 1001 个，这样本来具有 1 万个的这个就会被淘汰，即使我们让每台机子选出出现次数最多的 1000 个再归并，仍然会出错，因为可能存在大量个数为 1001 个的发生聚集。因此不能将数据随便均分到不同机子上，而是要根据 hash 后的值将它们映射到不同的机子上处理，让不同的机器处理一个数值范围。</p><p>　 而外排序的方法会消耗大量的 IO，效率不会很高。而上面的分布式方法，也可以用于单机版本，也就是将总的数据根据值的范围，划分成多个不同的子文件，然后逐个处理。处理完毕之后再对这些单词的及其出现频率进行一个归并。实际上就可以利用一个外排序的归并过程。</p><p>　 另外还可以考虑近似计算，也就是我们可以通过结合自然语言属性，只将那些真正实际中出现最多的那些词作为一个字典，使得这个规模可以放入内存。 </p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ data-ctx=海量数据面试题 data-src=/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F class=internal-link>设计与设计模式</a></li><li><a href=/%E9%9D%A2%E8%AF%95%E9%A2%98/ data-ctx=海量数据面试题 data-src=/%E9%9D%A2%E8%AF%95%E9%A2%98 class=internal-link>面试题</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://jieye-ericx.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Jieye ericx using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://jieye-ericx.github.io/>Home</a></li><li><a href=https://github.com/jieye-ericx>Github</a></li></ul></footer></div></div></body></html>