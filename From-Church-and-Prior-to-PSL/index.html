<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="1 1-4
2 4-11
3，4，5 11-16
3 Dynamic and Branching-Time Logics 3.1 Dynamic Logics 1976年，在Pnueli提议使用LTL来验证复杂计算机系统的前一年，沃恩·罗纳德普拉特（Vaughan Ronald Pratt）建议使用动态逻辑（dynamic logic）来描述指定程序，dynamic logic是模态逻辑（modal logic）的一种延伸[96]。"><meta property="og:title" content><meta property="og:description" content="1 1-4
2 4-11
3，4，5 11-16
3 Dynamic and Branching-Time Logics 3.1 Dynamic Logics 1976年，在Pnueli提议使用LTL来验证复杂计算机系统的前一年，沃恩·罗纳德普拉特（Vaughan Ronald Pratt）建议使用动态逻辑（dynamic logic）来描述指定程序，dynamic logic是模态逻辑（modal logic）的一种延伸[96]。"><meta property="og:type" content="website"><meta property="og:image" content="https://jieye-ericx.github.io/icon.png"><meta property="og:url" content="https://jieye-ericx.github.io/From-Church-and-Prior-to-PSL/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="1 1-4
2 4-11
3，4，5 11-16
3 Dynamic and Branching-Time Logics 3.1 Dynamic Logics 1976年，在Pnueli提议使用LTL来验证复杂计算机系统的前一年，沃恩·罗纳德普拉特（Vaughan Ronald Pratt）建议使用动态逻辑（dynamic logic）来描述指定程序，dynamic logic是模态逻辑（modal logic）的一种延伸[96]。"><meta name=twitter:image content="https://jieye-ericx.github.io/icon.png"><title>ericx 's 数字花园</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://jieye-ericx.github.io//icon.png><link href=https://jieye-ericx.github.io/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://jieye-ericx.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://jieye-ericx.github.io/js/darkmode.48459b7116d092b4e98d2cab704cad80.min.js></script>
<script src=https://jieye-ericx.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://jieye-ericx.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://jieye-ericx.github.io/",fetchData=Promise.all([fetch("https://jieye-ericx.github.io/indices/linkIndex.498f8802e86f71aa2af4d45d6c4096d6.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://jieye-ericx.github.io/indices/contentIndex.5368a39ad15318a851f2d088b43f3a36.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://jieye-ericx.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://jieye-ericx.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/jieye-ericx.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=jieye-ericx.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://jieye-ericx.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://jieye-ericx.github.io/>ericx 's 数字花园</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown
<a href=https://github.com/jackyzha0/quartz/tree/hugo/content/From%20Church%20and%20Prior%20to%20PSL.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#3-dynamic-and-branching-time-logics><strong>3 Dynamic and Branching-Time Logics</strong></a><ol><li><a href=#31-dynamic-logics><strong>3.1 Dynamic Logics</strong></a></li><li><a href=#32-branching-time-logics><strong>3.2 Branching-Time Logics</strong></a></li><li><a href=#33-combining-dynamic-and-temporal-logics><strong>3.3 Combining Dynamic and Temporal Logics</strong></a></li></ol></li><li><a href=#4-thread-iv-from-ltl-to-forspec-and-psl><strong>4 Thread IV: From LTL to ForSpec and PSL</strong></a><ol><li><a href=#41-from-ltl-to-forspec><strong>4.1 From LTL to ForSpec</strong></a></li><li><a href=#42-from-forspec-to-psl><strong>4.2 From ForSpec to PSL</strong></a></li></ol></li><li><a href=#5-contemplation><strong>5 Contemplation</strong></a></li></ol></nav></details></aside><p>1 1-4</p><p>2 4-11</p><p>3，4，5 11-16</p><a href=#3-dynamic-and-branching-time-logics><h2 id=3-dynamic-and-branching-time-logics><span class=hanchor arialabel=Anchor># </span><strong>3 Dynamic and Branching-Time Logics</strong></h2></a><a href=#31-dynamic-logics><h3 id=31-dynamic-logics><span class=hanchor arialabel=Anchor># </span><strong>3.1 Dynamic Logics</strong></h3></a><p>1976年，在Pnueli提议使用LTL来验证复杂计算机系统的前一年，沃恩·罗纳德普拉特（Vaughan Ronald Pratt）建议使用动态逻辑（dynamic logic）来描述指定程序，dynamic logic是模态逻辑（modal logic）的一种延伸[96]。</p><blockquote><p>在模态逻辑中 $\Box \varphi$意味着 $\varphi$在所有于当前world有关的worlds中成立 。因此，可以将$\Box \varphi$表示$\varphi$在程序执行后成立，Pratt在动态逻辑中加入了$[e]\varphi$，$e$ 是一个程序，$\varphi $在$e$开始执行后的所有状态中成立。</p><p>因为$\psi \rightarrow[e]\varphi$对应于 Hoare 三元祖 ${\psi}e{\varphi}$，因此动态逻辑可以被看作是Hoare逻辑的延伸。</p></blockquote><p>在模态逻辑中 $\Box \varphi$意味着 $\varphi$在所有于当前world有关的worlds中成立 。因此，可以将$\Box \varphi$表示$\varphi$在程序执行后成立，程序的转移关系为Kripke结构的概率关系。Pratt在动态模式( dynamic modalities )中加入了$[e]\varphi$，$e$ 是一个程序，$\varphi $在$e$开始执行后的所有状态中成立。然后，动态逻辑可以被看作是Hoare逻辑的延伸，因为$\psi \rightarrow[e]\varphi$对应于 Hoare 三元祖 ${\psi}e{\varphi}$（见 [3]） 。请参阅 [64]动态逻辑的更多介绍。</p><p><img src=https://jieye-ericx.github.io//../../pics/image-20211115085527955.png width=auto alt=image-20211115085527955></p><p>In 1977, a propositional version of Pratt’s dynamic logic, called PDL, was proposed,in which programs are regular expressions over atomic programs [52, 53]. It was shownthere that the SATISFIABILITY problem for PDL is in NEXPTIME and EXPTIME-hard.Pratt then proved an EXPTIME upper bound, adapting tableau techniques from modallogic [97, 98]. (We saw earlier that Wolper then adapted these techniques to linear-time logic.)</p><p>1977年，提出了Pratt动态逻辑的命题版本，称为PDL，其中程序是原子程序上的正则表达式[52,53]。结果表明，PDL的可满足性问题在NEXPTIME和EXPTIME困难。Pratt随后采用了模态逻辑中的tableau技术[97,98]证明了一个EXPTIME上限。（我们在前面看到，Wolper随后将这些技术应用于线性时间逻辑。）</p><p><img src=https://jieye-ericx.github.io//../../pics/image-20211115133036425.png width=auto alt=image-20211115133036425></p><blockquote><ul><li>P:多项式时间</li><li>BPP：有界误差概率多项式时间，可以通过包含随机因素的算法快速解决的问题</li><li>BQP：有界误差量子多项式时间，所有能用量子计算机快速解决的问题（如确定整数的素因子）</li><li>NP：不确定多项式时间</li><li>PH：多项式层级，PH是NP问题的一种扩展，如果一个问题开始是NP，但是随后会增加额外的复杂性，那么该问题就属于PH。</li><li>PSPACE：多项式空间，PSPACE包含了所有可以通过合理内存来解决的问题</li><li>EXPTIME：指数时间，所有能用经典计算机在指数级时间内解决的问题</li></ul></blockquote><p>Pratt’s dynamic logic was designed for terminating programs, while Pnueli was interested in nonterminating programs. This motivated various extensions of dynamic logic to nonterminating programs [67, 115, 114, 116]. Nevertheless, these logics are much less natural for the specifification of ongoing behavior than emporal logic. They inspired, however, the introduction of the (<em>modal</em>) µ-<em>calculus</em> by Dexter Kozen [72,73]. The µ-calculus is an extension of modal logic with least and greatest fifixpoints. It subsumes expressively essentially all dynamic and temporal logics [11]. Kozen’s paper was inspired by previous papers that showed the usefulness of fixpoints in characterizing correctness properties of programs [45, 92] (see also [99]). In turn, the µ-calculus inspired the introduction of µLTL, mentioned earlier. The µ-calculus also played an important role in the development of symbolic model checking [19, 20, 49].</p><p>Pratt的动态逻辑设计用于终止程序，而Pnueli则对非终止程序感兴趣。这激发了动态逻辑对非终止程序的各种扩展[67115114116]。然而与时态逻辑相比，这些逻辑对于正在进行的行为的规范来说要不自然得多。然而，他们启发了Dexter Kozen引入（模态）$\mu$-微积分[72,73]。$\mu$-微积分是模态逻辑具有最小和最大不动点的一个扩展。它包含了所有动态和时态逻辑[11]。Kozen的论文的灵感来源于以前的论文，这些论文展示了不动点在描述程序正确性属性方面的用处[45,92]（另见[99]）。反过来，$\mu$-微积分激发了前面提到的$\mu LTL$的引入。$\mu$-微积分在符号化模型检查的发展中也发挥了重要作用[19,20,49]。</p><p>TODO：做一个启发关系图</p><ol><li>讲了啥？基本思想，解决了什么问题，用了什么方法。</li><li>用了它的方法需要哪些假设</li><li>实验效果如何，评判指标是哪些，哪些维度，是否可以增加</li><li>如何证明他的理论是正确的</li></ol><a href=#32-branching-time-logics><h3 id=32-branching-time-logics><span class=hanchor arialabel=Anchor># </span><strong>3.2 Branching-Time Logics</strong></h3></a><p><strong>与Pnueli的线性时态方法相比，动态逻辑为推理程序提供了一种时间分支（ branching-time）方法</strong>。Lamport是第一个在程序正确性的背景下研究线性时间和分支时间之间的二分法的人[81]。随后引入了分支时间逻辑UB，它用存在和全称量词E和A扩展了一元LTL（LTL without until）。存在和全称量词使我们能够量化系统未来的不同行为。通过将Pratt在PDL中使用的tableau-based方法应用于UB，证明其可满足性问题是在指数时间内的[9]。 Clarke和Emerson随后在UB中添加了时间连接词“until”，并获得了CTL[28]。（他们没有关注CTL的可满足性问题，但是，正如我们前面看到的，它的模型检查问题；可满足性问题后来在EXPTIME中被证明是可解的[47]）最后可以发现LTL和CTL具有无与伦比的表达能力，从而引入了分支时间逻辑CTL∗，它统一了LTL和CTL[46,48]。</p><p>20世纪80年代分支时间逻辑的关键特征是[9]中引入了显式路径量词。这是Prior及其追随者在20世纪60年代和70年代没有发现的想法。最有可能的是，Prior会发现CTL∗他对自己的哲学应用感到满意，认为没有必要引入“奥克罕姆派（Ockhamist）”和“皮尔士派（Peircean）”的方法。</p><a href=#33-combining-dynamic-and-temporal-logics><h3 id=33-combining-dynamic-and-temporal-logics><span class=hanchor arialabel=Anchor># </span><strong>3.3 Combining Dynamic and Temporal Logics</strong></h3></a><p>到20世纪80年代初，时态逻辑和动态逻辑为具体说明程序提供了两种截然不同的视角：第一种是基于状态的，第二种是基于动作的。为了将这两种方法结合起来，业内已经做了很多努力。</p><p>其中包括引入<em>Process Logic</em>[63]（分支时间）、<em>Process Logic</em>[128]（分支时间）、<em>Regular Process Logic</em>[66]（线性时间）、<em>Dynamic LTL</em>[59]（线性时间）和<em>RCTL</em>[8]（分支时间），最终演变为<em>Sugar</em>[7]。RCTL/Sugar在这些逻辑中是独一无二的，因为它没有尝试借用动态逻辑中基于动作的部分。它是一种基于状态的分支时间逻辑，没有动作的概念。相反，它从动态逻辑中借用的是基于正则表达式的动态模式的使用。与动态逻辑（在程序语句上使用正则表达式）不同，RCTL/Sugar在状态谓词上使用正则表达式，类似于ETL[130134]的自动机，它运行在一系列公式上。</p><p>These include the introduction of <em>Process Logic</em> [63] (branching time), <em>Yet Another Process Logic</em> [128] (branching time), <em>Regular Process Logic</em> [66] (linear time), <em>Dynamic LTL</em> [59] (linear time), and <em>RCTL</em> [8] (branching time), which ultimately evolved into <em>Sugar</em> [7]. RCTL/Sugar is unique among these logics in that it did not attempt to borrow the action-based part of dynamic logic. It is a state-based branching-time logic with no notion of actions. Rather, what it borrowed from dynamic logic was the use of regular-expression-based dynamic modalities. Unlike dynamic logic, which uses regular expressions over program statements, RCTL/Sugar uses regular expressions over state predicates, analogously to the automata of ETL [130, 134], which run over sequences of formulas.</p><a href=#4-thread-iv-from-ltl-to-forspec-and-psl><h2 id=4-thread-iv-from-ltl-to-forspec-and-psl><span class=hanchor arialabel=Anchor># </span><strong>4 Thread IV: From LTL to ForSpec and PSL</strong></h2></a><p>在20世纪90年代末和21世纪初，模型检查对工业的影响越来越大。这导致了基于LTL的两种工业时序逻辑的开发：<strong>由Intel开发的ForSpec</strong>和<strong>由工业标准委员会开发的PSL</strong>。</p><a href=#41-from-ltl-to-forspec><h3 id=41-from-ltl-to-forspec><span class=hanchor arialabel=Anchor># </span><strong>4.1 From LTL to ForSpec</strong></h3></a><p>Intel’s involvement with model checking started in 1990, when Kurshan, spending asabbatical year in Israel, conducted a successful feasibility study at the Intel Design Center (IDC) in Haifa, using COSPAN, which at that point was a prototype tool; see[80]. In 1992, IDC started a pilot project using SMV. By 1995, model checking was used by several design projects at Intel, using an internally developed model checker based on SMV. Intel users have found CTL to be lacking in expressive power and the Design Technology group at Intel developed its own specifification anguage, FSL. The FSL language was a linear-time logic, and it was model checked using the automata-theoretic approach, but its design was rather ad-hoc, and its expressive power was unclear; see[54].</p><p>英特尔参与模型检查始于1990年，当时Kurshan在以色列休假一年，在海法的英特尔设计中心（IDC）利用当时作为原型工具的COSPAN进行了成功的可行性研究；见[80]。1992年，IDC启动了一个使用SMV进行模型检测的试点项目。到1995年，Intel的几个设计项目使用了模型检查，使用了内部开发的基于SMV的模型检查程序。英特尔用户发现CTL缺乏表达能力，英特尔的设计技术小组开发了自己的规范语言FSL。FSL语言是一种线性时间逻辑，使用自动机理论方法对其进行模型检查，但其设计相当随意，表达能力不明确；见[54]。</p><p>1997年，IDC的英特尔设计技术小组开始开发第二代模型检查技术。目标是开发一个模型，从头开始检查引擎，以及一种新的规范语言。1999年发布了基于BDD的模型检查器[55]，2000年发布了基于SAT的模型检查器.</p><p>1997年，我参与了第二代规范语言的设计。该语言ForSpec于2000年发布[5]。要决定的第一个问题是语言应该是线性的还是分支的。这导致了对这个问题的深入研究[126]，决定采用线性时间语言。一个明显的候选者是LTL；我们看到，到20世纪90年代中期，LTL既有明确的状态检查，也有符号模型检查，因此可行性没有问题。在这个问题上，我与Limor Fix, Michael Hadash, Yonit Kesten, and Moshe Sananes进行了多次对话。得出的结论是，LTL对工业应用来说表达程度不够。特别是，许多在FSL中可表达的属性在LTL中不可表达。因此，事实证明，关于LTL表达性的理论考虑(即缺乏ω-正则性)具有实际意义。</p><p>I offered two extensions of LTL; as we saw earlier both ETL and µLTL achieve ω-regularity and have the samecomplexity as LTL. Neither of these proposals was accepted, due to the perceived difficulty of usage of such logics by Intel validation engineers, who typically have only basic familiarity with automata theory and logic.</p><p>我提供了LTL的两个扩展；正如我们之前看到的，ETL和μLTL都实现了ω-正则性，并与LTL具有相同的复杂性。这两项建议<strong>都没有被接受</strong>，因为英特尔验证工程师认为使用此类逻辑很困难，他们通常只基本熟悉自动机理论和逻辑。</p><p>这些对话在1998年继续进行，现在是与Avner Landver的对话。Avner还认为Intel验证工程师不会接受基于自动机的ETL形式主义。由于熟悉RCTL/Sugar及其动态模式[7,8]，他向我询问了正则表达式，我的回答是正则表达式与自动机等价[69]，因此$ETL_f$的自动机可以用状态谓词上的正则表达式代替，它通过有限字上的自动机扩展LTL。这导致了RELTL的发展，它是由动态逻辑的动态规则模式（如ETL中的线性解释）补充的LTL。与dynamic logic中使用$[e]\varphi$符号不同，ForSpec使用可读性更强的（工程师）（$e\\ triggers \\ \varphi$），其中e是状态谓词上的正则表达式(例如$(p\lor q)^*,(p\wedge q)$),$\varphi$是公式。从语义上说，对所有的$j\geqslant i$,如果$\tau[i,j]\\ 满足\\ e$,则$\tau,j\\ |=\varphi$,,$ \tau,i |= (e\\ triggers\\ \varphi)$</p><p>使用ETLf的ω-正则性，现在很容易证明RELTL也达到ω-正则性[5]。</p><p>虽然在LTL中添加动态模式足以实现ω-正则性，但我们决定还直接支持Intel版本工程师经常使用的两种规范模式：时钟和重置。时钟和复位都是解决现代半导体设计由相互作用的并行模块组成这一事实所需的功能。虽然时钟和重置有一个简单的基本直觉，但正式定义它们的语义是非常重要的。ForSpec本质上是RELTL，增加了与时钟和重置相对应的功能，正如我们现在所解释的。</p><p>今天的半导体设计仍以同步电路为主。在同步电路中，时钟信号使时序逻辑同步，为设计者提供了一个简单的操作模型。虽然异步方法具有更高的速度（见[23]），但设计异步电路比设计同步电路要困难得多。当前的设计方法试图通过使用多个时钟在这两种方法之间达成共识。这导致了全局异步但局部同步的体系结构。时态逻辑语法大多忽略了显式支持时钟的问题。ForSpec通过<em>current clock</em>的概念支持多个时钟。具体地说，ForSpec在$c\varphi$上有一个构造变化，该变化表示时态公式$\varphi $将通过对时钟c来评估；也就是说，时态公式$\varphi $被时钟c的高相位定义的轨迹所评估。ForSpec中时钟的关键特征是，每个子公式可能根据不同的时钟前进.</p><p>由交互并行模块组成的现代设计的另一个特点是，在一个模块上运行的进程可以通过来自另一个模块的信号重置。如[117]所述，复位控制长期以来一直是嵌入式控制设计的一个关键方面。ForSpec直接支持复位信号。公式$accept_on \\ a\varphi$说明仅在重置信号a到达之后，才应检查属性$\varphi$，此时检查被视为已成功。相反，$reject_on \\ r\varphi$说明仅在重置信号r到达之后，才应检查属性$\varphi$，此时检查被视为已失败。ForSpec中重置的关键特征是，每个子公式可通过不同的重置信号重置（正或负）；有关详细讨论，请参见[5]。</p><p>ForSpec是一种工业属性规范语言，支持面向硬件的构造以及形式化和动态验证的统一语义，同时具有易于理解的表达性（ω-正则性）和计算复杂性（ForSpec和LTL的可满足性和模型检查问题具有相同的复杂性）[5]设计努力在冲突的需求（如表达性、可用性和可实现性）之间找到一个可接受的折衷方案，并通过理论阐明折衷方案。时钟和重置对硬件设计师来说都很重要，它们都具有清晰的直观语义，但将这种语义形式化并不重要。然而，严格的语义不仅能够对该语言的各种定理进行机械验证，还可以作为实现者的参考文档。ForSpec模型检查的实现遵循自动机理论方法，使用[12]中提倡的交替自动机.</p><a href=#42-from-forspec-to-psl><h3 id=42-from-forspec-to-psl><span class=hanchor arialabel=Anchor># </span><strong>4.2 From ForSpec to PSL</strong></h3></a><p>In 2000, the Electronic Design Automation Association instituted a standardization body called
<a href=http://www.accellera.org/. rel=noopener>Accellera</a>.Accellera’s mission is to drive worldwide development and use of standards required by systems, semiconductor and design tools companies. Accellera decided that the development of a standard specification language is a requirement for formal verification to become an industrial reality (see [80]). Since the focus was on specifying properties of designs rather than designs themselves, the chosen term was <strong>“property specification language” (PSL)</strong>. The PSL standard committee solicited industrial contributions and received four language contributions: CBV, from Motorola,ForSpec, from Intel, Temporal e, from Verisity [89], and Sugar, from IBM.</p><p>2000年，电子设计自动化协会成立了一个名为Accellera的标准化机构。Accelera的使命是推动系统、半导体和设计工具公司所需标准的全球开发和使用。Accellera认为，标准规范语言的开发是形式化验证成为工业现实的必要条件（见[80]）。由于重点是指定设计的属性，而不是设计本身，因此选择的术语是“属性规范语言”（PSL）。PSL标准委员会征求了业界的意见，并收到了四份语言意见：来自摩托罗拉的CBV、来自英特尔的ForSpec、来自Verisity的Temporal e[89]和来自IBM的Sugar。</p><p>委员会的讨论相当激烈。16最终，很明显，虽然技术因素起着重要作用，但行业委员会的决定最终是出于商业考虑。在这场争论中，IBM占据了上风，Accellera在2003年选择Sugar作为PSL的基础语言。同时，ForSpec的技术优点被接受，PSL采用了ForSpec的所有主要特性。本质上，PSL（当前版本1.1）是LTL，通过动态模式（称为常规层）、时钟和重置（称为中止）进行扩展。PSL确实继承了Sugar的语法，并且包含了一个分支时间扩展作为对Sugar的确认。??</p><p>PSL在ForSpec方面有一些演变。在对重置定义的正确方式进行了一些辩论[4]之后，ForSpec的方法在经过一些重新制定后基本上被接受[41]。ForSpec关于时钟的基本方法，即语义，被接受，但在一些重要细节上进行了修改[42]。</p><p>In addition to the dynamic modalities, borrowed from dynamic logic, PSL also has weak dynamic modalities,which are reminiscent of “looping” modalities in dynamic logic [67, 65]. Today PSL 1.1 is an IEEE Standard 1850–2005, and continues to be refined by the IEEE P1850 PSL Working Group.</p><p>除了从动态逻辑借用的动态模式外，PSL还具有弱动态模式，这让人想起动态逻辑中的“循环”模式[67,65]。如今PSL 1.1是IEEE标准1850–2005，并由IEEE P1850 PSL工作组继续完善。</p><p>ForSpec和PSL的实际应用表明，常规层（即动态模式）深受验证工程师的欢迎。另一种标准化的属性规范语言，称为SVA（用于SystemVerilog断言），本质上是基于该常规层的</p><a href=#5-contemplation><h2 id=5-contemplation><span class=hanchor arialabel=Anchor># </span><strong>5 Contemplation</strong></h2></a><p>The evolution of ideas, from Church and Prior to PSL, seems to be an amazing development. It reminds me of the medieval period, when building a cathedral spanned more than a mason’s lifetime. Many masons spend their whole lives working on a cathedral, never seeing it to completion. We are fortunate to see the completion of this particular “cathedral”. Just like the medieval masons, our contributions are often smaller than we’d like to consider them, but even small contributions can have a major impact. Unlike the medieval cathedrals, the scientifific cathedral has no architect; the construction is driven by a complex process, whose outcome is unpredictable. Much that has been discovered is forgotten and has to be rediscovered. It is hard to fathom what our particular “cathedral” will look like in 50 years.</p><p>从教会到PSL之前，思想的演变似乎是一个惊人的发展。这让我想起了中世纪时期，当时修建一座大教堂的时间超过了一个石匠的一生。许多泥瓦匠一生都在为一座大教堂工作，从未看到它完工。我们很幸运地看到这座特别的“大教堂”竣工。就像中世纪的石匠一样，我们的贡献往往比我们想的要小，但即使是微小的贡献也会产生重大影响。与中世纪大教堂一样，科学化大教堂没有建筑师；施工由一个复杂的过程驱动，其结果是不可预测的。许多被发现的东西被遗忘了，必须重新发现。很难想象50年后我们的“大教堂”会是什么样子。</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://jieye-ericx.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Jieye ericx using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://jieye-ericx.github.io/>Home</a></li><li><a href=https://github.com/jieye-ericx>Github</a></li></ul></footer></div></div></body></html>