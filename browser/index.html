<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="JS 的单线程 很多人都知道的是，JavaScript 是一门动态的解释型的语言，具有跨平台性。在被问到 JavaScript 为什么是一门单线程的语言，有的人可能会这么回答：“语言特性决定了 JavaScript 是一个单线程语言，JavaScript 天生是一个单线程语言”，这只不过是一层糖衣罢了。
JavaScript 从诞生起就是单线程，原因大概是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。
准确的来说，我认为 JavaScript 的单线程是指 JavaScript 引擎是单线程的，JavaScript 的引擎并不是独立运行的，跨平台意味着 JavaScript 依赖其运行的宿主环境 &mdash; 浏览器(大部分情况下是浏览器)。"><meta property="og:title" content="browser"><meta property="og:description" content="JS 的单线程 很多人都知道的是，JavaScript 是一门动态的解释型的语言，具有跨平台性。在被问到 JavaScript 为什么是一门单线程的语言，有的人可能会这么回答：“语言特性决定了 JavaScript 是一个单线程语言，JavaScript 天生是一个单线程语言”，这只不过是一层糖衣罢了。
JavaScript 从诞生起就是单线程，原因大概是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。
准确的来说，我认为 JavaScript 的单线程是指 JavaScript 引擎是单线程的，JavaScript 的引擎并不是独立运行的，跨平台意味着 JavaScript 依赖其运行的宿主环境 &mdash; 浏览器(大部分情况下是浏览器)。"><meta property="og:type" content="website"><meta property="og:image" content="https://jieye-ericx.github.io/icon.png"><meta property="og:url" content="https://jieye-ericx.github.io/browser/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="browser"><meta name=twitter:description content="JS 的单线程 很多人都知道的是，JavaScript 是一门动态的解释型的语言，具有跨平台性。在被问到 JavaScript 为什么是一门单线程的语言，有的人可能会这么回答：“语言特性决定了 JavaScript 是一个单线程语言，JavaScript 天生是一个单线程语言”，这只不过是一层糖衣罢了。
JavaScript 从诞生起就是单线程，原因大概是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。
准确的来说，我认为 JavaScript 的单线程是指 JavaScript 引擎是单线程的，JavaScript 的引擎并不是独立运行的，跨平台意味着 JavaScript 依赖其运行的宿主环境 &mdash; 浏览器(大部分情况下是浏览器)。"><meta name=twitter:image content="https://jieye-ericx.github.io/icon.png"><title>browser</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://jieye-ericx.github.io//icon.png><link href=https://jieye-ericx.github.io/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://jieye-ericx.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://jieye-ericx.github.io/js/darkmode.48459b7116d092b4e98d2cab704cad80.min.js></script>
<script src=https://jieye-ericx.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://jieye-ericx.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://jieye-ericx.github.io/",fetchData=Promise.all([fetch("https://jieye-ericx.github.io/indices/linkIndex.6af51e32574165fdcdb741687d051d11.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://jieye-ericx.github.io/indices/contentIndex.55dc1d780f6c0d7da82628806b7a0078.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://jieye-ericx.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://jieye-ericx.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/jieye-ericx.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=jieye-ericx.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://jieye-ericx.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://jieye-ericx.github.io/>jieye の 数字花园</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>browser</h1><p class=meta>Last updated
Aug 19, 2022</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><ol><li><a href=#js-的单线程>JS 的单线程</a></li><li><a href=#浏览器的多线程>浏览器的多线程</a></li><li><a href=#浏览器主线程常驻线程>浏览器主线程常驻线程</a></li><li><a href=#chrome-多进程架构的好处>Chrome 多进程架构的好处</a></li><li><a href=#chrome-服务化-节省更多的内存>Chrome 服务化 —节省更多的内存</a></li><li><a href=#chrome站点隔离site-isolation>Chrome站点隔离（Site Isolation）</a></li><li><a href=#输入url后发生了什么>输入URL后发生了什么</a></li><li><a href=#浏览器端的-event-loop>浏览器端的 Event Loop</a></li><li><a href=#node-中的-event-loop>Node 中的 Event Loop</a></li><li><a href=#node-与浏览器的-event-loop-差异>Node 与浏览器的 Event Loop 差异</a></li><li><a href=#settimeout-和-setimmediate>setTimeout 和 setImmediate</a></li><li><a href=#node-11x-的变化>Node 11.x 的变化</a></li><li><a href=#小结>小结</a></li></ol></li><li><a href=#浏览器存储>浏览器存储</a><ol><li><a href=#cookies>cookies</a></li><li><a href=#local-storage>local storage</a></li><li><a href=#session-storage>session storage</a></li><li><a href=#indexeddb>indexedDB</a></li><li><a href=#service-worker产生的意义>Service Worker产生的意义</a></li><li><a href=#pwa与service-worker>PWA与Service Worker</a></li></ol></li></ol></nav></details></aside><a href=#js-的单线程><h3 id=js-的单线程><span class=hanchor arialabel=Anchor># </span>JS 的单线程</h3></a><p>很多人都知道的是，JavaScript 是一门<strong>动态的解释型的语言</strong>，具有<strong>跨平台性</strong>。在被问到 JavaScript 为什么是一门单线程的语言，有的人可能会这么回答：“语言特性决定了 JavaScript 是一个单线程语言，JavaScript 天生是一个单线程语言”，这只不过是一层糖衣罢了。</p><p>JavaScript 从诞生起就是单线程，原因大概是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。</p><p>准确的来说，我认为 JavaScript 的单线程是指 <strong>JavaScript 引擎是单线程</strong>的，JavaScript 的引擎并不是独立运行的，跨平台意味着 JavaScript 依赖其运行的宿主环境 &mdash; 浏览器(大部分情况下是浏览器)。</p><p>浏览器需要渲染 DOM，JavaScript 可以修改 DOM 结构，JavaScript 执行时，浏览器 DOM 渲染停止。如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都操作 DOM，那么就会出现 DOM 冲突。</p><p>举个例子来说，在同一时刻执行两个 script 对同一个 DOM 元素进行操作，一个修改 DOM，一个删除 DOM，那这样话浏览器就会懵逼了，它就不知道到底该听谁的，会有资源竞争，这也是 JavaScript 单线程的原因之一。</p><a href=#浏览器的多线程><h3 id=浏览器的多线程><span class=hanchor arialabel=Anchor># </span>浏览器的多线程</h3></a><p>之前说过，JavaScript 运行的宿主环境浏览器是多线程的。</p><p>以 Chrome 来说，我们可以通过 Chrome 的任务管理器来看看。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172110.png width=auto alt=img></p><p>当你打开一个 Tab 页面的时候，就创建了一个进程。如果从一个页面打开了另一个页面，打开的页面和当前的页面属于同一站点的话，那么这个页面会复用父页面的渲染进程。</p><a href=#浏览器主线程常驻线程><h3 id=浏览器主线程常驻线程><span class=hanchor arialabel=Anchor># </span>浏览器主线程常驻线程</h3></a><ol><li><p>GUI 渲染线程</p><ul><li>绘制页面，解析 HTML、CSS，构建 DOM 树，布局和绘制等</li><li>页面重绘和回流</li><li>与 JS 引擎线程互斥，也就是所谓的 JS 执行阻塞页面更新</li></ul></li><li><p>JS 引擎线程</p><ul><li>负责 JS 脚本代码的执行</li><li>负责准执行准备好待执行的事件，即定时器计数结束，或异步请求成功并正确返回的事件</li><li>与 GUI 渲染线程互斥，执行时间过长将阻塞页面的渲染</li></ul></li><li><p>事件触发线程</p><ul><li>负责将准备好的事件交给 JS 引擎线程执行</li><li>多个事件加入任务队列的时候需要排队等待(JS 的单线程)</li></ul></li><li><p>定时器触发线程</p><ul><li>负责执行异步的定时器类的事件，如 setTimeout、setInterval</li><li>定时器到时间之后把注册的回调加到任务队列的队尾</li></ul></li><li><p>HTTP 请求线程</p><ul><li>负责执行异步请求</li><li>主线程执行代码遇到异步请求的时候会把函数交给该线程处理，当监听到状态变更事件，如果有回调函数，该线程会把回调函数加入到任务队列的队尾等待执行</li></ul></li></ol><a href=#chrome-多进程架构的好处><h3 id=chrome-多进程架构的好处><span class=hanchor arialabel=Anchor># </span>Chrome 多进程架构的好处</h3></a><p>之前有提到，Chrome 用的是多进程的渲染方式，最容易想到的场景就是每个窗口（Tab）都有一个独立的渲染进程。假设你打开了三个浏览器窗口，当其中一个窗口因为某种原因崩掉的时候，你大可以直接关闭这个不再响应的窗口并继续你在其他窗口的工作。我们换一个浏览器，所有的窗口都共享同一个进程，当一个窗口挂掉的时候，所有的窗口都直接挂掉了（像不像理财的时候人们总是说：“不要把所有的钱放在同一个钱包里”？）。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172111.png width=auto alt=img></p><p>将浏览器的工作拆分成不同的进程还有一个好处，就是安全。由于操作系统提供了一种限制进程“权限”的方法，因此浏览器可以将特定的功能和进程有效的隔离开。比如，Chrome 会限制用来处理用户输入的渲染进程去直接访问文件。</p><p>每个进程都有各自的内存空间，因此它们常会各自拥有一份基础功能的拷贝。正因为它们之间不像同一进程中的线程那样能够共享资源，所以就需要更多的内存占用。为了节省内存，Chrome 对其自身可调用的进程在数量上做了限制。具体的限制大小在不同性能的机器上各不相同，唯一确定的是，当达到了这个上限后，Chrome 会将同站点的多个窗口交给同一个进程来管理。</p><a href=#chrome-服务化-节省更多的内存><h3 id=chrome-服务化-节省更多的内存><span class=hanchor arialabel=Anchor># </span>Chrome 服务化 —节省更多的内存</h3></a><p>浏览器进程也应用了相同的方案。Chrome 正在进行架构层面的整改，目的是将浏览器的各部分功能变成独立的服务，这样就能轻松的将其拆分为不同的进程，也能更加灵活的互相组合。</p><p>总的来说，当 Chrome 在较高性能的设备上运行时，它会将每个服务分配至不同的进程，以此来获得更强的运行时稳定性和健壮性；反之，如果 Chrome 运行在一台资源受限的设备上时，Chrome 会将服务整合在一个进程中，以此来节省内存的占用。像这种通过整合进程资源以此来节省内存的手段，已经被用于 Android 上了。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172112.png width=auto alt=img></p><a href=#chrome站点隔离site-isolation><h3 id=chrome站点隔离site-isolation><span class=hanchor arialabel=Anchor># </span>Chrome站点隔离（Site Isolation）</h3></a><p>站点隔离是 Chrome 在其 67 桌面版上新增的特性，基本原则是不同的站点各自运行在自己的沙箱环境中，独享进程，并且不允许通信。我们已经讨论过每个窗口一个进程的模型，在这个模型中，浏览器允许跨站点的 iframe 独立进程共享不同站点之间的内存空间。早先在一个渲染进程中（窗口）同时运行 a.com 和 b.com 看起来没有什么问题，因为有同源策略，确保一个站点未经同意就无法访问其他站点的数据。绕过同源策略基本上成为了所有安全攻击的指导方针。而进程间的相互隔离是将站点分开的最佳途径（感兴趣的同学可以去了解一下 Meltdown 和 Spectre 攻击）。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172113.png width=auto alt=img></p><p>经过多年的工程上的努力，如今的站点隔离已经默认为用户开启了。事实上，站点隔离并不仅仅是为站点分配不同的渲染进程这么简单，它从根本上改变了 iframe 之间的通信方式。打开运行有不同站点 iframe 的开发者工具，意味着浏览器必须做很多看不到的幕后工作，才能让这一切看起来和以前没有什么区别，即使是简简单单的 ctrl+F 在这个场景下也意味着在不同的渲染进程中查询字符串。网上有很多文章介绍浏览器的站点隔离策略，当你看完那些之后就会意识到，为什么站点隔离值得 Chrome 团队为其发布一个独立版本了。</p><a href=#输入url后发生了什么><h3 id=输入url后发生了什么><span class=hanchor arialabel=Anchor># </span>输入URL后发生了什么</h3></a><p>输入一个 url，浏览器会从服务端获取数据并将页面展示出来。本文会聚焦在用户通过浏览器向一个站点发起访问请求以及浏览器准备渲染这个页面的部分，这个过程我称之为导航。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172114.png width=auto alt=img></p><p>我们在上一篇文章中提过，所有处于窗口之外的部分都由同一个浏览器进程进行掌管。浏览器的进程又同时拥有许多线程，掌管浏览器的不同部分：UI 线程用来绘制顶部的操作按钮和输入框、网络线程负责处理并接收来自互联网的数据、存储线程控制着访问本地文件的权限等。当你将一个网站的 url 输入到浏览器的地址栏时，此刻正是浏览器进程中的 UI 线程在起作用。</p><a href=#step-1处理用户输入><h5 id=step-1处理用户输入><span class=hanchor arialabel=Anchor># </span>Step 1：处理用户输入</h5></a><p>当用户开始在地址栏输入时，UI 线程首先会问：“大兄弟，你输入的是个查询字符串还是网站地址？”。因为 Chrome 的地址栏同时还是个搜索框，所以 UI 线程需要解析用户的输入，才能决定该直接访问网址还是把用户的输入丢给搜索引擎处理。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172115.png width=auto alt=img></p><a href=#step-2开始导航><h5 id=step-2开始导航><span class=hanchor arialabel=Anchor># </span>Step 2：开始导航</h5></a><p>当用户按下回车键后，UI 线程要求网络线程去获取网站的内容。窗口的 Tab 上会开始转菊花，网络线程会采用一系列的协议和操作（比如 DNS）查询必要的信息并为请求建立连接。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172116.png width=auto alt=img></p><p>此时，网络线程可能会收到来自服务器的一个标记着重定向指令的头部比如 HTTP 301，在这种情况下，网络线程会把这件事情告诉 UI 线程，之后则会发起一次指向重定向地址的新的网络请求。</p><a href=#step-3读取响应><h5 id=step-3读取响应><span class=hanchor arialabel=Anchor># </span>Step 3：读取响应</h5></a><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172116.png width=auto alt=img></p><p>当响应的数据开始传送到浏览器时，网络线程会在必要的情况下检查一些来自响应的字段。响应数据的 <code>Content-Type</code> 字段会表示当前返回的是哪种类型的数据，但它也不完全靠谱，经常会出现丢失或者干脆不准确的情况，但也不用担心，<strong>MIME 嗅探</strong>[3]会完成缺失的工作。正如<strong>源码</strong>[4]的注释中写道，这是一个可以被解释为 hack 的方案，如果感兴趣的话，你也可以去阅读这些注释，这样就能了解不同的浏览器是如何将实际的数据与 <code>Content-Type</code> 匹配了。</p><p>如果响应数据是一个 HTML 文件，那么接下来的一步会是把数据传递给浏览器的渲染进程；但如果数据是 zip 压缩文件或其他类型的文件，意味着这将被定位成一次下载动作，于是浏览器会将数据转交给下载管理器去处理。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172117.png width=auto alt=img></p><p>通常这一步也是<strong>安全检测</strong>[5]发生的时候：如果域名或响应数据和已知的恶意网站匹配时，网络进程会抛出一个警告，并展现一个告警的页面。另外，<strong>CORB</strong>[6] 检测也会开始工作，确保那些来自敏感站点的跨站响应数据不会进入到浏览器的渲染进程中。</p><a href=#step-4渲染进程><h5 id=step-4渲染进程><span class=hanchor arialabel=Anchor># </span>Step 4：渲染进程</h5></a><p>网络线程以获取了全部的数据，并完成了所有需要的检查，此刻它自信的告诉 UI 线程：“小兄弟，数据准备好了！”。接着，UI 线程会唤起一个渲染进程去渲染页面。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172117.png width=auto alt=img></p><p>由于网络情况的不可控，一个请求可能会花上好几百毫秒才能把响应数据拿回来，所以这里浏览器默认开启了用来加速这一过程的优化。在 Step 2 中，当 UI 线程将需要请求的 url 告诉网络线程时，其实它本身已经知道要导航到哪个网站了，于是 UI 线程在把 url 传递给网络线程的同时，会尝试启动一个渲染进程。如果一切都按照预期正常进行的话，当网络线程拿到数据时，渲染进程就已经处于待命状态了。也会有例外的情况：比如导航重定向到一个另外的站点，那么预先启动好的渲染进程将不会被使用，这导致 UI 线程需要重新启动一个渲染进程。</p><a href=#step-5触发导航><h5 id=step-5触发导航><span class=hanchor arialabel=Anchor># </span>Step 5：触发导航</h5></a><p>现在我们假设数据和渲染进程都准备好了，浏览器进程通过 IPC 告知渲染进程可以出发本次导航了。与此同时，数据流也将传递给渲染进程，这样后者就能继续接收 HTML 数据。一旦浏览器收到了来自渲染进程的导航启动信号，这次导航也就完成了，下一步进入文档的加载阶段。</p><p>到这会儿，浏览器的地址栏更新，安全指示符和站点的设置 UI 会将新页面的信息呈现出来。当前窗口的 session 将会更新，刚导航到的页面会被后退/前进按钮记录到窗口的页面历史中。为了便于在关闭窗口时恢复页面，历史的会话记录会保存在本地的磁盘上。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172118.png width=auto alt=img></p><a href=#extra-step初始加载完成><h5 id=extra-step初始加载完成><span class=hanchor arialabel=Anchor># </span>Extra Step：初始加载完成</h5></a><p>当导航触发后，渲染进程会持续接收资源并渲染页面。我们将在下一篇文章中讨论这一步的更多细节。当渲染进程“完成”渲染后，它会通过 IPC 告知浏览器进程（页面的 onload 事件均已执行完毕后），UI 线程也就不再在 tab 上转菊花了。</p><p>上面的“完成”两个字，之所以打了双引号，因为在实际场景中，它通常并不真正意味着完成，因为客户端的 JavaScript 可能在此时持续地加载资源并渲染新的视图。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172119.png width=auto alt=img></p><a href=#导航到另一个网站><h5 id=导航到另一个网站><span class=hanchor arialabel=Anchor># </span>导航到另一个网站</h5></a><p>一次简单的导航截至目前已经完成了。假如这时用户输入了一个不同的 url 会发生什么呢？其实也没啥，浏览器进程会按照上面的步骤导航到这个网站。但在这一切开始之前，浏览器会检查当前已经渲染好了的网站是否需要在网页卸载之前搞一点事情，这就是 <code>beforeunload</code> 事件。</p><p>在 <code>beforeunload</code> 事件中，我们可以在用户即将跳转至其他页面或者关闭 Tab 的时候发起一个“确认离开当前页面？”的二次确认。Tab 中的所有东西都由渲染进程控制着，当然也包括开发者编写的 JavaScript，所以当一个新的导航请求即将到来时，浏览器进程会对当前的渲染进程做最后的检查。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172120.png width=auto alt=img></p><p>我们应当尽量避免在 <code>beforeunload</code> 中添加总会执行的事件代码，这会造成更多的交互延时，毕竟它们总会在新的导航开始之前执行。<strong>只在需要的时候添加这些代码</strong>，比如提醒用户如果进入新的页面那么当前页面的数据会丢失。</p><p>如果导航是在渲染进程中被创建的（比如用户点击了页面上的某一链接或者在 JavaScript 运行了 <code>window.location.href = 'https://kyrieliu.cn'</code> ），则当前的渲染进程会首先检查是 <code>beforeunload</code> 中是否有东西需要执行。之后，它会经历与浏览器进程直接发起导航后一样的导航过程。</p><p>当新的导航将发往与当前页面不同的站点时，浏览器将会创建一个新的渲染进程去处理这些新工作，旧的渲染进程则则用来在剩余的时间里处理诸如 <code>unload</code> 的页面事件。如果你想了解更多的话，可以看看<strong>页面生命周期概览</strong>[7]和<strong>页面生命周期 API</strong>[8]这两篇文章。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172121.png width=auto alt=img></p><a href=#如果有-service-worker><h5 id=如果有-service-worker><span class=hanchor arialabel=Anchor># </span>如果有 Service Worker…</h5></a><p><strong>Service Worker</strong>[9] 的引入会对页面的导航流程带来一些改变。Service Worker 是一种可以在应用代码中编写网络代理的方法；增强了开发者对于本地缓存以及何时发起网络请求的控制。如果 Service Worker 提前设置了从本地缓存中读取某一页面的数据，那么也就不需要发起网络请求了。</p><p>需要明确的一点是，即使 Service Worker 提供了听起来很高端的功能，但它实质上也是运行在渲染进程中的 JavaScript 代码。那么问题来了：当用户发起一次导航时，浏览器进程是如何知道目标站点存在一个 Service Worker 的呢？</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172122.png width=auto alt=img></p><p>当一个 Service Worker 注册后，它的作用域会保存在一个引用中（你可以通过 <strong>Service Worker 的生命周期</strong>[10] 这篇文章了解我所说的“作用域”）。当导航发生时，网络线程会依据域名在已注册的 Service Worker 作用域集合中查询，如果找到某个对应的 Service Worker，UI 线程会发起一个渲染进程去执行 Service Worker 中的代码。Service Worker 可以从本地缓存中加载数据（无需发起网络请求），也可以选择通过网络请求获取最新的资源和数据。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172123.png width=auto alt=img></p><a href=#导航预加载><h5 id=导航预加载><span class=hanchor arialabel=Anchor># </span>导航预加载</h5></a><p>相信你可以发现，如果 Service Worker 最终决定从网络中请求数据，那么之前在浏览器进程和渲染进程之间所发生的通信都将成为导致响应延时的罪魁祸首。<strong>导航预加载</strong>[11]就是用来加速这一进程的机制：与 Service Worker 并行启动去加载资源。它将为这些请求设置一个 Header，由服务端来决定为这些请求发送不同的内容；比如，仅返回更新的数据而不是整个文档。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172124.png width=auto alt=img></p><a href=#浏览器端的-event-loop><h3 id=浏览器端的-event-loop><span class=hanchor arialabel=Anchor># </span>浏览器端的 Event Loop</h3></a><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172125.png width=auto alt=img></p><p>上图是一张 JS 的运行机制图，Js 运行时大致会分为几个部分：</p><ol><li>Call Stack：调用栈(执行栈)，所有同步任务在主线程上执行，形成一个执行栈，因为 JS 单线程的原因，所以调用栈中每次只能执行一个任务，当遇到的同步任务执行完之后，由任务队列提供任务给调用栈执行。</li><li>Task Queue：任务队列，存放着异步任务，当异步任务可以执行的时候，任务队列会通知主线程，然后该任务会进入主线程执行。任务队列中的都是已经完成的异步操作，而不是说注册一个异步任务就会被放在这个任务队列中。</li></ol><p>说到这里，Event Loop 也可以理解为：不断地从任务队列中取出任务执行的一个过程。</p><a href=#同步任务和异步任务><h4 id=同步任务和异步任务><span class=hanchor arialabel=Anchor># </span>同步任务和异步任务</h4></a><p>上文已经说过了 JavaScript 是一门单线程的语言，一次只能执行一个任务，如果所有的任务都是同步任务，那么程序可能因为等待会出现假死状态，这对于一个用户体验很强的语言来说是非常不友好的。</p><p>比如说向服务端请求资源，你不可能一直不停的循环判断有没有拿到数据，就好像你点了个外卖，点完之后就开始一直打电话问外卖有没有送到，外卖小哥都会抄着锅铲来打你(狗头)。因此，在 JavaScript 中任务有了同步任务和异步任务，异步任务通过注册回调函数，等到数据来了就通知主程序。</p><ol><li>同步任务：必须等到结果来了之后才能做其他的事情，举例来说就是你烧水的时候一直等在水壶旁边等水烧开，期间不做其他的任何事情。</li><li>异步任务：不需要等到结果来了才能继续往下走，等结果期间可以做其他的事情，结果来了会收到通知。举例来说就是你烧水的时候可以去做自己想做的事情，听到水烧开的声音之后再去处理。</li></ol><p>从概念就可以看出来，异步任务从一定程度上来看比同步任务更高效一些，核心是提高了用户体验。</p><a href=#event-loop><h4 id=event-loop><span class=hanchor arialabel=Anchor># </span>Event Loop</h4></a><p>Event Loop 很好的调度了任务的运行，宏任务和微任务也知道了，现在我们就来看看它的调度运行机制。</p><p>JavaScript 的代码执行时，主线程会从上到下一步步的执行代码，同步任务会被依次加入执行栈中先执行，异步任务会在拿到结果的时候将注册的回调函数放入任务队列，当执行栈中的没有任务在执行的时候，引擎会从任务队列中读取任务压入执行栈(Call Stack)中处理执行。</p><a href=#宏任务和微任务><h4 id=宏任务和微任务><span class=hanchor arialabel=Anchor># </span>宏任务和微任务</h4></a><p>现在就有一个问题了，任务队列是一个消息队列，先进先出，那就是说，后来的事件都是被加在队尾等到前面的事件执行完了才会被执行。如果在执行的过程中突然有重要的数据需要获取，或是说有事件突然需要处理一下，<strong>按照队列的先进先出顺序这些是无法得到及时处理的。这个时候就催生了宏任务和微任务，微任务使得一些异步任务得到及时的处理</strong>。</p><p>曾经看到的一个例子很好，宏任务和微任务形象的来说就是：你去营业厅办一个业务会有一个排队号码，当叫到你的号码的时候你去窗口办充值业务(宏任务执行)，在你办理充值的时候你又想改个套餐(微任务)，这个时候工作人员会直接帮你办，不可能让你重新排队。</p><p>所以上文说过的异步任务又分为宏任务和微任务，JS 运行时任务队列会分为宏任务队列和微任务队列，分别对应宏任务和微任务。</p><p>先介绍一下(浏览器环境的)宏任务和微任务大致有哪些：</p><ul><li><p>宏任务：</p></li><li><ol><li>script(整体的代码)</li><li>setTimeout</li><li>setInterval</li><li>I/O 操作</li><li>UI 渲染 (对这个笔者持保留意见)</li></ol></li><li><p>微任务：</p></li><li><ol><li>Promise.then</li><li>MutationObserver</li></ol></li></ul><a href=#事件运行顺序><h4 id=事件运行顺序><span class=hanchor arialabel=Anchor># </span>事件运行顺序</h4></a><ol><li>执行同步任务，同步任务不需要做特殊处理，直接执行(下面的步骤中遇到同步任务都是一样处理) &mdash; 第一轮从 script开始</li><li>从宏任务队列中取出队头任务执行</li><li>如果产生了宏任务，将宏任务放入宏任务队列，下次轮循的时候执行</li><li>如果产生了微任务，将微任务放入微任务队列</li><li>执行完当前宏任务之后，取出微任务队列中的所有任务依次执行</li><li>如果微任务执行过程中产生了新的微任务，则继续执行微任务，直到微任务的队列为空</li><li>轮循，循环以上 2 - 6</li></ol><p>总的来说就是：同步任务/宏任务 -> 执行产生的所有微任务(包括微任务产生的微任务) -> 同步任务/宏任务 -> 执行产生的所有微任务(包括微任务产生的微任务) -> 循环……</p><p>注意：微任务队列</p><a href=#举个栗子><h4 id=举个栗子><span class=hanchor arialabel=Anchor># </span>举个栗子</h4></a><p>光说不练假把式，现在就来看一个例子：</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172126.png width=auto alt=img>举个栗子</p><p>放图的原因是为了让大家在看解析之前可以先自己按照运行顺序走一遍，写好答案之后再来看解析。<br>解析：<br>(用绿色的表示同步任务和宏任务，红色表示微任务)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=o>+</span>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;script start&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>+</span>  <span class=nx>setTimeout</span><span class=p>(</span><span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>+</span>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;setTimeout&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>+</span>  <span class=p>},</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>+</span>  <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)=&gt;{</span>
</span></span><span class=line><span class=cl><span class=o>+</span>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;promise1&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>+</span>    <span class=nx>resolve</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=o>+</span>  <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=o>-</span>  <span class=p>.</span><span class=nx>then</span><span class=p>(()=&gt;{</span>
</span></span><span class=line><span class=cl><span class=o>-</span>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;then11&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>+</span>    <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)=&gt;{</span>
</span></span><span class=line><span class=cl><span class=o>+</span>      <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;promise2&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>+</span>      <span class=nx>resolve</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=o>+</span>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=o>-</span>    <span class=p>.</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>-</span>      <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;then2-1&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>-</span>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=o>-</span>    <span class=p>.</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>-</span>      <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;then2-2&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>-</span>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=o>-</span>  <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=o>-</span>  <span class=p>.</span><span class=nx>then</span><span class=p>(()=&gt;{</span>
</span></span><span class=line><span class=cl><span class=o>-</span>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;then12&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>-</span>  <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=o>+</span>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;script end&#39;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ol><li>首先遇到 console.log()，输出 <code>script start</code></li><li>遇到 setTimeout 产生宏任务，注册到<strong>宏任务队列[setTimeout]</strong>，下一轮 Event Loop 的时候在执行</li><li>然后遇到 new Promise 构造声明(同步)，log 输出 <code>promise1</code>，然后 resolve</li><li>resolve 匹配到 <strong>promise1 的第一个 then</strong>，把这个 then 注册到<strong>微任务队列[then11]中</strong>，继续当前整体脚本的执行</li><li>遇到最后的一个 log，输出 <code>script end</code>，<strong>当前执行栈清空</strong></li><li><strong>从微任务队列中取出队头任务&rsquo;then11&rsquo;</strong> 进行执行，其中有一个 log，输出 <code>then11</code></li><li>往下遇到 new Promise 构造声明(同步)，log 输出 <code>promise2</code>，然后 resolve</li><li>resolve 匹配到 <strong>promise2 的第一个 then</strong>，把这个 then 注册到<strong>微任务队列[then2-1]</strong>，当前 then11 可执行部分结束，然后产生了 <strong>promise1 的第二个 then</strong>，把这个 then 注册到<strong>微任务队列[then2-1, then12]</strong></li><li><strong>拿出微任务队头任务&rsquo;then2-1&rsquo;</strong> 执行，log 输出 <code>then2-1</code>，触发 <strong>promise2 的第二个 then</strong>，注册到<strong>微任务队列[then12, then2-2]</strong></li><li><strong>拿出微任务队头任务&rsquo;then12&rsquo;</strong>，log 输出 <code>then12</code></li><li><strong>拿出微任务队头任务&rsquo;then2-2&rsquo;</strong>，log 输出 <code>then2-2</code></li><li>微任务队列执行完毕，别忘了宏任务队列中的 setTimeout，log 输出 <code>setTimeout</code></li></ol><p>经过以上一番缜(xia)密(gao)分析，希望没有绕晕你，最后的输出结果就是：<br><code>script start -> promise1 -> script end -> then11 -> promise2 -> then2-1 -> then12 -> then2-2 -> setTimeout</code></p><a href=#宏任务微任务><h4 id=宏任务微任务><span class=hanchor arialabel=Anchor># </span>宏任务？微任务？</h4></a><p>不知道大家看了宏任务和微任务之后会不会有一个疑惑，宏任务和微任务都是异步任务，微任务之前说过了是为了及时解决一些必要事件而产生的。</p><ul><li><p>为什么要有微任务？<br>为什么要有微任务的原因前面已经说了，这里就不再赘述，简单说一下就是为了及时处理一些任务，不然等到最后再执行的时候拿到的数据可能已经是被污染的数据达不到预期目标了。</p></li><li><p>是什么宏任务？什么是微任务？<br>相信大家在学习 Event Loop 查找资料的时候，肯定各种资料里面都会讲到宏任务和微任务，但是不知道你有没有灵魂拷问过你自己：<code>什么是宏任务？什么是微任务？怎么区分宏任务和微任务？</code>不能只是默许接受这个概念，在这里，我根据我的个人理解进行一番说(hu)明(che)</p></li><li><p>宏任务和微任务的真面目<br>其实在 Chrome 的源码中并没有什么宏任务和微任务的代码或是说明，在 <strong>JS 大会</strong>[3]上提到过微任务这个名词，但是也没有说到底什么是微任务。</p><p>宏任务<br>文章最开始的时候说过，在 chrome 里，每个页面都对应一个进程。而该进程又有多个线程，比如 JS 线程、渲染线程、IO 线程、网络线程、定时器线程等等，这些线程之间的通信是通过向对象的任务队列中添加一个任务（postTask）来实现的。<strong>宏任务的本质可以认为是多线程事件循环或消息循环，也就是线程间通信的一个消息队列。</strong></p><p>就拿 setTimeout 举例来说，当遇到它的时候，浏览器就会对 Event Loop 说：嘿，我有一个任务交给你，Event Loop 就会说：好的，我会把它加到我的 todoList 中，之后我会执行它，它是需要调用 API 的。</p><p><strong>宏任务的真面目是浏览器派发，与 JS 引擎无关的，参与了 Event Loop 调度的任务</strong></p><p>微任务<br>微任务是在运行宏任务/同步任务的时候产生的，是属于当前任务的，所以它不需要浏览器的支持，内置在 JS 当中，直接在 JS 的引擎中就被执行掉了。</p></li></ul><a href=#特殊的点><h4 id=特殊的点><span class=hanchor arialabel=Anchor># </span>特殊的点</h4></a><ol><li>async 隐式返回 Promise 作为结果</li><li>执行完 await 之后直接跳出 async 函数，让出执行的所有权</li><li>当前任务的其他代码执行完之后再次获得执行权进行执行</li><li>立即 resolve 的 Promise 对象，是在本轮"事件循环"的结束时执行，而不是在下一轮"事件循环"的开始时</li></ol><a href=#再举个栗子><h4 id=再举个栗子><span class=hanchor arialabel=Anchor># </span>再举个栗子</h4></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;script start&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kr>async</span> <span class=kd>function</span> <span class=nx>async1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kr>await</span> <span class=nx>async2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;async1 end&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kr>async</span> <span class=kd>function</span> <span class=nx>async2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;async2 end&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>async1</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>setTimeout</span><span class=p>(</span><span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;setTimeout&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>newPromise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Promise&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nx>resolve</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;promise1&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;promise2&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;script end&#39;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>按照之前的分析方法去分析之后就会得出一个结果：<br><code>script start => async2 end => Promise => script end => promise1 => promise2 => async1 end => setTimeout</code></p><p>可以看出 async1 函数获取执行权是作为微任务的队尾，但是，在 Chrome73(金丝雀) 版本之后，async 的执行优化了，它会在 promise1 和 promise2 的输出之前执行。笔者大概了解了一下应该是用 PromiseResolve 对 await 进行了优化，减少了 Promise 的再次创建，有兴趣的小伙伴可以看看 Chrome 的源码。</p><a href=#node-中的-event-loop><h3 id=node-中的-event-loop><span class=hanchor arialabel=Anchor># </span>Node 中的 Event Loop</h3></a><p>Node 中也有宏任务和微任务，与浏览器中的事件循环类似。Node 与浏览器事件循环不同，其中有多个宏任务队列，而浏览器是只有一个宏任务队列。</p><p>Node 的架构底层是有 libuv，它是 Node 自身的动力来源之一，通过它可以去调用一些底层操作，Node 中的 Event Loop 功能就是在 libuv 中封装实现的。</p><a href=#宏任务和微任务-1><h4 id=宏任务和微任务-1><span class=hanchor arialabel=Anchor># </span>宏任务和微任务</h4></a><p>Node 中的宏任务和微任务在浏览器端的 JS 相比增加了一些，这里只列出浏览器端没有的：</p><ul><li>宏任务</li><li><ol><li>setImmediate</li></ol></li><li>微任务</li><li><ol><li>process.nextTick</li></ol></li></ul><a href=#事件循环机制的六个阶段><h4 id=事件循环机制的六个阶段><span class=hanchor arialabel=Anchor># </span><strong>事件循环机制的六个阶段</strong></h4></a><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172127.png width=auto alt=image-20200402223627057></p><p>Node 的事件循环分成了六个阶段，每个阶段对应一个宏任务队列，相当于是宏任务进行了一个分类。</p><ol><li>timers(计时器)<br>执行 setTimeout 以及 setInterval 的回调</li><li>I/O callbacks<br>处理网络、流、TCP 的错误回调</li><li>idel, prepare &mdash; 闲置阶段<br>node 内部使用</li><li>poll(轮循)<br>执行 poll 中的 I/O 队列，检查定时器是否到时间</li><li>check(检查)<br>存放 setImmediate 回调</li><li>close callbacks<br>关闭回调，例如 sockect.on(&lsquo;close&rsquo;)</li></ol><a href=#轮循顺序><h4 id=轮循顺序><span class=hanchor arialabel=Anchor># </span>轮循顺序</h4></a><p>执行的轮循顺序 &mdash; 每个阶段都要等对应的宏任务队列执行完毕才会进入到下一个阶段的宏任务队列</p><ol><li>timers</li><li>I/O callbacks</li><li>poll</li><li>setImmediate</li><li>close events</li></ol><p>每两个阶段之间执行微任务队列</p><a href=#event-loop-过程><h4 id=event-loop-过程><span class=hanchor arialabel=Anchor># </span>Event Loop 过程</h4></a><ol><li>执行全局的 script 同步代码</li><li>执行微任务队列，先执行所有 Next Tick 队列中的所有任务，再执行其他的微任务队列中的所有任务</li><li>开始执行宏任务，共六个阶段，从第一个阶段开始执行自己宏任务队列中的所有任务(浏览器是从宏任务队列中取第一个执行！！)</li><li>每个阶段的宏任务执行完毕之后，开始执行微任务</li><li>TimersQueue -> 步骤2 -> I/O Queue -> 步骤2 -> Check Queue -> 步骤2 -> Close Callback Queue -> 步骤2 -> TimersQueue …</li></ol><p>这里要注意的是，nextTick 事件是一个单独的队列，它的优先级会高于微任务，所以在当前宏任务/同步任务执行完成之后，会先执行 nextTick 队列中的所有任务，再去执行微任务队列中的所有任务。</p><a href=#node-与浏览器的-event-loop-差异><h3 id=node-与浏览器的-event-loop-差异><span class=hanchor arialabel=Anchor># </span>Node 与浏览器的 Event Loop 差异</h3></a><p><strong>浏览器环境下，microtask 的任务队列是每个 macrotask 执行完之后执行。而在 Node.js 中，microtask 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 microtask 队列的任务</strong>。</p><p><a href=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172128.png rel=noopener><img src=https://jieye-ericx.github.io//Browser.assets/2019-01-14-006.png width=auto alt=img></a></p><p>接下我们通过一个例子来说明两者区别：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()=&gt;{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;timer1&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>Promise</span><span class=p>.</span><span class=nx>resolve</span><span class=p>().</span><span class=nx>then</span><span class=p>(</span><span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;promise1&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()=&gt;{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;timer2&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>Promise</span><span class=p>.</span><span class=nx>resolve</span><span class=p>().</span><span class=nx>then</span><span class=p>(</span><span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;promise2&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=mi>0</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>浏览器端运行结果：<code>timer1=>promise1=>timer2=>promise2</code></p><p>浏览器端的处理过程如下：</p><p><a href=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172129.gif rel=noopener><img src=https://jieye-ericx.github.io//Browser.assets/2019-01-14-007.gif width=auto alt=img></a></p><p>Node 端运行结果：<code>timer1=>timer2=>promise1=>promise2</code></p><ul><li>全局脚本（main()）执行，将 2 个 timer 依次放入 timer 队列，main()执行完毕，调用栈空闲，任务队列开始执行；</li><li>首先进入 timers 阶段，执行 timer1 的回调函数，打印 timer1，并将 promise1.then 回调放入 microtask 队列，同样的步骤执行 timer2，打印 timer2；</li><li>至此，timer 阶段执行结束，event loop 进入下一个阶段之前，执行 microtask 队列的所有任务，依次打印 promise1、promise2</li></ul><p>Node 端的处理过程如下：</p><p><a href=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172130.gif rel=noopener><img src=https://jieye-ericx.github.io//Browser.assets/2019-01-14-008.gif width=auto alt=img></a></p><p>浏览器和 Node 环境下，microtask 任务队列的执行时机不同</p><ul><li>Node 端，microtask 在事件循环的各个阶段之间执行</li><li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li></ul><a href=#settimeout-和-setimmediate><h3 id=settimeout-和-setimmediate><span class=hanchor arialabel=Anchor># </span>setTimeout 和 setImmediate</h3></a><p>在这里要单独说一下 setTimeout 和 setImmediate，setTimeout 定时器很熟悉，那就说说 setImmediate</p><p>setImmediate() 方法用于把一些需要长时间运行的操作放在一个回调函数里，并在浏览器完成其他操作（如事件和显示更新）后立即运行回调函数。从定义来看就是为了防止一些耗时长的操作阻塞后面的操作，这也是为什么 check 阶段运行顺序排的比较后。</p><a href=#举个栗子-1><h4 id=举个栗子-1><span class=hanchor arialabel=Anchor># </span>举个栗子</h4></a><p>我们来看这样的一个例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>setTimeout(() =&gt; {
</span></span><span class=line><span class=cl>  console.log(&#39;setTimeout&#39;)
</span></span><span class=line><span class=cl>}, 0)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>setImmediate(() =&gt; {
</span></span><span class=line><span class=cl>  console.log(&#39;setImmediate&#39;)
</span></span><span class=line><span class=cl>})
</span></span></code></pre></td></tr></table></div></div><p>这里涉及 timers 阶段和 check 阶段，按照上面的运行顺序来说，timers 阶段是在第一个执行的，会早于 check 阶段。运行这段程序可以看到如下的结果：</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172131.png width=auto alt=image-20200402224016596></p><p>可是再多运行几次，你就会看到如下的结果：</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172132.png width=auto alt=image-20200402224028075></p><p>setImmediate 的输出跑到 setTimeout 前面去了，这时候就是：小朋友你是否有很多的问号❓</p><a href=#分析><h4 id=分析><span class=hanchor arialabel=Anchor># </span>分析</h4></a><p>我们来分析一下原因，timers 阶段确实是在 check 阶段之前，但是在 timers 阶段时候，这里的 setTimeout 真的到了执行的时间吗？</p><p>这里就要先看看 <code>setTiemout(fn, 0)</code>，这个语句的意思不是指不延迟的执行，而是指在可以执行 setTimeout 的时候就立即执行它的回调，也就是处理完当前事件的时候立即执行回调。</p><p>在 Node 中 setTimeout 第二个时间参数的最小值是 1ms，小于 1ms 会被初始化为 1(浏览器中最小值是 4ms)，所以在这里 <code>setTimeout(fn, 0) === setTimeout(fn, 1)</code></p><p>setTimeout 的回调函数在 timers 阶段执行，setImmediate 的回调函数在 check 阶段执行，Event Loop 的开始会先检查 timers 阶段，但是在代码开始运行之前到 timers 阶段(代码的启动、运行)会消耗一定的时间，所以会出现两种情况：</p><ol><li>timers 前的准备时间超过 1ms，满足 loop -> timers >= 1，setTimeout 的时钟周期到了，则执行 timers 阶段(setTimeout)的回调函数</li><li>timers 前的准备时间小于 1ms，还没到 setTimeout 预设的时间，则先执行 check 阶段(setImmediate)的回调函数，下一次 Event Loop 再进入 timers 阶段执行 timer 阶段(setTimeout)的回调函数</li></ol><p>最开始就说了，一个优秀的程序员要让自己的代码按照自己想要的顺序运行，下面我们就来控制一下 setTimeout 和 setImediate 的运行。</p><ul><li>让 setTimeout 先执行<br>上面代码运行顺序不同无非就是因为 Node 准备时间的不确定性，我们可以直接手动延长准备时间👇</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>const start = Date.now()
</span></span><span class=line><span class=cl>  while (Date.now() - start &lt; 10)
</span></span><span class=line><span class=cl>  setTimeout(() =&gt; {
</span></span><span class=line><span class=cl>  console.log(&#39;setTimeout&#39;)
</span></span><span class=line><span class=cl>  }, 0)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  setImmediate(() =&gt; {
</span></span><span class=line><span class=cl>    console.log(&#39;setImmediate&#39;)
</span></span><span class=line><span class=cl>  })
</span></span></code></pre></td></tr></table></div></div><ul><li><p>让 setImmediate 先执行<br>setImmediate 是在 check 阶段执行，相对于 setTimeout 来说是在 timers 阶段之后，只需要想办法把程序的运行环境控制在 timers 阶段之后就可以了。</p><p>让程序至少从 I/O callbacks 阶段开始 &mdash; 可以套一层文件读写把把程序控制在 I/O callbacks 阶段的运行环境中👇</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>const fs = require(&#39;fs&#39;)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>fs.readFile(__dirname, () =&gt; {
</span></span><span class=line><span class=cl>  setTimeout(() =&gt; {
</span></span><span class=line><span class=cl>    console.log(&#39;setTimeout&#39;)
</span></span><span class=line><span class=cl>  }, 0)
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  setImmediate(() =&gt; {
</span></span><span class=line><span class=cl>    console.log(&#39;setImmediate&#39;)
</span></span><span class=line><span class=cl>  })
</span></span><span class=line><span class=cl>})
</span></span></code></pre></td></tr></table></div></div><a href=#node-11x-的变化><h3 id=node-11x-的变化><span class=hanchor arialabel=Anchor># </span>Node 11.x 的变化</h3></a><p>timers 阶段的执行有所变化</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>setTimeout(() =&gt;console.log(&#39;timeout1&#39;))
</span></span><span class=line><span class=cl>setTimeout(() =&gt; {
</span></span><span class=line><span class=cl> console.log(&#39;timeout2&#39;)
</span></span><span class=line><span class=cl> Promise.resolve().then(() =&gt;console.log(&#39;promise resolve&#39;))
</span></span><span class=line><span class=cl>})
</span></span></code></pre></td></tr></table></div></div><ol><li>node 10 及之前的版本：<br>要考虑上一个定时器执行完成时，下一个定时器是否到时间加入了任务队列中，如果未到时间，先执行其他的代码。<br>比如：<br>timer1 执行完之后 timer2 到了任务队列中，顺序为 <code>timer1 -> timer2 -> promise resolve</code><br>timer2 执行完之后 timer2 还没到任务队列中，顺序为 <code>timer1 -> promise resolve -> timer2</code></li><li>node 11 及其之后的版本：<br><code>timeout1 -> timeout2 -> promise resolve</code><br>一旦执行某个阶段里的一个宏任务之后就立刻执行微任务队列，这和浏览器端运行是一致的。</li></ol><a href=#小结><h3 id=小结><span class=hanchor arialabel=Anchor># </span>小结</h3></a><p>Node 和端浏览器端有什么不同</p><ol><li>浏览器端的 Event Loop 和 Node.js 中的 Event Loop 是不同的，实现机制也不一样</li><li>Node.js 可以理解成有4个宏任务队列和2个微任务队列，但是执行宏任务时有6个阶段</li><li>Node.js 中限制性全局 script 代码，执行完同步代码后，先从微任务队列 Next Tick Queue 中取出所有任务放入调用栈执行，再从其他微任务队列中取出所有任务放入调用栈中执行，然后开始宏任务的6个阶段，每个阶段都将其宏任务队列中的所有任务都取出来执行(浏览器是只取第一个执行)，每个宏任务阶段执行完毕之后开始执行微任务，再开始执行下一阶段宏任务，以此构成事件循环</li><li>宏任务包括 ….</li><li>微任务包括 ….</li></ol><p>看到这里，你应该对浏览器端和 Node 端的 Event Loop 有了一定的了解，那就留一个题目。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172133.png width=auto alt=image-20200402224502960></p><p>不直接放代码是想让大家先自己思考然后在敲代码运行一遍</p><a href=#浏览器存储><h2 id=浏览器存储><span class=hanchor arialabel=Anchor># </span>浏览器存储</h2></a><a href=#cookies><h3 id=cookies><span class=hanchor arialabel=Anchor># </span>cookies</h3></a><a href=#多种浏览器存储方式并存如何选择><h4 id=多种浏览器存储方式并存如何选择><span class=hanchor arialabel=Anchor># </span>多种浏览器存储方式并存，如何选择？</h4></a><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172134 width=auto alt=img></p><ul><li>因为<code>http</code>请求无状态，所以需要<code>cookie</code>去维持客户端状态</li><li>cookie的生成方式：<ul><li><code>http</code>&ndash;><code>response header</code>&ndash;><code>set-cookie</code></li></ul></li><li><code>js</code>中可以通过<code>document.cookie</code>可以读写<code>cookie</code></li><li>cookie的使用用处：<ul><li>用于浏览器端和服务器端的交互(用户状态)</li><li>客户端自身数据的存储</li></ul></li><li><code>expire</code>：过期时间</li><li>cookie的限制：<ul><li>作为浏览器存储，大小<code>4kb</code>左右</li><li>需要设置过期时间 <code>expire</code></li></ul></li><li>重要属性：<code>httponly</code> 不支持<code>js</code>读写(防止收到模拟请求攻击)</li><li>不太作为存储方案而是用于维护客户关系</li><li>优化点：cookie中在相关域名下面：<ul><li><code>cdn</code>的流量损耗</li><li>解决方案：<code>cdn</code>的域名和主站域名要分开</li></ul></li></ul><p><strong>API</strong></p><p>服务端向客户端发送的cookie(HTTP头,不带参数)：<br><code>Set-Cookie: =</code> (name可选)</p><p>服务端向客户端发送的cookie(HTTP头，带参数)：<br><code>Set-Cookie: =;(可选参数1);(可选参数2)</code></p><p>客户端设置cookie：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>document.cookie = &#34;&lt;cookie-name&gt;=&lt;cookie-value&gt;;(可选参数1);(可选参数2)&#34;
</span></span></code></pre></td></tr></table></div></div><p>可选参数：<br><code>Expires=</code>：cookie的最长有效时间，若不设置则cookie生命期与会话期相同</p><p><code>Max-Age=</code>：cookie生成后失效的秒数</p><p><code>Domain=</code>：指定cookie可以送达的主机域名，若一级域名设置了则二级域名也能获取。</p><p><code>Path=</code>：指定一个URL，例如指定path=/docs，则”/docs”、”/docs/Web/“、”/docs/Web/Http”均满足匹配条件</p><p><code>Secure</code>：必须在请求使用SSL或HTTPS协议的时候cookie才回被发送到服务器</p><p><code>HttpOnly</code>：客户端无法更改Cookie，客户端设置cookie时不能使用这个参数，一般是服务器端使用</p><p>示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Set-Cookie: sessionid=aes7a8; HttpOnly; Path=/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>document.cookie = &#34;KMKNKK=1234;Sercure&#34;
</span></span></code></pre></td></tr></table></div></div><p>可选前缀：<br><code>__Secure-</code>：以<code>__Secure-</code>为前缀的cookie，必须与secure属性一同设置，同时必须应用于安全页面（即使用HTTPS）</p><p><code>__Host-</code>：以<code>__Host-</code>为前缀的cookie，必须与secure属性一同设置，同时必须应用于安全页面（即使用HTTPS）。必须不能设置domian属性（这样可以防止二级域名获取一级域名的cookie），path属性的值必须为”/“。</p><p>前缀使用示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Set-Cookie: __Secure-ID=123; Secure; Domain=example.com
</span></span><span class=line><span class=cl>Set-Cookie: __Host-ID=123; Secure; Path=/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>document.cookie = &#34;__Secure-KMKNKK=1234;Sercure&#34;
</span></span><span class=line><span class=cl>document.cookie = &#34;__Host-KMKNKK=1234;Sercure;path=/&#34;
</span></span></code></pre></td></tr></table></div></div><a href=#local-storage><h3 id=local-storage><span class=hanchor arialabel=Anchor># </span>local storage</h3></a><ul><li><code>HTML5</code>设计出来专门用于浏览器存储的</li><li>大小为<code>5M</code>左右</li><li>仅在客户端使用，不和服务端进行通信</li><li>接口封装较好</li><li>浏览器本地缓存方案</li></ul><p><strong>API</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>//sessionStorage用法相同
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>localStorage</span><span class=p>.</span><span class=nx>setItem</span><span class=p>(</span><span class=s2>&#34;name&#34;</span><span class=p>,</span><span class=mi>1</span><span class=p>);</span>   <span class=c1>// 以&#34;x&#34;为名字存储一个数值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>localStorage</span><span class=p>.</span><span class=nx>getItem</span><span class=p>(</span><span class=s2>&#34;name&#34;</span><span class=p>);</span>     <span class=c1>// 获取数值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>localStorage</span><span class=p>.</span><span class=nx>key</span><span class=p>(</span><span class=nx>i</span><span class=p>);</span>              <span class=c1>// 获取第i对的名字
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>localStorage</span><span class=p>.</span><span class=nx>removeItem</span><span class=p>(</span><span class=s2>&#34;name&#34;</span><span class=p>);</span>  <span class=c1>// 获取该对的值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>localStorage</span><span class=p>.</span><span class=nx>clear</span><span class=p>();</span>             <span class=c1>// 全部删除
</span></span></span></code></pre></td></tr></table></div></div><a href=#session-storage><h3 id=session-storage><span class=hanchor arialabel=Anchor># </span>session storage</h3></a><ul><li>会话级别的浏览器存储</li><li>大小为<code>5M</code>左右</li><li>仅在客户端使用，不和服务器端进行通信</li><li>接口封装较好</li><li>对于表单信息的维护</li></ul><a href=#indexeddb><h3 id=indexeddb><span class=hanchor arialabel=Anchor># </span>indexedDB</h3></a><ul><li><code>IndexedDB</code>是一种低级<code>API</code>，用于客户端存储大量结构化数据。该<code>API</code>使用索引来实现对该数据的高性能搜索。虽然<code>Web</code></li><li><code>Storage</code>对于存储叫少量的数据很管用，但对于存储更大量的结构化数据来说，这种方法不太有用。<code>IndexedDB</code>提供了一个解决方案。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>为应用创建离线版本
</span></span></code></pre></td></tr></table></div></div><ul><li><code>cdn</code>域名不要带<code>cookie</code></li><li><code>localstorage</code>存库、图片</li></ul><p><code>cookie</code>种在主站下，二级域名也会携带这个域名，造成流量的浪费</p><a href=#service-worker产生的意义><h3 id=service-worker产生的意义><span class=hanchor arialabel=Anchor># </span>Service Worker产生的意义</h3></a><a href=#pwa与service-worker><h3 id=pwa与service-worker><span class=hanchor arialabel=Anchor># </span>PWA与Service Worker</h3></a><ul><li><code>PWA</code>(<code>Progressive Web Apps</code>)是一种<code>Web App</code>新模型，并不是具体指某一种前言的技术或者某一个单一的知识点，我们从英文缩写来看就能看出来，这是一个渐进式的<code>Web App</code>，是通过一系列新的<code>Web特性</code>，配合优秀的<code>UI</code>交互设计，逐步增强<code>Web App</code>的用户体验</li></ul><a href=#chrom插件lighthouse><h4 id=chrom插件lighthouse><span class=hanchor arialabel=Anchor># </span>chrom插件lighthouse</h4></a><blockquote><p>检测是不是一个渐进式<code>web app</code></p></blockquote><ul><li>当前手机在弱网环境下能不能加载出来</li><li>离线环境下能不能加载出来</li></ul><blockquote><p>特点</p></blockquote><ul><li>可靠：没有网络的环境中也能提供基本的页面访问，而不会出现“未连接到互联网”的页面</li><li>快速：针对网页渲染及网络数据访问有较好的优化</li><li>融入(<code>Engaging</code>)：应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性</li></ul><a href=#service-worker><h4 id=service-worker><span class=hanchor arialabel=Anchor># </span>service worker</h4></a><blockquote><p><code>service worker</code>是一个脚本，浏览器独立于当前页面，将其在后台运行，为实现一些不依赖页面的或者用户交互的特性打开了一扇大门。在未来这些特性将包括消息推送，背景后台同步，<code>geofencing</code>(地理围栏定位)，但他将推出的第一个首要的特性，就是拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。</p></blockquote><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/notes/frontend/browser/20210410172135 width=auto alt=img></p><a href=#案例分析><h4 id=案例分析><span class=hanchor arialabel=Anchor># </span>案例分析</h4></a><p><a href=https://juejin.im/post/5ba0fe356fb9a05d2c43a25c rel=noopener>Service Worker学习与实践</a></p><p><a href=http://kailian.github.io/2017/03/01/service-worker#%f0%9f%90%89 rel=noopener>了解servie worker</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>chrome://serviceworker-internals/`  
</span></span><span class=line><span class=cl> `chrome://inspect/#service-worker/
</span></span></code></pre></td></tr></table></div></div><p><code>service worker</code>网络拦截能力，存储<code>Cache Storage</code>，实现离线应用</p><a href=#service-worker离线应用><h4 id=service-worker离线应用><span class=hanchor arialabel=Anchor># </span>Service Worker离线应用</h4></a><p><code>serviceworker</code>需要<code>https</code>协议</p><a href=#如何实现serviceworker与主页面之间的通信><h4 id=如何实现serviceworker与主页面之间的通信><span class=hanchor arialabel=Anchor># </span>如何实现ServiceWorker与主页面之间的通信</h4></a><p>[lavas](</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/%E5%89%8D%E7%AB%AF/ data-ctx=browser data-src=/%E5%89%8D%E7%AB%AF class=internal-link>前端</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://jieye-ericx.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Jieye ericx using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://jieye-ericx.github.io/>Home</a></li><li><a href=https://github.com/jieye-ericx>Github</a></li></ul></footer></div></div></body></html>