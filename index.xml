<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AboutTheGarden on</title><link>https://jieye-ericx.github.io/</link><description>Recent content in AboutTheGarden on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://jieye-ericx.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://jieye-ericx.github.io/RPC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/RPC/</guid><description>这个基于 JSON 的序列化器有一个毛病，就是在某个类的属性反序列化时，如果属性声明为 Object 的，就会造成反序列化出错，通常会把 Object 属性直接反序列化成 String 类型，就需要其他参数辅助序列化。并且，JSON 序列化器是基于字符串（JSON 串）的，占用空间较大且速度较慢。</description></item><item><title/><link>https://jieye-ericx.github.io/TCP-%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/TCP-%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6/</guid><description>当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头和 TCP 头，但却没有携带数据报文。为了解决 ACK 传输效率低问题，所以就衍生出了 TCP 延迟确认。 TCP 延迟确认的策略：
当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</description></item><item><title/><link>https://jieye-ericx.github.io/time_await/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/time_await/</guid><description>主动关闭连接的，才有 TIME_WAIT 状态。
可以看到，TIME_WAIT 是「主动关闭方」断开连接时的最后一个状态，该状态会持续 2 [[MSL]] (Maximum Segment Lifetime) 时长，之后进入 CLOSED 状态。
为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续 2MSL 时长，这个时间足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。 如果客户端（主动关闭方）最后一次 ACK 报文（第四次挥手）在网络中丢失了，那么按照 TCP 可靠性原则，服务端（被动关闭方）会重发 FIN 报文。 假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSED 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。 服务端收到这个 RST 并将其解释为一个错误（Connection reset by peer），这对于一个可靠的协议来说不是一个优雅的终止方式。 为了防止这种情况出现，客户端必须等待足够长的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。</description></item><item><title/><link>https://jieye-ericx.github.io/UDP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/UDP/</guid><description>[[实现可靠传输]]</description></item><item><title/><link>https://jieye-ericx.github.io/%E4%B8%8Equic%E5%8D%8F%E8%AE%AETLS%E6%8F%A1%E6%89%8B%E6%AC%A1%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E4%B8%8Equic%E5%8D%8F%E8%AE%AETLS%E6%8F%A1%E6%89%8B%E6%AC%A1%E6%95%B0/</guid><description/></item><item><title/><link>https://jieye-ericx.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</guid><description>分布式系统 分布式数据库 数据分片 （水平分片 垂直分片）
分片算法 高可用 复制
单主复制 多主复制 错误侦测 心跳检测法 Gossip 协议检测 φ 值检测 存储引擎 LSM树 评价存储引擎</description></item><item><title/><link>https://jieye-ericx.github.io/%E5%89%91%E6%8C%87Offer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%89%91%E6%8C%87Offer/</guid><description>剑指Offer 1. 替换空格 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
1 2 3 4 5 class Solution { public: void replaceSpace(char *str,int length) { } }; 这题其实就是在给定地str中找到空格，并替换成%20，由于是一个字符替换成三个字符，所以需要移动元素，如果从前往后移动，假设有n个空格，则第n个空格后面的元素都要被移动n次，很浪费时间，所以从后往前移动，并且不需要额外的数组，先计算出填补后的长度`newlength=oldnumber+n*2`,然后从后遍历直接`str[pNewlength--]=str[pOldlength];` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: void replaceSpace(char *str,int length) { if (str == NULL || length &amp;lt; 0) return; int i=0,oldLength=strlen(str),newLength=0,blanks=0; while(str[i]!</description></item><item><title/><link>https://jieye-ericx.github.io/%E5%A4%9A%E6%80%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%A4%9A%E6%80%81/</guid><description>被问到的
多态在 Java 技术里有很重要的地位，在面试中也会经常被问到。
1．Java多态概述
Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但可具有不同的参数列表、返回值类型。调用方法时通过传递的参数类型来决定具体使用哪个方法，这就是多态性。
Java的方法重写，是父类与子类之间的多态性，子类可继承父类中的方法，但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。重写的参数列表和返回类型均不可修改。
2．方法重写后的动态绑定
多态允许具体访问时实现方法的动态绑定。Java对于动态绑定的实现主要依赖于方法表，通过继承和接口的多态实现有所不同。
继承：在执行某个方法时，在方法区中找到该类的方法表，再确认该方法在方法表中的偏移量，找到该方法后如果被重写则直接调用，否则认为没有重写父类该方法，这时会按照继承关系搜索父类的方法表中该偏移量对应的方法。
接口：Java 允许一个类实现多个接口，从某种意义上来说相当于多继承，这样同一个接口的的方法在不同类方法表中的位置就可能不一样了。所以不能通过偏移量的方法，而是通过搜索完整的方法表。
3．JVM的结构（拓展知识，不了解可以看看） TODO 从上图可以看出，当程序运行需要某个类时，类加载器会将相应的class文件载入到JVM中，并在方法区建立该类的类型信息（包括方法代码，类变量、成员变量、以及本博文要重点讨论的方法表）。 注意，这个方法区中的类型信息跟在堆中存放的class对象是不同的。在方法区中，这个class的类型信息只有唯一的实例（所以方法区是各个线程共享的内存区域），而在堆中可以有多个该class对象。可以通过堆中的class对象访问到方法区中类型信息。就像在java反射机制那样，通过class对象可以访问到该类的所有信息一样。
方法表是实现动态调用的核心。为了优化对象调用方法的速度，方法区的类型信息会增加一个指针，该指针指向记录该类方法的方法表，方法表中的每一个项都是对应方法的指针。这些方法中包括从父类继承的所有方法以及自身重写（override）的方法。
4．Java 的方法调用方式 Java 的方法调用有两类，动态方法调用与静态方法调用。</description></item><item><title/><link>https://jieye-ericx.github.io/%E7%99%BD%E6%9D%BF-2023-05-02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%99%BD%E6%9D%BF-2023-05-02/</guid><description>==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==
Text Elements %%
Drawing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 N4KAkARALgngDgUwgLgAQQQDwMYEMA2AlgCYBOuA7hADTgQBuCpAzoQPYB2KqATL ZMzYBXUtiRoIACyhQ4zZAHoFAc0JRJQgEYA6bGwC2CgF7N6hbEcK4OCtptbErHAL RY8RMpWdx8Q1TdIEfARcZgRmBShcZQUARm0ADm0eADYaOiCEfQQOKGZuAG1wMFAw MogSbggANQArAHkATgAlAGkAFQBJAC1OuA4ADQAxBAAzZQBNAHV2gEV0sshYRCrA 7CiOZWCF8sxuZ1iAVniUgGYeBNieQ/5ymH2ea+0Ui8aABheb4sgKEnVuWJvHjaU7 HQ6fW6QSQIQjKaTcADshxBKQRsQSSMhEGsW3EqDeWOYUFIbAA1ggAMJsfBsUhVAD EbyZzJ2kE0uGwpOUJKEHGIVJpdIkxOszDguECuVZEFGhHw+AAyrBthJJByNIFpUS SeSpn9JADCcSyQglTAVehBB5pTy4Rxwvk0LEsWxxdg1PcnUysdzhHBOsRHagCgBd LE8vn25hB0qLaDwPGnb4AX0JCAQxABABYUuizjms1jGCx2Fw0Kdnd8GExWJwAHKc MTcLMIlJvWKNNtYwjMAAimSgGe4owIYSxmmEfIAosFsrkgxwhPKsUI4MRcIPM06U glTkDYi2Eu8EliiBxSdxF8uqzTOUO0CP8GFisnwGG6Lg4HAlRu8bHoNC2RVEQcJQ DsDCEAgFAAEIclyEb8tStIMqMqFoeB2AiJKUCdIO+hKjqlJIUK6CMsyTIYVhOQ4X hsGcr6vKIYKVQihwYoStRlGkNhuFZEMcqKsqeJSOqIhILcECYdx1G8fhxq6vqhrF JJVG5LJBEmmaFoQFalQSVJPF4c0wh2g6SnlAZMl4fUboegC3rKZZal4UMnBQEMuD 6HKnqoJWFmqTRfFuQqhBGHiPAEo5AWye0WBQAAgiBZboMEoxgfp0V4T+pAJdxbAU NCuBbqgV74Bl0nOVkU58vFeUFSExXYnV4HMNgJLygM3CnI0fDKa17X4BMXWNMiR4 JFmpyYspRhsAY3CxpA9AEEIeKxC+5WGVkxmMVGQYQAh4HciQIVhZeS5lY5xEAAoE AgMh/qmUUVVAGnkjZUClgu50SXAgRmMIzAAOKkMdoV4qV4CPZAsrBDGr7JkAA=== %%</description></item><item><title/><link>https://jieye-ericx.github.io/%E7%99%BD%E6%9D%BF-2023-05-16/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%99%BD%E6%9D%BF-2023-05-16/</guid><description>==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==
Text Elements %%
Drawing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 N4KAkARALgngDgUwgLgAQQQDwMYEMA2AlgCYBOuA7hADTgQBuCpAzoQPYB2KqATL ZMzYBXUtiRoIACyhQ4zZAHoFAc0JRJQgEYA6bGwC2CgF7N6hbEcK4OCtptbErHAL RY8RMpWdx8Q1TdIEfARcZgRmBShcZQUARm0ATm1YmjoghH0EDihmbgBtcDBQMBKI Em4IChgATQB9AEkoAEEAMzh6AHEAFQAWXAAOAFkAaQTa2qbUkshYRArA7CiOZWCp 0sxuZ1ieADZtHoB2HYBWHZ5j/lKYTZ7+pNiDhJ3+g4vCyAoSdW5Y/uPtA6AgDMPS Br0ukEkCEIymkPx28QS/X6PH62ze0wg1hW4lQAAYIRBmFBSGwANYIADCbHwbFIFQ AxHjmSy1pBNLhsGTlKShBxiNTafSJCTrMw4LhAtk2RAWoR8PgAMqwVYSSScjSBGX E0kUgDqX0kP0JOvJCGVMFV6EEHhlvNhHHCuTQsUJbAl2DU1xdzMJPOEcHqxGdqDy AF1Cbz+Y7mCHipjZrige8AL4mhAIYjcZ4JMGPBJ8d4MJisTjcHoJQmMFjsDgAOU4 Yh+BzxxyBdx4PQJRcIzAAIukoJnuC0CGFCZphPyAKLBTLZEMFaZFd6lcoSACK3iB QLrlIAUgAtBC1AAyAAlJOfMPuzvpJhDSomKpLSVRVyn3hGi0I4MRcEOWYus8PTnD wQIIsi3aYkQHBktwHBCAqhK0lyw5oKO+BhIUaaFPGkDrugW5wDue5HieF5Xjed4P kWz4SK+bBUISGxoM4YL7D0bbooS3qoM4txJMcxx/Lm4JFp8xDfMBeLaMJPTPOJmJ QjCcJoDsBzaECPB4kCPFFtiVrQaUpoUoKdKMiyrITpy3JRgKNIWSK5AcOKkpZFAM pygqFpWlIGoiEgJokmaBpSUaLrBbq5oqriRI0uUkbCA6TrGkW7qcl6Py+kW/q/kG i7fpi9kxnGq7QPAuI8Km6boag2wJAcXbtrcVYlrW3DHAcbU1pwDYcE2aBdccsTaQ iOyEr2A7BIBI5jggE5TsQs4ZB5IaIchP5/gBdWxCBYEQb8/TGZAsHwWgG34ChbBo UBqCYeORZwGwhALvkq5LsuJ0lHiq5FdMn3THtsnyYpGLLs4GlaTpennH9X4oaEUD Uvo+hqIBAAKL3ShdSFXUWxKSlAABCr2OMs3D4ZA6TzlAQYVFUdSNK07TdH0QyjOM tHLrKN1CCGziyTsCSxAWukvECeIi083XlcouBwD8NVFlkxCk/yr3KAhePBUTTSkG +UK4Hdl2Eqr+uGyEd1YgbTEQDhlz4WU1s7AgdYAI5ktUmApIS9HoEOmCeSxmztnJ Lx3HiZzg5AfECTp2jPKDLwx5UhrZYSKmwp5aDnIShm4idRIhWZjnCugTJWXiMocl yeX8uZ5fQC5blSsHRbeUqsUVOq2CakFBMlwgYXSfVUVmr5cU2olRb2pIpVpZiGWe rA2VF3lgbBvk/2QCVqW45tmJhHVEFdWCXZF9WpZcLnPXX/1g2oMcub9Npo0TT2/a DnVJJCAtRaTj5MtOca1taH1KL+f8s1gL9FAsccCz9YhdRQq9c6qBTZFlQhSO6D1/ 4JiwDndAdpKBdAIRULynAoCKkIEYKqRcWiUIAGK4DRvgPiro6IEKaEQZQN90BiGy EwGU1YoDmAINwmEfCIBo2IMQVYNkwiwVxL8Qkehsi4FekwemEhGYNGaG0TovQBgj DGBMGUdIYSvQIKQoO5CUGOnPNCbOPxtBwxKJ+MARUsRwDgMqHalNCjQChJkCo/5S DwUuAwQgCAKDE1svXByQpGQtBSaktYEBsAiDbo0DIypoqN0slXdJmSDYeRyfoOJd d7IFOcmKCUbdilZLKUOfQjD5Rd0tHFXu/dGmlOyOUvJoV06RUCSU7JLTBkUknhUa eWZIljOaRkAASslee+8x6jKaf0lpAB5D0WUfTGQyVsumLTGFMJYfKdh8yTnlPOdk ahtDuA6RuX005GQbHNB4VI4ILR26lAWds3JURSDNFthQI2JsdabLeeU6c/ILZMUh S+cF6TmDYFJAqAAGuWdskT0WYvwNUbgBwIJaRGqcPOgSjBsAMAEzE9ACB/yVu415 4zllLQXhIey6SeQkEebiDBAKy4YwIAgGQuJgC4QBScyZCA9miM4OtaFpQ4CBDMMI ZgHRSD8poYKvG4BpWynlOESmn4UxAA== %%</description></item><item><title/><link>https://jieye-ericx.github.io/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description> 动态化线程池算是当前的趋势 可以将线程池的参数从代码中迁移到分布式配置中心上，实现线程池参数可动态配置和即时生效
简化线程池配置：线程池构造参数有8个，但是最核心的是3个：corePoolSize、maximumPoolSize，workQueue，它们最大程度地决定了线程池的任务分配和线程分配策略。考虑到在实际应用中我们获取并发性的场景主要是两种：（1）并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行。（2）并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。所以线程池只需要提供这三个关键参数的配置，并且提供两种队列的选择，就可以满足绝大多数的业务需求，Less is More。 参数可动态修改：为了解决参数不好配，修改参数成本高等问题。在Java线程池留有高扩展性的基础上，封装线程池，允许线程池监听同步外部的消息，根据消息进行修改配置。将线程池的配置放置在平台侧，允许开发同学简单的查看、修改线程池配置。 增加线程池监控：对某事物缺乏状态的观测，就对其改进无从下手。在线程池执行任务的生命周期添加监控能力，帮助开发同学了解线程池状态。</description></item><item><title/><link>https://jieye-ericx.github.io/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/</guid><description/></item><item><title/><link>https://jieye-ericx.github.io/%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</guid><description>QPS QPS Queries Per Second 是每秒查询率 ,是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准, 即每秒的响应请求数，也即是最大吞吐能力。
TPS TPS Transactions Per Second 也就是事务数/秒。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，
PV PV （Page View）：页面访问量，即页面浏览量或点击量，用户每次刷新即被计算一次。可以统计服务一天的访问日志得到。
UV UV （Unique Visitor）：独立访客，统计1天内访问某站点的用户数。可以统计服务一天的访问日志并根据用户的唯一标识去重得到。响应时间（RT）：响应时间是指系统对请求作出响应的时间，一般取平均响应时间。可以通过Nginx、Apache之类的Web Server得到。</description></item><item><title>1 MySQL的数据目录</title><link>https://jieye-ericx.github.io/1-MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/1-MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</guid><description>1 MySQL的数据目录 1 MySQL8的主要目录结构 数据库文件目录 1 2 3 4 5 6 7 mysql&amp;gt; show variables like &amp;#39;datadir&amp;#39;; +---------------+-----------------+ | Variable_name | Value | +---------------+-----------------+ | datadir | /var/lib/mysql/ | +---------------+-----------------+ 1 row in set (0.</description></item><item><title>1. Scikit-learn与特征工程</title><link>https://jieye-ericx.github.io/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/</guid><description>1. Scikit-learn与特征工程 数据决定了机器学习的上限，而算法只是尽可能逼近这个上限”，这句话很好的阐述了数据在机器学习中的重要性。大部分直接拿过来的数据都是特征不明显的、没有经过处理的或者说是存在很多无用的数据，那么需要进行一些特征处理，特征的缩放等等，满足训练数据的要求。
我们将初次接触到Scikit-learn这个机器学习库的使用
Scikit-learn
Python语言的机器学习工具 所有人都适用，可在不同的上下文中重用 基于NumPy、SciPy和matplotlib构建 开源、商业可用 - BSD许可 目前稳定版本0.18 自2007年发布以来，scikit-learn已经成为最给力的Python机器学习库（library）了。scikit-learn支持的机器学习算法包括分类，回归，降维和聚类。还有一些特征提取（extracting features）、数据处理（processing data）和模型评估（evaluating models）的模块。作为Scipy库的扩展，scikit-learn也是建立在Python的NumPy和matplotlib库基础之上。NumPy可以让Python支持大量多维矩阵数据的高效操作，matplotlib提供了可视化工具，SciPy带有许多科学计算的模型。 scikit-learn文档完善，容易上手，丰富的API，使其在学术界颇受欢迎。开发者用scikit-learn实验不同的算法，只要几行代码就可以搞定。scikit-learn包括许多知名的机器学习算法的实现，包括LIBSVM和LIBLINEAR。还封装了其他的Python库，如自然语言处理的NLTK库。另外，scikit-learn内置了大量数据集，允许开发者集中于算法设计，节省获取和整理数据集的时间。</description></item><item><title>1.数据类型</title><link>https://jieye-ericx.github.io/Redis%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Redis%E5%8E%9F%E7%90%86/</guid><description>1.数据类型 1 Redis键(key) keys 查看当前库所有key (匹配：keys 1)
exists key判断某个key是否存在
type key 查看你的key是什么类型
del key 删除指定的key数据
unlink key 根据value选择非阻塞删除
仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</description></item><item><title>11 数据库设计规范（范式）</title><link>https://jieye-ericx.github.io/11-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E8%8C%83%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/11-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E8%8C%83%E5%BC%8F/</guid><description>1 为什么需要数据库设计 2 范 式 2.1 范式简介 在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。可以理解为，一张数据表的设计结
构需要满足的某种设计标准的 级别 。要想设计一个结构合理的关系型数据库，必须满足一定的范式。
2.2 范式都包括哪些 目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（
1NF）、第二范式
（
2NF）、第三范式（
3NF）、巴斯-科德范式（
BCNF）、第四范式(4NF）和第五范式（
5NF，又称完美</description></item><item><title>13 事务基础知识</title><link>https://jieye-ericx.github.io/13-%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/13-%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>1 数据库事务概述 1.1 存储引擎支持情况 SHOW ENGINES 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。
能看出在 MySQL 中，只有InnoDB 是支持事务的。
1.2 基本概念 事务：一组逻辑操作单元，使数据从一种状态变换到另一种状态。
事务处理的原则：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(ollback )到最初状态。</description></item><item><title>15 锁</title><link>https://jieye-ericx.github.io/15-%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/15-%E9%94%81/</guid><description>事务的隔离性由这章讲述的锁来实现
1 概述 在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对并发操作进行控制 ，因此产生了锁 。同时锁机制 也为实现MySQL的各个隔离级别提供了保证。锁冲突也是影响数据库并发访问性能的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。
2 MySQL并发事务访问相同记录 并发事务访问相同记录的情况大致可以划分为3种：
2.1 读-读情况 读-读情况，即并发事务相继读取相同的记录。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。
2.2 写-写情况 写-写情况，即并发事务相继对相同的记录做出改动。
在这种情况下会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的，如图所示：
当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。比如，事务T1要对这条记录做改动，就需要生成一个锁结构与之关联：
在锁结构里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来：
trx信息：代表这个锁结构是哪个事务生成的。 is_waiting ：代表当前事务是否在等待。</description></item><item><title>16 多版本并发控制</title><link>https://jieye-ericx.github.io/16-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/16-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</guid><description>1 什么是 MVCC MVCC（Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的并发控制。这项技术使得在InnoDB的事务隔离级别下执行一致性读 操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。
2 快照读与当前读 MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读,而这个读指的就是快照读, 而非 当前读。当前读实际上是一种加锁的操作，是悲观锁的实现,而MVCC本质是采用乐观锁思想的一种方式。
2.1 快照读 快照读又叫一致性读，读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，即不加锁的非阻塞读,比如这样：SELECT * FROM player WHERE …,之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。</description></item><item><title>17 其他数据库日志</title><link>https://jieye-ericx.github.io/17-%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/17-%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97/</guid><description>我们在讲解数据库事务时，讲过两种日志：重做日志、回滚日志。
对于线上数据库应用系统，突然遭遇数据库宕机,怎么办？在这种情况下，定位宕机的原因 就非常关键。我们可以查看数据库的错误日志。因为日志中记录了数据库运行中的诊断信息，包括了错误、警告和注释等信息。比如：从日志中发现某个连接中的 SQL操作发生了死循环，导致内存不足，被系统强行终止了。明确了原因，处理起来也就轻松了，系统很快就恢复了运行。
除了发现错误，日志在数据复制、数据恢复、操作审计，以及确保数据的永久性和一致性等方面，都有着不可替代的作用。
MysQL8.0官网日志地址：“https://dev.mysql.com/doc/refman/8.0/en/server-logs.html”
1 MySQL支持的日志 1.1 日志类型 MySQL有不同类型的日志文件，用来存储不同类型的日志，分为 二进制日志 、 错误日志 、 通用查询日志和 慢查询日志 ，这也是常用的4种。MySQL 8又新增两种支持的日志： 中继日志 和 数据定义语句日志 。使用这些日志文件，可以查看MySQL内部发生的事情。</description></item><item><title>2 用户与权限管理</title><link>https://jieye-ericx.github.io/2-%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/2-%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</guid><description>2 用户与权限管理 1 用户管理 1.1 登录MySQL服务器 mysql –h hostname|hostIP –P port –u username –p DatabaseName –e &amp;quot;SQL语句&amp;quot;
参数：
-h参数 后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。 -P参数 后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306，</description></item><item><title>3 逻辑架构</title><link>https://jieye-ericx.github.io/3-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/3-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</guid><description>1 逻辑架构剖析 1.1 服务器处理客户端请求 服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢?这里以查询请求为例展示:
1.2 Connectors 1.3 第1层:连接层 系统(客户端)访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。 经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。</description></item><item><title>6 索引的数据结构</title><link>https://jieye-ericx.github.io/6-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/6-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>6 索引的数据结构 1. 为什么使用索引 索弓是存储弓|擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分， 通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL 中也是一样的道理， 进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。
假如给数据使用 二叉树 这样的数据结构进行存储，如下图所示
二叉搜索树， 采用这种存储结构搜索数据的时间，复杂度是 log2N。
2. 索引及其优缺点 2.1 索引概述 MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。</description></item><item><title>9 性能分析工具的使用</title><link>https://jieye-ericx.github.io/9-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/9-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>9 性能分析工具的使用 1.数据库服务器的优化步骤 当我们遇到数据库调优问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。 整个流程划分成了 观察（Show status） 和 行动（Action） 两个部分。字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。
我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的SQL都有哪些，查看具体的SQL执行计划，甚至是SQL执行中的每一步的成本代价， 这样才能定位问题所在，找到了问题，再采取相应的行动。
详细解释一下这张图:
首先在S1部分，我们需要观察服务器的状态是否存在周期性的波动。如果存在周期性波动，有可能是周期性节点的原因，比如双十一、促销活动等。这样的话，我们可以通过A1这一步骤解决，也就是加缓存，或者更改缓存失效策略。 如果缓存策略没有解决，或者不是周期性波动的原因，我们就需要进一步分析查询延迟和卡顿的原因。接下来进入S2这一步,我们需要开启慢查询。慢查询可以帮我们定位执行慢的SQL语句。我们可以通过设置long_ query_ time参数定义“慢”的阈值，如果SQL执行时间超过了long_query_time, 则会认为是慢查询。当收集上来这些慢查询之后，我们就可以通过分析工具对慢查询日志进行分析。 在S3这一步骤中，我们就知道了执行慢的SQL,这样就可以针对性地用EXPLAIN查看对应SQL语句的执行计划，或者使用show profile 查看SQL中每个步骤的时间成本。这样我们就可以了解SQL查询慢是因为执行时间长，还是等待时间长。 如果是SQL等待时间长，我们进入A2步骤。在这一步骤中， 我们可以调优服务器的参数，比如适当增加数据库缓冲池等。 如果是SQL执行时间长，就进入A3步骤,这一步中我们需要考虑是索引设计的问题?</description></item><item><title>browser</title><link>https://jieye-ericx.github.io/browser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/browser/</guid><description>JS 的单线程 很多人都知道的是，JavaScript 是一门动态的解释型的语言，具有跨平台性。在被问到 JavaScript 为什么是一门单线程的语言，有的人可能会这么回答：“语言特性决定了 JavaScript 是一个单线程语言，JavaScript 天生是一个单线程语言”，这只不过是一层糖衣罢了。
JavaScript 从诞生起就是单线程，原因大概是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。
准确的来说，我认为 JavaScript 的单线程是指 JavaScript 引擎是单线程的，JavaScript 的引擎并不是独立运行的，跨平台意味着 JavaScript 依赖其运行的宿主环境 &amp;mdash; 浏览器(大部分情况下是浏览器)。</description></item><item><title>canvas</title><link>https://jieye-ericx.github.io/Canvas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Canvas/</guid><description>canvas &amp;lt;canvas&amp;gt; 是 HTML5 新增的元素，可用于通过使用JavaScript中的脚本来绘制图形，创建动画。&amp;lt;canvas&amp;gt; 最早由Apple引入WebKit.
我们可以使用&amp;lt;canvas&amp;gt;标签来定义一个canvas元素。
canvas元素默认具有高宽
width： 300px
height：150px
1.整体API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 1.</description></item><item><title>CDN</title><link>https://jieye-ericx.github.io/CDN/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/CDN/</guid><description>一、什么是 CDN CDN 的全称是(Content Delivery Network)，即内容分发网络。其目的是通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因，提高用户访问网站的响应速度。
简单的说，CDN 的工作原理就是将您源站的资源缓存到位于全球各地的 CDN 节点上，用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都回您的源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验。
CDN 对网络的优化作用主要体现在如下几个方面
解决服务器端的“第一公里”问题 缓解甚至消除了不同运营商之间互联的瓶颈造成的影响 减轻了各省的出口带宽压力 缓解了骨干网的压力 优化了网上热点内容的分布 二、CDN工作原理 传统访问过程</description></item><item><title>CSRFXSS</title><link>https://jieye-ericx.github.io/CSRFXSS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/CSRFXSS/</guid><description>CSRF 跨站请求伪造（Cross Site Request Forgery），是指黑客诱导用户打开黑客的网站，在黑客的网站中，利用用户的登陆状态发起的跨站请求。CSRF攻击就是利用了用户的登陆状态，并通过第三方的站点来做一个坏事。
要完成一次CSRF攻击,受害者依次完成两个步骤:
登录受信任网站A，并在本地生成Cookie 在不登出A的情况，访问危险网站B CSRF攻击
在a.com登陆后种下cookie, 然后有个支付的页面，支付页面有个诱导点击的按钮或者图片，第三方网站域名为 b.com，中的页面请求 a.com的接口，b.com 其实拿不到cookie，请求 a.com会把Cookie自动带上（因为Cookie种在 a.com域下）。这就是为什么在服务端要判断请求的来源，及限制跨域（只允许信任的域名访问），然后除了这些还有一些方法来防止 CSRF 攻击，下面会通过几个简单的例子来详细介绍 CSRF 攻击的表现及如何防御。</description></item><item><title>css</title><link>https://jieye-ericx.github.io/css/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/css/</guid><description>1. 怎么让一个 div 水平垂直居中 1 2 3 &amp;lt;div class=&amp;#34;parent&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 简单粗暴
1 2 3 4 5 6 7 8 9 10 11 12 div.</description></item><item><title>CSS3</title><link>https://jieye-ericx.github.io/CSS3-no/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/CSS3-no/</guid><description>CSS3 优势：
使用CSS3技术来控制页面元素CSS属性的变化 不需要js也能写 由浏览器执行，更加流畅 减少代码量 应用场景：
网页特效 用户交互 抽奖动画 网页小游戏 transition transition CSS 属性是 transition-property， transition-duration， transition-timing-function 和 transition-delay 的一个 简写属性。</description></item><item><title>Dataview</title><link>https://jieye-ericx.github.io/Dataview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Dataview/</guid><description>我的理解是将每一篇文章理解成一个数据库，借助编程语言可以实现高级自动化
1 2 3 4 5 6 7 8 9 10 ```dataviewjs var list=dv.pages(`&amp;#34;Notes/报告&amp;#34;`) for(let e of list){ if(e.title!==&amp;#34;💽博文分享&amp;#34;){ dv.</description></item><item><title>Docker基础</title><link>https://jieye-ericx.github.io/Docker%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Docker%E5%9F%BA%E7%A1%80/</guid><description>1 Docker简介 1.1 为什么会有docker？ 一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验
Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。
环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装?也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用Docker可以消除协作编码时“在我的机器上可正常工作”的问题。
之前在服务器配置一个应用的运行环境，要安装各种软件，就拿尚硅谷电商项目的环境来说，Java/TomcatMySQL/JDBC驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在Windows上安装的这些环境，到了Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。
传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等java为例)。而为了让这程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker镜 像的设计，使得Docker得以打过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运.作。
1.2 docker理念 Docker是基于Go语言实现的云开源项目。
Docker的主要目标是“Build, Ship[ and Run Any App,Anywhere&amp;quot;，也就是通过对应用组件的封装、分发、部署、运行等生命期的管理，使用户的APP (可以是一个WEB应用或数据库应用等等)及其运行环境能够做到“一次封装，到处运行”。</description></item><item><title>ESLint</title><link>https://jieye-ericx.github.io/ESLint/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/ESLint/</guid><description>关于 ESLint 关于 ESLint，它的 Slogan 是 Find and fix problems in your JavaScript code。如上文所说，它可以发现并修复你 JavaScript 代码中的问题。来看一下官网上描述 ESLint 具备的三个特性：
Find Problems。ESLint 通过静态代码分析可以快速发现代码中的问题。ESLint 可以运行在大多数文本编辑器中，并且也可以在工作流中接入 ESLint Fix Automatically。ESLint 发现的很多问题都可以自动修复 Customize。可以定制 ESLint 检查规则 基于以上描述，我们在前端工程化中可以这样使用 ESLint：</description></item><item><title>fast open</title><link>https://jieye-ericx.github.io/fast-open/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/fast-open/</guid><description/></item><item><title>Go</title><link>https://jieye-ericx.github.io/Go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Go/</guid><description>输入输出 https://blog.csdn.net/weixin_44211968/article/details/124632136
字节 byte 类型也属于整型
证明了基于数组的切片，使用的底层数组还是原来的数组，一旦修改切片的元素值，那么底层数组对应的值也会被修改。
1.GMP goroutine machine processor 通知协程退出的方式 通过全局变量：如果全局变量为真就退出
如果worker中再启动goroutine，就不太好控制了 通过通道：协程在通道里面取到true就退出
使用全局变量在跨包调用时不容易实现规范和统一，需要维护一个共用的channel 通过context：通过调用ctx.Done()方法通知所有的协程退出
当子goroutine又开启另外一个goroutine时，只需要将ctx传入即可 context.</description></item><item><title>GYM</title><link>https://jieye-ericx.github.io/GYM/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/GYM/</guid><description>Env 首先我们可以通过如下代码调用并展示（可视化）一个环境：
1 2 3 4 5 6 7 import gym env = gym.make(&amp;#39;CartPole-v0&amp;#39;) env.reset() for _ in range(1000): env.</description></item><item><title>hexo二次元看板娘初探</title><link>https://jieye-ericx.github.io/hexo%E4%B9%8B%E7%9C%8B%E6%9D%BF%E5%A8%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/hexo%E4%B9%8B%E7%9C%8B%E6%9D%BF%E5%A8%98/</guid><description>hexo二次元看板娘初探 基本配置好hexo后，便迫不及待地想把这萌萌的东西放在自己的博客中，配置使用整理一哈~
安装 ^93febc
根据其 官方文档的描述：
1 npm install --save hexo-helper-live2d 安装后打开博客，就能发现默认的看板娘已经出现在页面中了。
配置 整理了一份基本配置，放置在根目录下的_config.yml中：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # Live2D## https://github.</description></item><item><title>HOMEPAGE</title><link>https://jieye-ericx.github.io/HOMEPAGE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/HOMEPAGE/</guid><description>最近编辑的笔记 1 2 3 4 table WITHOUT ID file.link AS &amp;#34;最近编辑过的笔记&amp;#34;,file.mtime as &amp;#34;时间&amp;#34; from &amp;#34;&amp;#34; sort file.mtime desc limit 5 ^427b8c</description></item><item><title>html</title><link>https://jieye-ericx.github.io/html/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/html/</guid><description>iframe框架有那些优缺点 优点：
iframe能够原封不动的把嵌入的网页展现出来。 如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。 缺点：
搜索引擎的爬虫程序无法解读这种页面 框架结构中出现各种滚动条 使用框架结构时，保证设置正确的导航链接。 iframe页面会增加服务器的http请求 label标签有什么作用 label 标签通常是写在表单内，它关联一个控件，使用 label 可以实现点击文字选取对应的控件。</description></item><item><title>html</title><link>https://jieye-ericx.github.io/Html%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Html%E5%9F%BA%E7%A1%80/</guid><description>h5的文档声明，声明当前的网页是按照HTML5标准编写的
编写网页时一定要将h5的文档声明写在网页的最上边
如果不写文档声明，则会导致有些浏览器会进入一个怪异模式，
进入怪异模式以后，浏览器解析页面会导致页l面无法正常显示，所以为了避免进入该模式，一定要写文档声明
1 &amp;lt;!doctype *html*&amp;gt; 实体 1 2 3 4 5 6 7 8 9 10 11 12 13 &amp;lt;!</description></item><item><title>HTTP</title><link>https://jieye-ericx.github.io/HTTP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/HTTP/</guid><description>特性 keepalive 在第一个 HTTP 请求完后，先不断开 TCP 连接，让后续的 HTTP 请求继续使用此连接？当然可以，HTTP 的 Keep-Alive 就是实现了这个功能，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，避免了连接建立和释放的开销，这个方法称为 HTTP 长连接。HTTP 1.</description></item><item><title>Image</title><link>https://jieye-ericx.github.io/Image/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Image/</guid><description>一、基础知识 1.1 位图 「位图图像（bitmap），亦称为点阵图像或栅格图像，是由称作像素（图片元素）的单个点组成的。」 这些点可以进行不同的排列和染色以构成图样。当放大位图时，可以看见赖以构成整个图像的无数单个方块。扩大位图尺寸的效果是增大单个像素，从而使线条和形状显得参差不齐。
「用数码相机拍摄的照片、扫描仪扫描的图片以及计算机截屏图等都属于位图。」 位图的特点是可以表现色彩的变化和颜色的细微过渡，产生逼真的效果，缺点是在保存时需要记录每一个像素的位置和颜色值，占用较大的存储空间。常用的位图处理软件有 Photoshop、Painter 和 Windows 系统自带的画图工具等。
分辨率是位图不可逾越的壁垒，在对位图进行缩放、旋转等操作时，无法生产新的像素，因此会放大原有的像素填补空白，这样会让图片显得不清晰。
图中的小方块被称为像素，这些小方块都有一个明确的位置和被分配的色彩数值，小方格颜色和位置就决定该图像所呈现出来的样子。
可以将像素视为整个图像中不可分割的单位或者是元素。「不可分割的意思是它不能够再切割成更小单位抑或是元素，它是以一个单一颜色的小格存在。」 每一个点阵图像包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。
1.2 矢量图 所谓矢量图，就是使用直线和曲线来描述的图形，构成这些图形的元素是一些点、线、矩形、多边形、圆和弧线等，**「***它们都是通过数学公式计算获得的，具有编辑后不失真的特点。*」****例如一幅画的矢量图形实际上是由线段形成外框轮廓，由外框的颜色以及外框所封闭的颜色决定画显示出的颜色。
「矢量图以几何图形居多，图形可以无限放大，不变色、不模糊。」 常用于图案、标志、VI、文字等设计。常用软件有：CorelDraw、Illustrator、Freehand、XARA、CAD 等。</description></item><item><title>javascript</title><link>https://jieye-ericx.github.io/javascript/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/javascript/</guid><description>1. mouseenter和mouseover的区别 mouseover事件：不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。
mouseenter事件：只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。
以及
mouseout事件：不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件。
mouseleave事件：只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。
2. alert（1&amp;amp;&amp;amp;2），alert（1||0） &amp;amp;&amp;amp;运算符，前面的true，返回后面的。前面的为false，返回前面的。
||运算符，前面的为true，返回前面的。前面的为false，返回后面的。
3. 为什么TCP连接需要三次握手，两次不可以吗，为什么 感觉自己还没懂，先占坑，可看知乎</description></item><item><title>JavaScript 之混淆的“类”</title><link>https://jieye-ericx.github.io/JavaScript-%E4%B9%8B%E6%B7%B7%E6%B7%86%E7%9A%84%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/JavaScript-%E4%B9%8B%E6%B7%B7%E6%B7%86%E7%9A%84%E7%B1%BB/</guid><description>JavaScript之混淆的类 序言 学习JavaScript时，如果你已经对C++、Java等传统面向对象编程语言有一定了解，或者老师教导过你使用类(类是面向对象编程的实现核心)把过程化风格的代码转换成结构清晰的代码，那么你很自然地会想在js中使用类。如在万物皆为类的Java中，严格区分类和对象，对象由类实例化而成，继承实际上是类的扩展。但JavaScript中只有对象，没有类，这是本质上的区别，可在JavaScript中有许多模拟类的语法糖在试图掩盖这个事实，很多教程中并未对此作详细解释，而是直接教初学者使用这些语法糖，导致初学者会在无形中出现困惑。
虽然JavaScript中没有类，但俗话说“没有的才是最好的”，开发者们通过不断探索总结，成功地模拟出了“类”。由于大家定义类的方法五花八门，风格不一。对于模拟面向对象的封装、继承、多态，更有许多研究，实现办法更加晦涩，不利于JavaScript新手使用。
这就引出了本文的话题：JavaScript中类的机制。
类的封装、继承与多态 说到面向对象编程，不得不先了解类。
根据维基百科的定义，类(class)在面向对象编程中是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。有封装性、继承性、多态性三个最重要的特性。
类与继承抽象了一种代码的组织形式，一种编程领域对真实世界中问题的建模。比如，轮船可以被看做交通工具的一个特例，后者是更广泛的类，可以用Vehicle和Steamer两个类进行建模。Vehicle可以定义引擎、载人能力等几乎所有交通工具都具有的属性，而在具体的交通工具类中，定义同样的属性是没有意义的，所以在定义Steamer类时，只需声明它继承了Vehicle这个基类，那么它就能拥有基类的属性及方法。
有了Steamer类，就有了轮船的所有属性和行为，这便是类的封装。我们迫不及待地想上船航行，可类好比蓝图，正如轮船的图纸，并非真正可以交互的轮船，只有根据图纸建造出物理实物，才能上船。真的轮船便是蓝图的物理实例，本质上是对蓝图的复制，即实例化。
类的另一个核心概念是多态，指父类(基类)的通用行为可以被子类用特殊行为重写。如Vehicle类中为所有交通工具定义了一个decelerate()减速方法，默认操作是踩刹车，但在轮船的减速中，可能还需要抛锚，所以在Steamer类中，可以重写decelerate()方法，在引用Vehicle类中decelerate()方法的基础上再加一步抛锚操作。即任何方法都可引用继承层次中高层的方法(方法名可以不同)。
有以下伪代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Vehicle{ engines=1 startEngine(){ console.</description></item><item><title>Javascript基础</title><link>https://jieye-ericx.github.io/Javascript%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Javascript%E5%9F%BA%E7%A1%80/</guid><description>继承 1、原型链继承 Array.includes Array.indexOf() 构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。
继承的本质就是复制，即重写原型对象，代之以一个新类型的实例。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function SuperType() { this.</description></item><item><title>kafka</title><link>https://jieye-ericx.github.io/kafka/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/kafka/</guid><description>Kafka 概念
Kafka 是一种高吞吐量、分布式、基于发布/订阅的消息系统，最初由 LinkedIn 公司开发，使用 Scala 语言编写，目前是 Apache 的开源项目。 **Kafka 主要组件broker：**Kafka 服务器，负责消息存储和转发 **topic：**消息类别，Kafka 按照 topic 来分类消息 **partition：**topic 的分区，一个 topic 可以包含多个 partition，topic 消息保存在各个 partition 上 **offset：**消息在日志中的位置，可以理解是消息在 partition 上的偏移量，也是代表该消息的唯一序号 **Producer：**消息生产者 **Consumer：**消息消费者 **Consumer Group：**消费者分组，每个 Consumer 必须属于一个 group **Zookeeper：**保存着集群 broker、topic、partition 等 meta 数据;另外，还负责 broker 故障发现，partition leader 选举，负载均衡等功能 Kafka 优点</description></item><item><title>Linux常用命令与环境变量</title><link>https://jieye-ericx.github.io/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid><description>linux的目录结构 打开终端，输入ls查看linux根目录下的情况
1 2 3 $ ls / ---------------- bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var /bin (/usr/bin /usr/local/bin )</description></item><item><title>Linux性能优化</title><link>https://jieye-ericx.github.io/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid><description>Linux性能优化 00开篇词 别再让Linux性能问题成为你的绊脚石 你好，我是倪朋飞，微软 Azure 的资深工程师，同时也是 Kubernetes 项目维护者，主要负责开源容器编排系统 Kubernetes 在 Azure 的落地实践。
一直以来，我都在云计算领域工作。对于服务器性能的关注，可以追溯到我刚参加工作那会儿。为什么那么早就开始探索性能问题呢？其实是源于一次我永远都忘不了的“事故”。
那会儿我在盛大云工作，忙活了大半夜把产品发布上线后，刚刚躺下打算休息，却突然收到大量的告警。匆忙爬起来登录到服务器之后，我发现有一些系统进程的 CPU 使用率高达 100%。
当时我完全是两眼一抹黑，可以说是只能看到症状，却完全不知道该从哪儿下手去排查和解决它。直到最后，我也没能想到好办法，这次发布也成了我心中之痛。
从那之后，我开始到处查看各种相关书籍，从操作系统原理、到 Linux 内核，再到硬件驱动程序等等。可是，学了那么多知识之后，我还是不能很快解决类似的性能问题。</description></item><item><title>Linux目录</title><link>https://jieye-ericx.github.io/Linux/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Linux/</guid><description>[[Linux常用命令与环境变量]]
[[Linux性能优化]]
[[selectpollepoll]]
[[排坑]]</description></item><item><title>log</title><link>https://jieye-ericx.github.io/log/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/log/</guid><description>Undolog 实现事务回滚，保障事务的原子性。事务处理过程中，如果出现了错误或者用户执行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。 实现 MVCC（多版本并发控制）关键因素之一。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。 !</description></item><item><title>MSL</title><link>https://jieye-ericx.github.io/MSL/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/MSL/</guid><description>MSL 指的是 TCP 协议中任何报文在网络上最大的生存时间，任何超过这个时间的数据都将被丢弃。虽然 RFC 793 规定 MSL 为 2 分钟，但是在实际实现的时候会有所不同，比如 Linux 默认为 30 秒，那么 2MSL 就是 60 秒。
MSL 是由网络层的 IP 包中的 TTL 来保证的，TTL 是 IP 头部的一个字段，用于设置一个数据报可经过的路由器的数量上限。报文每经过一次路由器的转发，IP 头部的 TTL 字段就会减 1，减到 0 时报文就被丢弃。</description></item><item><title>my</title><link>https://jieye-ericx.github.io/Ray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Ray/</guid><description>my 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 &amp;#39;checkpoint_at_end&amp;#39; = {bool} True &amp;#39;checkpoint_freq&amp;#39; = {int} 4 &amp;#39;max_failures&amp;#39; = {int} 1000 &amp;#39;resume&amp;#39; = {bool} False &amp;#39;export_formats&amp;#39; = {list: 2} [&amp;#39;model&amp;#39;, &amp;#39;checkpoint&amp;#39;] &amp;#39;stop&amp;#39; = {dict: 1} {&amp;#39;time_total_s&amp;#39;: 14400} &amp;#39;config&amp;#39; = {dict: 8} { &amp;#39;log_level&amp;#39;: &amp;#39;ERROR&amp;#39;, &amp;#39;num_workers&amp;#39;: 1, &amp;#39;num_gpus&amp;#39;: 0, &amp;#39;horizon&amp;#39;: 1000, &amp;#39;env&amp;#39;: &amp;lt;class &amp;#39;baselines.</description></item><item><title>Mysql join优化</title><link>https://jieye-ericx.github.io/Mysql-join%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Mysql-join%E4%BC%98%E5%8C%96/</guid><description>先说结论 首先，使用[[小表]]作为驱动表
如果可以使用 Index Nested-Loop Join 算法，也就是说可以用上被驱动表上的索引，其实是没问题的； 如果使用 Block Nested-Loop Join 算法，扫描行数就会过多。尤其是在大表上的 join 操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种 join 尽量不要用。 判断要不要使用 join 语句时，就是看 explain 结果里面，Extra 字段里面有没有出现“Block Nested Loop”字样</description></item><item><title>Mysql 原理</title><link>https://jieye-ericx.github.io/Mysql-%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Mysql-%E5%8E%9F%E7%90%86/</guid><description>[[1 MySQL的数据目录]]
[[2 用户与权限管理]]
[[3 逻辑架构]]
[[6 索引的数据结构]]
[[9 性能分析工具的使用]]
[[11 数据库设计规范（范式）]]
[[13 事务基础知识]]
[[15 锁]]
[[16 多版本并发控制]]
[[17 其他数据库日志]]</description></item><item><title>Nginx</title><link>https://jieye-ericx.github.io/Nginx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Nginx/</guid><description>Nginx 的产生 Nginx 同 Apache 一样都是一种 Web 服务器。基于 REST 架构风格，以统一资源描述符（Uniform Resources Identifier）URI 或者统一资源定位符（Uniform Resources Locator）URL 作为沟通依据，通过 HTTP 协议提供各种网络服务。
然而，这些服务器在设计之初受到当时环境的局限，例如当时的用户规模，网络带宽，产品特点等局限并且各自的定位和发展都不尽相同。这也使得各个 Web 服务器有着各自鲜明的特点。</description></item><item><title>Node 定时器</title><link>https://jieye-ericx.github.io/nodejs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/nodejs/</guid><description>child_process 在介绍child_process模块之前，先来看一个例子。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const http = require(&amp;#39;http&amp;#39;); const longComputation = () =&amp;gt; { let sum = 0; for (let i = 0; i &amp;lt; 1e10; i++) { sum += i; }; return sum; }; const server = http.</description></item><item><title>Obsidian高级探索</title><link>https://jieye-ericx.github.io/Obsidian%E9%AB%98%E7%BA%A7%E6%8E%A2%E7%B4%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Obsidian%E9%AB%98%E7%BA%A7%E6%8E%A2%E7%B4%A2/</guid><description>高级用法 [!Note] 标注
[[标注]]
[[Dataview]]
[[YAML Front matter]]
最重要的插件！ 看上 ob 最重要的当然是其和 vsc 媲美的插件系统，这里整理了一些我用的插件
obsidian 插件 改成name而非id 是否必装 原因 待考察 [[Word Splitting for Simplified Chinese in Edit Mode]] y 和[[Omnisearch]]插件配合才能支持中文搜索 [[Advanced Slides]] y 预览效果不错，也可以网页打开，基于 revealjs 已经相当成熟 [[Advanced Tables]] y 这个表格就是用它写的，贼方便 [[Advanced URL]] y 别的软件link到obsidian，直达目的，[[万物互联]] 必备 [[Bartender]] 编辑左侧和下方菜单显示和顺序，有用 [[Commander]] y 自定义ob界面的各种按钮 [[DB Folder]] 界面编辑用起来还是不舒服，没有notion的体验好 [[Daily Notes Editor]] 批量处理每日日志，挺好用，但感觉要期待官方收编[[Calendar]]插件 [[Dataview]] y 待学习，有点麻烦，别人都说是神器 [[DigitalGarden]] 替代官方发布的免费方案，后面有机会尝试 [[ExcaliBrain]] 类 thebrain 的插件，给图谱引入父子和兄弟的关系 [[Janitor]] y 目前最好的批量清理笔记插件 [[LiveSync]] 通过自己的 server，进行多端同步 [[ProZen]] y 禅模式目前ob中最好的实现 [[QuickAdd]] 半自动化批量添加模板 [[Templater]] 快速插入模板，很重要 [[Admonition|admonition]] 引用美化，鲜活页面 美化quote样式，已经被内置[[Callout]] 取代 [[auto-link-title]] y 复制的网址自动获取其 title，爆赞 [[calendar]] 如果能坚持每日日记，必装 [[Linter]] y 标准化、美化 markdown [[Supercharged Links]] y 给链接加上样式，提高可识别性👍 [[Text expand]] advanced-cursors 目前不需要多光标操作 annotator 插件太重，而且读书笔记做在这里太不轻便了 chronology 以日历的形式显式文件编辑历史 cmenu 编辑菜单很重要，而且支持定制 [[cmenu学习笔记]]，貌似没多大用，用命令行就行了 code-block-copy 程序员必备：复制代码太方便了，以后应该会自带 creases 长文的局部折叠局部展开工具 customizable-menu 自定义右键菜单 customizable-page-header-buttons y 可以给每个 page 加按钮，以及最右上角，有用，符合使用逻辑 customizable-sidebar 自定义侧边图标 cycle-through-panes 用快捷键快速在已打开的 pages 切换 dynamic-toc 动态目录，发布的时候很有用 excalidraw-plugin 图中加入双链的场景很诱人，待持续探索 没看到内置画图的必要性，可以用更专业工具 find-unlinked-files 批量整理悬空文件，有利于回顾 focus-mode y 页面最大化或全局最大化都很有用 footnotes 便捷插入 footnote 有用 hider 就是美化用的，隐藏界面各个面板，但感觉没必要 hover-editor y 预览的窗口也可以有更多操作 icon-folder 给文件列表的文件夹和文件加 emoji，更有视觉美感和记忆感 icons-plugin 很有用，各种网站 logo 都能快速搜索到 image-auto-upload-plugin y 神器，markdown 一键粘贴图片 link-favicon 给外链添加图标，增加可识别性，和 [[Supercharged Links]] 互补 longform 将日记批量合并到月记里面，以及其他写小说场景 mrj-text-obsidian y 将搜索结果记录下来，从而实现 dataview 的补充效果 note-refactor [[note-refactor学习笔记]] 待真正场景使用 notion-like-tables 通过最少侵入，引入好用表格 obsidian-git 它自动刷 commit，挺好，目前自动的时候会卡 不行，太卡了，自己自动 git 更好 obsidian42-brat y 装未上架的插件方便 outliner 装了它，高频使用的多级列表的编辑非常爽 pandoc 目前还没用到导出功能 pane-relief y 给返回前进按钮加上历史记录 periodic-notes 和 calendar 一样，能坚持必装 quick-explorer y 在菜单栏显示当前文件所在文件夹路径，不知道是否有性能问题？ recent-files y 自带的 cmd +o 只能查看近 10 个，这个有 30 个而且有常驻按钮 sliding-panes y 横向无限滑动场景有时候很有用 spaced-repetition y 间隔复习，知识完美闭环，必装 [[Spaced Repetition]] tag-wrangler y 批量更改标签必用 timelines time 使用起来太麻烦了 tracker 使用起来太麻烦了 various-complements y 自动补全智能提示 vault-statistics 快捷查看统计当前库的总数据 weread-plugin y 将微信读书的笔记批量自动同步过来 zoom 目前感觉不实用，而且有 bug 点击没反应有时</description></item><item><title>PKM</title><link>https://jieye-ericx.github.io/PKM/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/PKM/</guid><description>personal knowledge management 我认为的 pkm 一切以满足自我的需要为主的个人知识管理库
满足将各方面所学科学的记录下来 拥有 tag 和索引，能够快速查找 拥有自动化数据统计，了解效率情况</description></item><item><title>PM2</title><link>https://jieye-ericx.github.io/PM2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/PM2/</guid><description>简介 对于线上项目，如果直接通过 node app 来启动，如果报错了可能直接停止导致整个服务崩溃，一般监控 node 有几种方案。
supervisor: 一般用作开发环境的使用。 forever: 管理多个站点，一般每个站点的访问量不大的情况，不需要监控。 PM2: 一个进程管理工具，维护一个进程列表，可以用它来管理你的node进程，负责所有正在运行的进程，并查看node进程的状态，也支持性能监控，负载均衡等功能。 PM2 的主要特性 内建负载均衡（使用 Node cluster 集群模块） 后台运行 0 秒停机重载，我理解大概意思是维护升级的时候不需要停机.</description></item><item><title>Python基础</title><link>https://jieye-ericx.github.io/Python%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Python%E5%9F%BA%E7%A1%80/</guid><description>1 系统中的python 查看系统bin目录下所有的python
ls /usr/bin/python*
2 源 pip
配置文件位置：/Users/ericx/.config/pip/pip.conf
https://mirrors.tuna.tsinghua.edu.cn/help/pypi/
1 2 3 4 5 # 设置源 pip config set global.</description></item><item><title>Python目录</title><link>https://jieye-ericx.github.io/Python/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Python/</guid><description>[[强化学习课程-李宏毅]]
[[特征工程]]
[[GYM]]
[[Python基础]]
[[Pytorch]]
[[Ray]]
[[RL琐碎]]</description></item><item><title>Pytorch</title><link>https://jieye-ericx.github.io/Pytorch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Pytorch/</guid><description>torch.dtype torch.dtype是表示torch.Tensor的数据类型的对象。PyTorch有八种不同的数据类型：
Data type dtype Tensor types 32-bit floating point torch.float32 or torch.</description></item><item><title>redis</title><link>https://jieye-ericx.github.io/redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/redis/</guid><description>1.Redis 持久化机制 Redis主要提供了两种持久化机制：RDB和AOF;
RDB 默认开启，会按照配置的指定时间将内存中的数据快照到磁盛中，创建一个dump.rdb文件，Redis启动时再恢复到内存中。
Redis会单独创建fork一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。需要注意的是，每次快照持久化都会将主进程的数据库数据复制一遍，导致内存开销加倍，若此时内存不足，则会阻塞服务器运行，直到复制结束释放内存；都会将内存数据完整写入磁盛一次，所以如果数据量大的话，而且写操作频繁，必然会引起大量的
磁盘IO操作，严重影响性能，并且最后一次持久化后的数据可能会丟失。
AOF 以日志的形式记录每个写操作（读操作不记录），只需追加文件但不可以改写文件，Redis启动时会根据日志从头到尾全部执行一遍以完成数据的恢复工作。包括flushDB也会执行。
主要有两种方式触发：有写操作就写、每秒定时写（也会丢数据）。
因为AOF采用追加的方式，所以文件会越来越大，针对这个问题，新增了重写机制，就是当日志文件大到一定程度的时候，会fork出一条新进程来遍历进程内存中的数据，每条记录对应一条set语句，写到临时文件中，然后再替换到旧的日志文件（类似rdb的操作方式）。默认触发是当aof文件大小是上次重写后大小的一倍且文件大于64M时触发。当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。一般情况下，只要使用默认开启的RDB即可，因为相对于AOF,RDB便于进行数据库备份，并且恢复数据集的速度也要快很多。
开启持久化缓存机制，对性能会有一定的影响，特别是当设置的内存满了的时候，更是下降到几百reqs/s。所以如果只是用来做缓存的话，可以关掉持久化。
2.缓存雪崩、缓存穿透、缓存击穿 3.内存淘汰策略 Redis内存回收机制
Redis的内存回收主要围绕以下两个方面：
1.Redis过期策略:删除过期时间的key值
2.Redis淘汰策略:内存使用到达maxmemory上限时触发内存淘汰数据
Redis的过期策略和内存淘汰策略不是一件事，实际研发中不要弄混淆了，下面会完整的介绍两者。</description></item><item><title>Redis 解决mysql查询速度慢</title><link>https://jieye-ericx.github.io/Redis-%E8%A7%A3%E5%86%B3mysql%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E6%85%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Redis-%E8%A7%A3%E5%86%B3mysql%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E6%85%A2/</guid><description>有一个应用需要上传一组 ID 到服务器来查询这些 ID 所对应的数据，数据库中存储的数据量是7千万，每次上传的 ID 数量一般都是几百至上千数量级别。
以前的解决方案
数据存储在Oracle中，为ID建立了索引； 查询时，先将这些上传的ID数据存储到临时表中，然后用表关联的方法来查询。 这样做的优点是减少了查询次数（不用每个ID都查询一次），减少了解析SQL的时间（只需要执行1次查询SQL，但是多了插入数据的SQL处理时间）。
但是这样的设计仍然存在巨大的提升空间，当并发查询的数量增加时，数据库的响应就会很久。虽然建立了索引，但是每个ID查询的时间复杂度仍是O(logn)级别的，那么总的查询时间复杂度就应该是m*O(logn)。不知道Oracle对表关联查询有做了哪些优化，但应该也是改变不了时间复杂度的级别。
解决方法
一遇到读数据库存在瓶颈的问题，首先想到的就是要用内存数据库，用缓存来解决。首选 Redis，因为Redis是一种提供了丰富数据结构的key-value数据库，value可以存储STRING（字符串）、HASH（哈希），LIST（列表），ZSET（有序集）。
首先需要将数据的存储改成 key-value 架构。简单的做法就是一个ID对应一个字符串的 Value。但是一个 ID 可以对应多条数据，而且一条数据内又可以包含多个字段。这时候就需要将这些数据重新组合一下，拼在一起，或者是采用列表、哈希或集合来存储 Value。</description></item><item><title>RegExp</title><link>https://jieye-ericx.github.io/RegExp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/RegExp/</guid><description>匹配字符规则 预定义类 量词符 边界符 \d 匹配数字,相当于[0-9] ***** 0个或者更多 ^ 一行的开头 \D 匹配非数字,相当于[^0-9] + 1个或更多，至少1个 $ 一行的结尾 \w 匹配数字、字母、下划线,相当于[A-Za-z0-9_] ?</description></item><item><title>Reinforcement Learning</title><link>https://jieye-ericx.github.io/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B-%E6%9D%8E%E5%AE%8F%E6%AF%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B-%E6%9D%8E%E5%AE%8F%E6%AF%85/</guid><description>Reinforcement Learning 0 从监督学习到强化学习 那什么是 Reinforcement Learning 呢,到目前为止，我们讲的几乎都是 Supervised Learning,假设你要做一个 Image 的 Classifier,你不只要告诉机器,它的 Input 是什么,你还要告诉机器,它应该输出什么样的 Output,然后接下来呢,你就可以 Train 一个 Image 的 Classifier</description></item><item><title>selectpollepoll</title><link>https://jieye-ericx.github.io/selectpollepoll/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/selectpollepoll/</guid><description>感觉如果不做底层开发，永远也无法深入理解了😅</description></item><item><title>SSH 基本知识</title><link>https://jieye-ericx.github.io/SSH/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/SSH/</guid><description>SSH 是 Linux 系统的登录工具，现在广泛用于服务器登录和各种加密通信。
SSH 基本知识 SSH（Secure Shell 的缩写）是一种网络协议，用于加密两台计算机之间的通信，并且支持各种身份验证机制。
实务中，它主要用于保证远程登录和远程通信的安全，任何网络服务都可以用这个协议来加密。
SSH 是什么 历史上，网络主机之间的通信是不加密的，属于明文通信。这使得通信很不安全，一个典型的例子就是服务器登录。登录远程服务器的时候，需要将用户输入的密码传给服务器，如果这个过程是明文通信，就意味着传递过程中，线路经过的中间计算机都能看到密码，这是很可怕的。
SSH 就是为了解决这个问题而诞生的，它能够加密计算机之间的通信，保证不被窃听或篡改。它还能对操作者进行认证（authentication）和授权（authorization）。明文的网络协议可以套用在它里面，从而实现加密。
历史 1995年，芬兰赫尔辛基工业大学的研究员 Tatu Ylönen 设计了 SSH 协议的第一个版本（现称为 SSH 1），同时写出了第一个实现（称为 SSH1）。</description></item><item><title>typescript</title><link>https://jieye-ericx.github.io/typescript/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/typescript/</guid><description>一、TypeScript 是什么 TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。
TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。下图显示了 TypeScript 与 ES5、ES2015 和 ES2016 之间的关系：</description></item><item><title>Vue</title><link>https://jieye-ericx.github.io/Vue2%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Vue2%E5%9F%BA%E7%A1%80/</guid><description>之前学习很有问题，只看视频不记笔记，直接把机构的笔记复制来也不整理，痛定思痛，特整理如下。
Vue 是什么？ Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架 Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue.</description></item><item><title>vue&amp;react</title><link>https://jieye-ericx.github.io/vuereact/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/vuereact/</guid><description>Vue和React区别 监听数据变化的实现原理不同 Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能 React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的VDOM的重新渲染 为什么 React 不精确监听数据变化呢？这是因为 Vue 和 React 设计理念上的区别，Vue 使用的是可变数据，而React更强调数据的不可变。所以应该说没有好坏之分，Vue更加简单，而React构建大型应用的时候更加鲁棒。
因为一般都会用一个数据层的框架比如 Vuex 和 Redux，所以这部分不作过多解释，在最后的 vuex 和 redux的区别 中也会讲到。</description></item><item><title>Vue3快速上手</title><link>https://jieye-ericx.github.io/Vue3%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Vue3%E5%9F%BA%E7%A1%80/</guid><description>Vue3快速上手 1.Vue3简介 2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王） 耗时2年多、 2600+次提交、 30+个RFC、 600+次PR、 99位贡献者 github上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0 2.Vue3带来了什么 1.性能的提升 打包大小减少41% 初次渲染快55%, 更新渲染快133% 内存减少54%
…… 2.</description></item><item><title>Vuex</title><link>https://jieye-ericx.github.io/Vuex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Vuex/</guid><description>##1.Vuex概述
Vuex是实现组件全局状态（数据）管理的一种机制，可以方便的实现组件之间的数据共享
使用Vuex管理数据的好处：
A.能够在vuex中集中管理共享的数据，便于开发和后期进行维护
B.能够高效的实现组件之间的数据共享，提高开发效率
C.存储在vuex中的数据是响应式的，当数据发生改变时，页面中的数据也会同步更新
使用 Vue 我们就不可避免的会遇到组件间共享的数据或状态。应用的业务代码逐渐复杂，props、事件、事件总线等通信的方式的弊端就会愈发明显。这个时候我们就需要 Vuex 。Vuex 是一个专门为 Vue 设计的状态管理工具。
状态管理是 Vue 组件解耦的重要手段。
2.Vuex的基本使用 Vuex 不限制你的代码结构，但需要遵守一些规则：</description></item><item><title>web-test</title><link>https://jieye-ericx.github.io/web-test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/web-test/</guid><description>单元测试 首先声明一点，长期以来，前端开发的单元测试并不是在前端的开发过程中所必须的，也不是每个前端开发工程师所注意和重视的，甚至扩大到软件开发过程中单元测试这一环也不是在章程上有书面规定所要求的。但是随着每个工程的复杂化、代码的高复用性要求和前端代码模块之间的高内聚低耦合的需求，前端工程中的单元测试流程就显得很有其必要。
1.前端单元测试是什么 首先我们要明确测试是什么：
​ 为检测特定的目标是否符合标准而采用专用的工具或者方法进行验证，并最终得出特定的结果。
​ 对于前端开发过程来说，这里的特定目标就是指我们写的代码，而工具就是我们需要用到的测试框架(库)、测试用例等。检测处的结果就是展示测试是否通过或者给出测试报告，这样才能方便问题的排查和后期的修正。
​ 基于测试“是什么”的说法，为便于刚从事前端开发的同行的进阶理解，那我们就列出单元测试它“不是什么”：
需要访问数据库的测试不是单元测试
需要访问网络的测试不是单元测试
需要访问文件系统的测试不是单元测试
&amp;mdash; 修改代码的艺术
对于单元测试“不是什么”的引用解释，至此点到为止。鉴于篇幅限制，对于引用内容，我想前端开发的同行们看到后会初步有一个属于自己的理解。</description></item><item><title>webpack4</title><link>https://jieye-ericx.github.io/webpack4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/webpack4/</guid><description>Webpack是什么 webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。
在 webpack 看来, 前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理。
它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。
webpack 五个核心概念 Entry 入口(Entry)指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图。
Output 输出(Output)指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名。</description></item><item><title>Web性能</title><link>https://jieye-ericx.github.io/Web%E6%80%A7%E8%83%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Web%E6%80%A7%E8%83%BD/</guid><description>性能优化涉及到的分类 网络层面 构建层面 浏览器渲染层面 服务端层面 涉及到的功能点 资源的合并与压缩 图片编解码原理和类型选择 浏览器渲染机制 懒加载预加载 浏览器存储 缓存机制 PWA Vue-SSR 资源合并与压缩 http请求的过程及潜在的性能优化点 理解减少http请求数量和减少请求资源大小两个优化要点 掌握压缩与合并的原理 掌握通过在线网站和fis3两种实现压缩与合并的方法 浏览器的一个请求从发送到返回都经历了什么 动态的加载静态的资源</description></item><item><title>YAML Front matter</title><link>https://jieye-ericx.github.io/YAML-Front-matter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/YAML-Front-matter/</guid><description>这可以说是能建立自动构建分类部署的最重要的东西了
每篇文章的开头都有被&amp;mdash;包裹的 yaml 数据，而这两个三横杠包括的区域一般被称为 Front-matter。
1 2 3 4 5 6 7 8 9 10 ---key:valuekey2:value2multiple:[one, two, three]multiple:- one- two- three---你的所有参数都应当放在同一个 Front matter 中，例如其中的 Key、Key2、Key3 可以是多个参数名，如果是一个 Key 对应多个参数的话，就需要用 [ ] 将他们概括起来，或者用 - 来将它们从上到下排列。 Obsidian 自带的 Front matter 主要只有两个：</description></item><item><title>三次握手与四次挥手时的Seq 与 ACK</title><link>https://jieye-ericx.github.io/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E7%9A%84Seq-%E4%B8%8E-ACK/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E7%9A%84Seq-%E4%B8%8E-ACK/</guid><description>之前只笼统的知道每次报文的 SEQ 和 ACK 是收到的或者要求的+数据字节数
但还真没想到第三次握手与第一条消息以及第二次和第三次挥手的 SEQ、ACK 都是一样的，想想也合理，因为都是同一方连续发了两条报文，自然都一样了
发送的 TCP 报文：
公式一：序列号 = 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为上一次发送的序列号 + 1。 公式二：确认号 = 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</description></item><item><title>上下文</title><link>https://jieye-ericx.github.io/%E4%B8%8A%E4%B8%8B%E6%96%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E4%B8%8A%E4%B8%8B%E6%96%87/</guid><description>上下文
Context 在许多编程语言/框架中都出现，曾几何时，我难以理解这个单词的含义</description></item><item><title>两阶段提交</title><link>https://jieye-ericx.github.io/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/</guid><description>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。
如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而 binlog 还没有来得及写入 如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redo log 还没有来得及写入 MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</description></item><item><title>使用LinkedBlockingQueue时线程池的坑</title><link>https://jieye-ericx.github.io/%E4%BD%BF%E7%94%A8LinkedBlockingQueue%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9D%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E4%BD%BF%E7%94%A8LinkedBlockingQueue%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9D%91/</guid><description>最近遇到一个问题HTTP 线程快速上升，外部服务调用超时，服务本身响应时间超长
现象 应用平常运行正常没有任何问题，突然有一天应用的访问量爆增，出现外部服务调用超时，服务本身响应时间超长，HTTP线程快速上升，但CPU利用率并不高
定位思路 分析这类线程异常问题，最直接有效的方法是查看线程的 dump
根据dump极有可能是线程池设置不合理导致，查看线程池 cachedTreadPool 的定义，发现定义如下：
核心线程数为 cpu 的数量2倍，最大线程数为 cpu 的数量乘以配置的数量，任务队列为 LinkedBlockingQueue，也就是最大数量为 Integer.MAX_VALUE，对线程池了解的话，这样的设置会导致线程池的任务堆积。因为线程池默认实现是核心线程数满了之后，再填充任务队列，如果线程数量小于最大线程数再创建线程。而这儿设置的任务队列几乎是无界的，也就是说这个线程池真正工作的线程只会是 cpu 的数量的 2 倍。</description></item><item><title>分布式</title><link>https://jieye-ericx.github.io/%E5%88%86%E5%B8%83%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%88%86%E5%B8%83%E5%BC%8F/</guid><description>关于分布式 20230314 也看过不少面试题和博客了，但感觉一直无法完全理解，所以有了这篇总结[[分布式系统]]
[[分布式系统]] 是直接由 xmind 导出，格式有些混乱，所以还是看这张图吧
通过极客时间专栏、pdai、javaguide 等渠道学习制作了此xmind
不定期更新图片
分布式数据库 [[kafka]]
[[RPC]]</description></item><item><title>分布式数据库</title><link>https://jieye-ericx.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/</guid><description>https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/24%E8%AE%B2%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AE%8C/01%20%20%E5%AF%BC%E8%AE%BA%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F%E8%81%8A%E8%81%8A%E5%AE%83%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.md
分布式数据库的核心——数据分片、数据同步
数据分片
该特性是分布式数据库的技术创新。它可以突破中心化数据库单机的容量限制，从而将数据分散到多节点，以更灵活、高效的方式来处理数据。这是分布式理论带给数据库的一份礼物。
分片方式包括两种。 水平分片：按行进行数据分割，数据被切割为一个个数据组，分散到不同节点上。 垂直分片：按列进行数据切割，一个数据表的模式（Schema）被切割为多个小的模式。 数据同步
它是分布式数据库的底线。由于数据库理论传统上是建立在单机数据库基础上，而引入分布式理论后，一致性原则被打破。因此需要引入数据库同步技术来帮助数据库恢复一致性。
简而言之，就是使分布式数据库用起来像“正常的数据库”。所以数据同步背后的推动力，就是人们对数据“一致性”的追求。这两个概念相辅相成，互相作用。 sql 与 nosql 1 数据分片 -提高数据容量和性能 水平分片：在不同的数据库节点中存储同一表的不同行。 垂直分片：在不同的数据库节点中存储表不同的表列。 分片算法 分片算法一般指代水平分片所需要的算法。经过多年的演化，其已经在大型系统中得到了广泛的实践。下面我将介绍两种最常见的水平分片算法，并简要介绍一些其他的分片算法优化思路。</description></item><item><title>利用Element实现响应式导航栏</title><link>https://jieye-ericx.github.io/%E5%88%A9%E7%94%A8Element%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%BC%E8%88%AA%E6%A0%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%88%A9%E7%94%A8Element%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%BC%E8%88%AA%E6%A0%8F/</guid><description>开始之前 按照计划，前端使用Vue.js+Element UI，但在设计导航栏时，发现element没有提供传统意义上的页面顶部导航栏组件，只有一个可以用在很多需要选择tab场景的导航菜单，便决定在其基础上改造，由于我认为实现移动端良好的体验是必须的，所以便萌生了给其增加响应式功能的想法。
需求分析与拆解 假设我们的导航栏有logo和四个el-menu-item。
给window绑定监听事件，当宽度小于a时，四个链接全部放入右侧el-submenu的子菜单：
当宽度大于a时，右侧el-submenu不显示，左侧el-menu-item正常显示：
所以，先创建一个数组，存储所有所需的item：
1 2 3 4 5 6 navItems: [ { name: &amp;#34;Home&amp;#34;, indexPath: &amp;#34;/home&amp;#34;, index: &amp;#34;1&amp;#34; }, { name: &amp;#34;Subscribe&amp;#34;, indexPath: &amp;#34;/subscribe&amp;#34;, index: &amp;#34;2&amp;#34;}, { name: &amp;#34;About&amp;#34;, indexPath: &amp;#34;/about&amp;#34;, index: &amp;#34;3&amp;#34; }, { name: &amp;#34;More&amp;#34;, indexPath: &amp;#34;/more&amp;#34;, index: &amp;#34;4&amp;#34; } ] 监听宽度 很明显功能实现的关键是随时监听窗口的变化，根据对应的宽度做出响应，在data中，我使用screenWidth变量来存储窗口大小,保存初始打开页面时的宽度:</description></item><item><title>前端</title><link>https://jieye-ericx.github.io/%E5%89%8D%E7%AB%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%89%8D%E7%AB%AF/</guid><description>前端是学的最久最多的了，bilibili的实习也是前端居多，在转后端面前，这些好像又失去了作用
浏览器相关
[[browser]]
Web安全
[[同源策略]]
[[CSRFXSS]]
[[包管理工具]]
[[移动Web与响应式]]
框架
[[react]]
[[Vue2基础]]
[[Vue3基础]]
[[Vuex]]
[[Diff]]
构建工具
[[webpack4]]
webpack5相关在notion中，等待搬运
基础知识
[[CSS3 no]]</description></item><item><title>前端工程化</title><link>https://jieye-ericx.github.io/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</guid><description>前端工程本质上是软件工程的一种。软件工程化关注的是性能、稳定性、可用性、可维护性等方面，注重基本的开发效率、运行效率的同时，思考维护效率。一切以这些为目标的工作都是&amp;quot;前端工程化&amp;quot;。工程化是一种思想而不是某种技术。
模块化 简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。（方便了多人协作）。
分而治之是软件工程中的重要思想，是复杂系统开发和维护的基石，这点放在前端开发中同样适用。模块化是目前前端最流行的分治手段。
模块化开发的最大价值应该是分治！
不管你将来是否要复用某段代码，你都有充分的理由将其分治为一个模块。
JS模块化方案 AMD/CommonJS/UMD/ES6 Module等等。
CommonJS的核心思想是把一个文件当做一个模块，要在哪里使用这个模块，就在哪里require这个模块，然后require方法开始加载这个模块并且执行其中的代码，最后会返回你指定的export对象。
1 2 3 4 5 6 7 8 module.export = function() { hello: function() { alert(&amp;#34;你好&amp;#34;); } } var a = require(&amp;#39;.</description></item><item><title>前端面试题</title><link>https://jieye-ericx.github.io/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>[[浏览器相关]]
[[css]]
[[html]]
[[javascript]]
[[vue&amp;amp;react]]</description></item><item><title>包管理工具</title><link>https://jieye-ericx.github.io/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>npm 1 2 3 # 查看文件路径 npm config get userconfig npm config get globalconfig proxy 1 2 3 4 5 npm config set proxy http://127.</description></item><item><title>同源策略</title><link>https://jieye-ericx.github.io/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</guid><description>同源的定义 同源策略是一个重要的安全策略，它用于限制一个 origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。
Origin
Web内容的源由用于访问它的 URL 的方案(协议)，主机(域名)和端口定义。只有当方案，主机和端口都匹配时，两个对象具有相同的起源。
同源的例子
http://example.com/app1/index.html http://example.com/app2/index.html same origin because same scheme (http) and host (example.</description></item><item><title>命令速查</title><link>https://jieye-ericx.github.io/Mysql-%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Mysql-%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</guid><description>命令速查 重要！进行用户相关操作后记得刷新权限！！！FLUSH PRIVILEGES;
列出所有数据库
show databases;
删除数据库
drop database name;
新建数据库
create database name;</description></item><item><title>基本知识</title><link>https://jieye-ericx.github.io/%E7%A7%BB%E5%8A%A8Web%E4%B8%8E%E5%93%8D%E5%BA%94%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%A7%BB%E5%8A%A8Web%E4%B8%8E%E5%93%8D%E5%BA%94%E5%BC%8F/</guid><description>基本知识 视口 视口（viewport）就是浏览器显示页面内容的屏幕区域。最先由 Apple 引入，用于解决移动端页面的显示问题，通过一个叫 &amp;lt;meta&amp;gt; 的 DOM 标签，允许我们可以定义视口的各种行为，比如宽度，高度，初始缩放比例等，视口可以分为布局视口、视觉视口和理想视口。
布局视口 layout viewport 一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的PC端页面在手机上显示的问题。
layout viewport 是一个固定的值，由浏览器厂商设定，
IOS 和 Android 基本都是 980px 黑莓（BlackBerry）和 IE10 是 1024px 在PC端上，布局视口等于浏览器窗口的宽度 所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。</description></item><item><title>基础</title><link>https://jieye-ericx.github.io/RL%E7%90%90%E7%A2%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/RL%E7%90%90%E7%A2%8E/</guid><description>基础 episode：从一个游戏开始到结束，叫做一个episode
loss:可以作为负的reward
Monte-Carlo(MC):
分类 是否理解环境？
不理解环境：不尝试去理解环境，环境给什么就是什么 Model-free
理解环境：为真实世界建模 Model-based
Model-based 就是在model free的基础上多一个虚拟环境 基于Policy-Based与基于Value-Based
基于概率：直接输出下一步要采取动作的概率，根据概率选取行动，可以支持连续动作 Policy Gradients
基于价值（连续动作无能为力）：而基于价值的方法输出则是所有动作的价值, 根据最高价值来选着动作 Q-Learning Sarsa</description></item><item><title>实现可靠传输</title><link>https://jieye-ericx.github.io/%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</guid><description>市面上已经有基于 UDP 协议实现的可靠传输协议的成熟方案了，那就是 QUIC 协议，已经应用在了 HTTP/3,在 UDP 报文头部与 HTTP 消息之间，共有 3 层头部
为了解决 [[TCP]] 的[[队头阻塞]]，QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口</description></item><item><title>小表</title><link>https://jieye-ericx.github.io/%E5%B0%8F%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%B0%8F%E8%A1%A8/</guid><description>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表</description></item><item><title>排坑</title><link>https://jieye-ericx.github.io/%E6%8E%92%E5%9D%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E6%8E%92%E5%9D%91/</guid><description>locale 的报错 LC_CTYPE / LC_ALL 问题 如果输入 locale 查看系统字体编码，可能会出现如下报错
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 locale: Cannot set LC_CTYPE to default locale: No such file or directory locale: Cannot set LC_ALL to default locale: ?</description></item><item><title>操作系统</title><link>https://jieye-ericx.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid><description>进程间通信 1、无名管道( pipe )；2、高级管道(popen)；3、有名管道 (named pipe)；4、消息队列( message queue )；5、信号量( semophore )；7、共享内存( shared memory )；8、套接字( socket )。
线程间通信 1.锁机制：包括互斥锁、条件变量、读写锁 2.信号量机制(Semaphore) 3.信号机制(Signal)</description></item><item><title>数字花园</title><link>https://jieye-ericx.github.io/%E6%95%B0%E5%AD%97%E8%8A%B1%E5%9B%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E6%95%B0%E5%AD%97%E8%8A%B1%E5%9B%AD/</guid><description>定义 数字花园是通过借助网络数字工具，对想法、笔记和思考等一切你感兴趣的信息或进行收集、整理和创作，文字之间用标签或链接创建连接，形成一座独具个人浓厚色彩的信息与知识型花园。
这个花园是开放的，不可避免地至少要经常打理。
数字花园介于笔记本和博客之间的交叉空间，具有半公开性质。
不像笔记内容的纯私人性一样，数字花园鼓励用户发布自己的想法、草稿，这在很大程度上降低了我们的发布压力。
同时，数字花园不像博客那样完全公开，以建立个人品牌作为内容发布的主要目的。</description></item><item><title>数据库、部署、运维</title><link>https://jieye-ericx.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%83%A8%E7%BD%B2%E8%BF%90%E7%BB%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%83%A8%E7%BD%B2%E8%BF%90%E7%BB%B4/</guid><description>[[Docker基础]]
[[PM2]]
[[Nginx]]
[[Redis原理]]
[[Mysql 原理]]
[[Mysql 命令速查]]
[[Mysql join优化]] [[Redis 解决mysql查询速度慢]] [[系统监控异常处理]]</description></item><item><title>标注</title><link>https://jieye-ericx.github.io/%E6%A0%87%E6%B3%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E6%A0%87%E6%B3%A8/</guid><description>1 2 &amp;gt; [!NOTE] Note title &amp;gt; Information [!NOTE] Note title
Information
1 2 &amp;gt; [!</description></item><item><title>浏览器指纹 notion</title><link>https://jieye-ericx.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9-notion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9-notion/</guid><description>什么是浏览器指纹? 我们常说的指纹，都是指人们手指上的指纹，因具有唯一性，所以可以被用来标识一个人的唯一身份。而浏览器指纹是指仅通过浏览器的各种 信息，如CPU核心数、显卡信息、系统字体、屏幕分辨率、浏览器插件等组合成的一个字符串，就能近乎绝对定位一个 用户，就算使用浏览器的隐私窗口模式，也无法避免。
这是一个被动的识别方式。也就是说，理论上你访问了某一个网站，那么这个网站就能识别到你，虽然不知道你是谁，但你有一个唯一的指纹，将来无论是广告投放、精准推送、安全防范，还是其他一些关于隐私的事情，都非常方便。
实现浏览器指纹的技术点有哪些? 1、基本指纹 浏览器基本指纹是任何浏览器都具有的特征标识，比如屏幕分辨率、硬件类型、操作系统、用户代理（User agent）、系统字体、语言、浏览器插件 、浏览器扩展、浏览器设置 、时区差等众多信息，这些指纹信息“类似”人类的身高、年龄等，有很大的冲突概率，只能作为辅助识别。可以在该网址进行查看本地浏览器的基本特征，https://www.whatismybrowser.com/
2、高级指纹 浏览器高级指纹与基本指纹的区别是，基本指纹就像是人的外貌特征，外貌可以用男女、身高、体重区分，然而这些特征不能对某个人进行唯一性标识，仅使用基本指纹也无法对客户端进行唯一性判定，基于HTML5的诸多高级功能就能 生成高级指纹了。
Canvas指纹 说到高级指纹，不得不提Canvas指纹，Canvas（画布）是HTML5中一种动态绘图的标签，可以使用其生成甚至处理高级图片。
Canvas指纹的原理大致如下：
相同的HTMLCanvasElement元素绘制操作，在不同操作系统、不同浏览器上，产生的图片内容不完全相同。在图片格式上，不同浏览器使用了不同的图形处理引擎、不同的图片导出选项、不同的默认压缩级别等。在像素级别来看，操作系统各自使用了不同的设置和算法来进行抗锯齿和子像素渲染操作。即使相同的绘图操作，产生的图片数据的CRC检验也不相同。Canvas几乎已被所有主流浏览器支持，可以通过大部分的PC、平板、智能手机访问。
在线测试地址：https://www.browserleaks.com/canvas，可查看浏览器的Canvas唯一性字符串。
WebGL指纹 通过HTMLCanvasElement元素可以获取到Webgl对象（canvas.</description></item><item><title>浏览器相关</title><link>https://jieye-ericx.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/</guid><description>1. 如何实现浏览器内多个标签页之间的通信? WebSocket SharedWorker 也可以调用 localstorge、cookies 等本地存储方式。 localstorge 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信。 注意：Safari 在无痕模式下设置 localstorge 值时会抛出QuotaExceededError 的异常~~~~
2.webSocket如何兼容低浏览器？ Adobe Flash Socket ActiveX HTMLFile (IE) 基于 multipart 编码发送 XHR 基于长轮询的 XHR 引用WebSocket.</description></item><item><title>目录</title><link>https://jieye-ericx.github.io/Java/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Java/</guid><description>这里记录着 Java 的学习记录
作为 hc 最多、资料最多的后端语言，却是我最后学习的、但应该也是学习最多的
Java 基础学起来确实比 Golang 方便得多，看完 | Java 全栈知识体系和 JavaGuide（Java学习&amp;amp;&amp;amp;面试指南） | JavaGuide(Java面试 + 学习指南) 感觉基础讲的非常全面了，有问题直接查找便是，这里就不再记录了</description></item><item><title>第1章：React入门</title><link>https://jieye-ericx.github.io/react/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/react/</guid><description>第1章：React入门 1.1. React简介 1.1.1. 官网
英文官网: https://reactjs.org/ 中文官网: https://react.docschina.org/ 1.1.2. 介绍描述
用于动态构建用户界面的 JavaScript 库(只关注于视图) 由Facebook开源 1.1.3. React的特点</description></item><item><title>系统监控异常处理</title><link>https://jieye-ericx.github.io/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid><description>写起来思路很清晰，但实际上整个过程花费了大半天的时间，其实排查的过程中，有很多关键点没有抓到，有很多现象，是可以凭经验条件反射的推断出原因的：
看到cpu使用率上涨，用jstack看使用cpu的线程，以及该线程在跑什么代码。 找到是gc线程，然后看gc曲线是否正常。 看堆内存曲线，正常的曲线是锯齿形的，如果不是，一次full GC之后内存没有明显下降，那基本可以推断发生内存泄漏了。 怀疑是内存泄漏的问题，可以跑jmap，然后拉到MAT分析。 第四步比较耗时的话，可以同时跑这个命令：jmap -histo pid。看看有没有线索。 jvm的一些工具：jstack、jmap、jstat、jhat。包括可视化工具：MAT、jvisualvm</description></item><item><title>组件库设计</title><link>https://jieye-ericx.github.io/%E7%BB%84%E4%BB%B6%E5%BA%93%E8%AE%BE%E8%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%BB%84%E4%BB%B6%E5%BA%93%E8%AE%BE%E8%AE%A1/</guid><description>1.前端组件库的设计原则 1.1 细粒度的考量 我们在学习设计模式的时候会遇到很多种设计原则,其中一个设计原则就是单一职责原则,在组件库的开发中同样适用,我们原则上一个组件只专注一件事情,单一职责的组件的好处很明显,由于职责单一就可以最大可能性地复用组件,但是这也带来一个问题,过度单一职责的组件也可能会导致过度抽象,造成组件库的碎片化。
举个例子，一个自动完成组件(AutoComplete),他其实是由 Input 组件和 Select 组件组合而成的,因此我们完全可以复用之前的相关组件,就比如 Antd 的 AutoComplete 组件中就复用了 Select 组件,同时 Calendar、 Form 等等一系列组件都复用了 Select 组件,那么 Select 的细粒度就是合适的,因为 Select 保持的这种细粒度很容易被复用.</description></item><item><title>综合</title><link>https://jieye-ericx.github.io/%E7%BD%91%E7%BB%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%BD%91%E7%BB%9C/</guid><description>综合 1.当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？ 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。 下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。 最后一步是 TCP 断开连接的四次挥手过程。 2.</description></item><item><title>缺陷</title><link>https://jieye-ericx.github.io/TCP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/TCP/</guid><description>状态 [[time_await]]
握手 [[三次握手与四次挥手时的Seq 与 ACK]] [[与quic协议TLS握手次数]]
特性 [[TCP 延迟确认机制]]
![[fast open]]
Keepalive TCP 的 Keepalive 这东西其实就是 TCP 的保活机制，它的工作原理我之前的文章写过，这里就直接贴下以前的内容。 如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。 如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。 如果对端主机宕机（注意不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机），或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。 ^a0811d (关于 HTTP 的 [[HTTP#^d5b1b1|keepalive]] 缺陷 针对 HTTPS 来说，TLS 是在应用层实现的握手，而 TCP 是在内核实现的握手，这两个握手过程是无法结合在一起的，总是得先完成 TCP 握手，才能进行 TLS 握手。</description></item><item><title>网络与媒体</title><link>https://jieye-ericx.github.io/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AA%92%E4%BD%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AA%92%E4%BD%93/</guid><description>[[趣谈网络协议]]
[[CDN]]
[[HTTP]]
[[Image]]
[[RegExp]]
[[SSH]]
[[TCP]]
[[UDP]]
[[网络性能指标]]</description></item><item><title>网络迁移需要重新建立 TCP 连接</title><link>https://jieye-ericx.github.io/%E7%BD%91%E7%BB%9C%E8%BF%81%E7%A7%BB%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E5%BB%BA%E7%AB%8B-TCP-%E8%BF%9E%E6%8E%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%BD%91%E7%BB%9C%E8%BF%81%E7%A7%BB%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E5%BB%BA%E7%AB%8B-TCP-%E8%BF%9E%E6%8E%A5/</guid><description>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。
那么当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立 TCP 连接。
而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</description></item><item><title>虚拟DOM和diff算法</title><link>https://jieye-ericx.github.io/Diff/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Diff/</guid><description>虚拟DOM和diff算法 snabbdom安装配置 snabbdom是瑞典语单词，单词原意“速度”,在IT方面是著名的虚拟DOM库，是diff算法的鼻祖，Vue源码就借鉴了snabbdom。官方git：https://github.com/snabbdom/snabbdom。
在git上的snabbdom源码是用TypeScript写的，git上并不提供编译好的JavaScript版本，因此如果要直接使用build出来的JavaScript版的snabbdom库，可以从npm上下载：
npm i -D snabbdom
snabbdom库是DOM库，当然不能在nodejs环境运行，所以我们需要搭建webpack和webpack-dev-server开发环境，好消息是不需要安装任何loader。
这里需要注意，必须安装最新版webpack@5，不能安装webpack@4，这是因为webpack4没有读取身份证中exports的能力。
npm i -D webpack@5 webpack-cli@3webpack-dev-server@3
webpack.config.js配置为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 从https://www.</description></item><item><title>趣谈网络协议</title><link>https://jieye-ericx.github.io/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</guid><description>趣谈网络协议 00 我是如何创作“趣谈网络协议”专栏的 我用将近半年的时间在“极客时间”写了一个专栏“趣谈网络协议”。对于我自己来讲，这真的是个非常特殊而又难忘的经历。
很多人都很好奇，这个专栏究竟是怎么一步步创作出来的，每一篇文章是怎么写出来的？自己录音频又是什么样的感受？写完整个专栏之后，我终于有时间回顾、整理一下这半年的所感所想。对我来说，这是一次难得的体验，也是一次与“极客时间”的深度沟通。
专栏是写给谁的？ 和极客时间的编辑谈妥主题之后，他们首先要求我基于约定的主题，写一个36节至50节的大纲，之后会以每周三篇的频率，文字加音频的方式发布。每篇文章的体量要求在3000字左右，录成音频大约就是10分钟。
我本来觉得写这么一个专栏根本就不是个事儿。毕竟咱也是在IT圈摸爬滚打了许多年的“老司机”，干货积累得也不少。只要是熟悉的领域，不用准备，聊个把小时都没啥问题。况且我原来还写过书、写过博客、写过公众号。所以，我对自己文字方面的能力很有自信。
至于语言方面，咱常年出入各大技术论坛，什么场子没趟过。一个两天的线下培训，咱都能扛过来。每篇10分钟，总共36篇，那不才是6个小时嘛，肯定没问题。
但是，写了之后我发现，自己会是一回事儿，能讲给别人是另一回事儿，而能讲给“看不见的陌生人”听，是这世上最难的事儿。
我知道，很多技术人都有这样一个“毛病”，就是觉得掌握技术本身是最重要的，其他什么产品、市场、销售，都没技术含量。这种思维导致很多技术比较牛的人会以自我为中心，仅站在自己的角度思考问题。所以，常常是自己讲得很爽，完全不管听的人是不是真的接受了。写专栏的时候，这绝对是个大忌。
除此之外，这种思维对职业发展的影响也是很大的。单打独斗，一个人搞定一个软件的时代已经过去了。学会和别人合作，才是现代社会的生存法则，而良好的合作源于沟通。
但沟通不易，高质量的沟通更难。面对的人越多，沟通的难度就越大。因为每个人的背景、知识、基础都不同，想听的内容肯定更是千差万别。况且不是每个人都能准确地表达出自己的需求，加之需求的表达、转述都会因表达方式和传递媒介而发生变形，这样一来，接收信息的一方自然很难把握真实的需求。
写专栏的时候，“极客时间”的编辑不断地告诉我，我的受众只有一个人，就是“你”。我心想，这个简单啊，因为面对的人最少嘛！可是，事实上证明，我又“错”了。
这个抽象的“你”，看起来只有一个，其实却是看不到、摸不着的许许多多的人。所以，这个其实是最难的。协议专栏上线10天，就有10000多人订阅，而订阅专栏的用户里，只有少数人会留言。所以，对于很多读者的真实情况，我都无从得知，你可能每天都听但是没有留言的习惯，也可能买了之后觉得我讲得不好，骂一句“这钱白花了”，然后再也不听。
所以，如何把控内容，写给广大未知受众，是我写这个专栏面临的最大挑战。而这里面，文章的深度、广度，音频的语调、语气，每一个细节都非常重要。
专栏文章是怎么写的？ 经过大纲和前几篇文稿的打磨，我对“极客时间”和专栏创作也有了更深的了解。我私下和很多人交流过一个问题，那就是，咱们平时聊一个话题的时候，有很多话可以说。但是真正去写一篇文章的时候，好像又没有什么可讲的，尤其是那些看起来很基础的内容。
我在写专栏的过程中，仔细思考过这样一个问题：很多人对某一领域或者行业研究得很深入，也有自己长期的实践，但是有多少人可以从感性认识上升到理性认知的高度呢？
现在技术变化这么快，我们每个人的精力都是有限的，不少人学习新知识的方式就是看看书，看看博客、技术文章，或者听同事讲一下，了解个大概就觉得可以直接上手去做了。我也是这样的。可是一旦到写专栏的时候，基础掌握不扎实的问题一下子全都“暴露”出来了。</description></item><item><title>部署总结</title><link>https://jieye-ericx.github.io/%E9%83%A8%E7%BD%B2%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E9%83%A8%E7%BD%B2%E6%80%BB%E7%BB%93/</guid><description>利用 Obsidian 笔记创造个人知识库，自动生成个人网站数字花园 部署本花园离不开前人栽树，感谢 [[PKM]] 大佬 oldwinter 和脚本提供者 🪴 Quartz 3.3，让我认识到存在这样的个人知识库方案</description></item><item><title>长度单位</title><link>https://jieye-ericx.github.io/CSS%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/CSS%E5%9F%BA%E7%A1%80/</guid><description>长度单位 像素 px
像素是我们在网页中使用的最多的一个单位，一个像素就相当于我们屏幕中的一个小点，我们的屏幕实际上就是由这些像素点构成的但是这些像素点，是不能直接看见。不同显示器一个像素的大小也不相同，显示效果越好越清晰，像素就越小，反之像素越大。
百分比 %
也可以将单位设置为一个百分比的形式，这样浏览器将会根据其父元素的样式来计算该值使用百分比的好处是，当父元素的属性值发生变化时，子元素也会按照比例发生改变。在我们创建一个自适应的页面时，经常使用百分比作为单位。
em
em和百分比类似，它是相对于当前元素的字体大小来计算的
1em = 1font-size 使用em时，当字体大小发生改变时，em也会随之改变 当设置字体相关的样式时，经常会使用em 颜色单位 在CSS可以直接使用颜色的单词来表示不同的颜色</description></item><item><title>队头阻塞</title><link>https://jieye-ericx.github.io/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E/</guid><description>导致接收窗口的队头阻塞问题，是因为 TCP 必须按序处理数据，也就是 TCP 层为了保证数据的有序性，只有在处理完有序的数据后，滑动窗口才能往前滑动，否则就停留，停留「接收窗口」会使得应用层无法读取新的数据。</description></item><item><title>面试题</title><link>https://jieye-ericx.github.io/%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>[[redis]]
[[Go]]
[[操作系统]]
[[网络]]
![[前端面试题]]</description></item><item><title>💻技术学习笔记</title><link>https://jieye-ericx.github.io/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid><description>从18年大二开始整理技术笔记至今，看了看文件目录，记录了太多从未看过的内容，借这次重新发布[[数字花园]]的机会，在这里梳理下需要继续学习维护的部分
想想从大二到研二，好像什么都做过，但又好像什么都做不精
![[Java]]
![[前端]]
![[分布式]]
![[Python]]
![[数据库、部署、运维]]
![[Linux]]
![[网络与媒体]]
![[面试题]]</description></item><item><title>💽博文分享</title><link>https://jieye-ericx.github.io/%E5%8D%9A%E6%96%87%E5%88%86%E4%BA%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%8D%9A%E6%96%87%E5%88%86%E4%BA%AB/</guid><description>这里展示了本人摸鱼划水时写的一些以发布为目的的博客
[[JavaScript 之混淆的“类”]]
[[hexo之看板娘]]
[[利用Element实现响应式导航栏]]
1 2 3 4 5 6 7 8 9 var list=dv.pages(`&amp;#34;Notes/报告&amp;#34;`) for(let e of list){ if(e.</description></item></channel></rss>