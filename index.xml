<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AboutTheGarden on</title><link>https://jieye-ericx.github.io/</link><description>Recent content in AboutTheGarden on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://jieye-ericx.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://jieye-ericx.github.io/1-MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/1-MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</guid><description>1 MySQL的数据目录 1 MySQL8的主要目录结构 数据库文件目录 1 2 3 4 5 6 7 mysql&amp;gt; show variables like &amp;#39;datadir&amp;#39;; +---------------+-----------------+ | Variable_name | Value | +---------------+-----------------+ | datadir | /var/lib/mysql/ | +---------------+-----------------+ 1 row in set (0.</description></item><item><title/><link>https://jieye-ericx.github.io/11-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E8%8C%83%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/11-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E8%8C%83%E5%BC%8F/</guid><description>1 为什么需要数据库设计 2 范 式 2.1 范式简介 在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。可以理解为，一张数据表的设计结
构需要满足的某种设计标准的 级别 。要想设计一个结构合理的关系型数据库，必须满足一定的范式。
2.2 范式都包括哪些 目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（
1NF）、第二范式
（
2NF）、第三范式（
3NF）、巴斯-科德范式（
BCNF）、第四范式(4NF）和第五范式（
5NF，又称完美</description></item><item><title/><link>https://jieye-ericx.github.io/13-%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/13-%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>1 数据库事务概述 1.1 存储引擎支持情况 SHOW ENGINES 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。 能看出在 MySQL 中，只有InnoDB 是支持事务的。
1.2 基本概念 事务：一组逻辑操作单元，使数据从一种状态变换到另一种状态。 事务处理的原则：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(ollback )到最初状态。</description></item><item><title/><link>https://jieye-ericx.github.io/15-%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/15-%E9%94%81/</guid><description>事务的隔离性由这章讲述的锁来实现
1 概述 在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对并发操作进行控制 ，因此产生了锁 。同时锁机制 也为实现MySQL的各个隔离级别提供了保证。锁冲突也是影响数据库并发访问性能的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。
2 MySQL并发事务访问相同记录 并发事务访问相同记录的情况大致可以划分为3种：
2.1 读-读情况 读-读情况，即并发事务相继读取相同的记录。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。
2.2 写-写情况 写-写情况，即并发事务相继对相同的记录做出改动。 在这种情况下会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的，如图所示： 当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。比如，事务T1要对这条记录做改动，就需要生成一个锁结构与之关联： 在锁结构里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来：
trx信息：代表这个锁结构是哪个事务生成的。 is_waiting ：代表当前事务是否在等待。 当事务T1改动了这条记录后，就生成了一个锁结构与该记录关联，因为之前没有别的事务为这条记录加锁，所以is-waiting 属性就是 fa1se，我们把这个场景就称之为获取锁成功，或者 加锁成功，然后就可以继续执行操作了。 在事务T1提交之前，另一个事务T2也想对该记录做改动，那么先看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的 is_waiting属性值为true，表示当前事务需要等待，我们把这个场景就称之为 获取锁失败，或者 加锁失败，图示： 在事务丁1提交之后，就会把该事务生成的锁结构释放掉，然后看看还有没有别的事务在等待获取锁，发现了事务T2还在等待获取锁，所以把事务 T2 对应的锁结构的is_waiting 属性设置为false，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了。效果图就是这样： 小结几种说法：</description></item><item><title/><link>https://jieye-ericx.github.io/16-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/16-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</guid><description>1 什么是MVCC MVCC（Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的并发控制。这项技术使得在InnoDB的事务隔离级别下执行一致性读 操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。
2 快照读与当前读 MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读,而这个读指的就是快照读, 而非 当前读。当前读实际上是一种加锁的操作，是悲观锁的实现,而MVCC本质是采用乐观锁思想的一种方式。
2.1 快照读 快照读又叫一致性读，读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，即不加锁的非阻塞读,比如这样：SELECT * FROM player WHERE .</description></item><item><title/><link>https://jieye-ericx.github.io/17-%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/17-%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97/</guid><description>我们在讲解数据库事务时，讲过两种日志：重做日志、回滚日志。 对于线上数据库应用系统，突然遭遇数据库宕机,怎么办？在这种情况下，定位宕机的原因 就非常关键。我们可以查看数据库的错误日志。因为日志中记录了数据库运行中的诊断信息，包括了错误、警告和注释等信息。比如：从日志中发现某个连接中的 SQL操作发生了死循环，导致内存不足，被系统强行终止了。明确了原因，处理起来也就轻松了，系统很快就恢复了运行。 除了发现错误，日志在数据复制、数据恢复、操作审计，以及确保数据的永久性和一致性等方面，都有着不可替代的作用。
MysQL8.0官网日志地址：“https://dev.mysql.com/doc/refman/8.0/en/server-logs.html”
1 MySQL支持的日志 1.1 日志类型 MySQL有不同类型的日志文件，用来存储不同类型的日志，分为 二进制日志 、 错误日志 、 通用查询日志和 慢查询日志 ，这也是常用的4种。MySQL 8又新增两种支持的日志： 中继日志 和 数据定义语句日志 。使用这些日志文件，可以查看MySQL内部发生的事情。</description></item><item><title/><link>https://jieye-ericx.github.io/2-%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/2-%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</guid><description>2 用户与权限管理 1 用户管理 1.1 登录MySQL服务器 mysql –h hostname|hostIP –P port –u username –p DatabaseName –e &amp;quot;SQL语句&amp;quot;
参数：
-h参数 后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。 -P参数 后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306， 不使用该参数时自动连接到3306端口，port为连接的端口号。 -u参数 后面接用户名，username为用户名。 -p参数 会提示输入密码。 DatabaseName参数 指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库中，然后可以使用USE命令来选择数据库。 -e参数 后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL服务器。 举例：mysql -uroot -p -hlocalhost -P3306 mysql -e &amp;quot;select host,user from user&amp;quot;</description></item><item><title/><link>https://jieye-ericx.github.io/20220309-Safe-Reinforcement-Learning-via-Formal-Methods-Toward-Safe-Control-Through-Proof-and-Learning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/20220309-Safe-Reinforcement-Learning-via-Formal-Methods-Toward-Safe-Control-Through-Proof-and-Learning/</guid><description>Safe Reinforcement Learning via Formal Methods:
Toward Safe Control Through Proof and Learning
Abstract 正式验证为系统的安全运行提供了高度的信心，但前提是实际情况与验证模型相符。虽然一个好的模型在大多数情况下都是准确的，但即使是最好的模型也不完整。在网络物理系统中尤其如此，因为系统的高保真物理模型开发成本高昂，而且往往难于验证。相反，基于强化学习的控制器因其在未建模环境中的灵活性而受到赞扬，但不能保证安全运行。 本文提出了一种可证明安全的学习方法，它提供了两个方面的最佳效果：学习的探索和优化能力，以及形式验证的安全保障。我们的主要观点是，正式验证与经过验证的运行时监控相结合可以确保学习代理的安全。只要观察到的现实与用于离线验证的模型相符，只要学习代理将探索限制在验证控制选择的混杂范围内，验证结果就会被保留。
当检测到模型冲突时，代理放弃效率，而是尝试学习一种控制策略，将代理引导到状态空间的建模部分。我们证明，我们将安全控制的知识融入学习系统的方法可以维护安全保障，并证明我们保留了强化学习带来的经验绩效效益。我们还探索了自动驾驶汽车自适应巡航控制模型的简单模型中这些经过严格验证的推测控制器的设计空间中的各个点。</description></item><item><title/><link>https://jieye-ericx.github.io/20220309-Towards-Verifiable-and-Safe-Model-Free-Reinforcement-Learning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/20220309-Towards-Verifiable-and-Safe-Model-Free-Reinforcement-Learning/</guid><description>Towards Verififiable and Safe Model-Free Reinforcement Learning
Abstract 强化学习（Regulation Learning，RL）是一种广泛应用的机器学习体系结构，已被应用于各种决策问题，从资源管理到机器人移动，从推荐系统到系统生物学，从交通控制到超人级别的游戏。然而，除了严格控制或受限的应用之外，RL的成功有限，在安全关键场景中成功使用RL尚待实现。这种限制的一个主要原因是缺乏正式的方法来将需求指定为任务和学习约束，并在学习期间和学习后为这些需求和约束提供保证。这项工作通过提出一个总体框架来解决这些问题，该框架利用RL在学习高性能控制器方面的成功，同时保证满足给定的要求，并在安全配置中指导学习过程。
机器学习在为工业问题提供可行的解决方案方面变得越来越普遍，并开始被用来解决更接近人类的任务或与人类有关的数据。强化学习（RL）作为机器学习的一个有效分支，同样也得到了广泛的应用和越来越大的成功。RL为决策问题提供了解决方案，无论是在没有先验知识的情况下，还是在很难找到解析解的情况下[55]。这种实用的方法为RL在自动控制、博弈论、经济学和生物学等领域的应用铺平了道路</description></item><item><title/><link>https://jieye-ericx.github.io/20220310-Safe-Reinforcement-Learning-with-Model-Uncertainty-Estimates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/20220310-Safe-Reinforcement-Learning-with-Model-Uncertainty-Estimates/</guid><description>Safe Reinforcement Learning with Model Uncertainty Estimates
Abstract 目前许多自主系统的设计强烈依赖于深度神经网络（DNN）的黑盒预测。然而，DNN往往对看不见的数据的预测过于自信，并可能对远离分布的测试数据给出不可预测的结果。对于安全关键应用，例如行人周围的碰撞避免，这种分布变化具有鲁棒性的预测的重要性是显而易见的。模型不确定性的度量可以用来识别看不见的数据，但是像贝叶斯神经网络这样的最新提取方法大多难以计算。本文使用MCDropout和Bootstrapping给出了可计算的、可并行化的不确定性估计。这些方法嵌入到一个安全的强化学习框架中，在行人周围形成感知不确定性的导航。其结果是一种避碰策略，它知道自己不知道什么，并谨慎地避免行人表现出看不见的行为。 仿真结果表明，与不确定基线相比，该策略对新的观测结果更具鲁棒性，并采取更安全的措施。
1 INTRODUCTION 强化学习（RL）用于在操作、运动规划和行为预测方面产生最先进的结果。然而，底层神经网络通常缺乏产生定性预测不确定性估计的能力，并且往往对分布外的测试数据过于自信[1]–[3]。在安全关键任务中，如汽车或行人的避碰，对看不见数据的错误但自信的预测可能会导致致命故障[4]。我们研究了安全RL的方法，这些方法对看不见的观察具有鲁棒性，并且知道他们不知道什么可以在不可预测的测试用例中发出警报；最终导致更安全的行动。
一项特别具有挑战性的安全关键任务是在校园环境中使用自动穿梭巴士或漫游车避免行人[5]，[6]。人类通过理解其他行人和车辆的隐藏意图并与之互动，实现了基本上无碰撞的导航[7]，[8]。此外，大多数情况下，这种互动是在没有语言交流的情况下完成的。我们之前的工作使用RL捕捉隐藏的意图，并在行人周围实现协作导航[9]–[11]。然而，RL方法总是面临着从模拟到现实世界的通用性问题，并且无法保证在远离训练测试数据的情况下的性能。如第一节所示，仅针对协作行人的示例策略可能无法推广到现实世界中的非协作行人。
经过训练的策略将输出一个最佳猜测策略，该策略可能会假设协作行为，并且在不标记新观察的情况下，会失败。为了避免此类故障情况，本文开发了一个安全的RLdynamic避碰框架，以模型不确定性的形式表达新的观察结果。如图6所示，该框架进一步解释了不确定性，并谨慎地避免了高不确定性区域。
现有的安全RL研究大多集中在使用外部新奇探测器或内部修改来识别环境或模型不确定性[12]。请注意，我们的工作以模型不确定性估计为目标，因为它们可能会揭示训练数据稀疏的测试数据部分，并且模型可能无法概括[13]。风险敏感RL（RSRL）的工作通常关注环境的不确定性，以检测和避免高风险事件，这些事件的发生概率低，但成本高[14]–[18]。RSRL中的其他工作针对MDP中的模型不确定性，但不容易应用于神经网络[15]，[19]。我们的工作主要与风险敏感的RL方法正交，并且可以组合成一个RL策略，该策略对看不见的数据具有鲁棒性，对高风险事件敏感。
这里上面作者并没有把他们的东西和现有的RL的区别讲清晰？
总结提取模型不确定性的困难，阐述自己方法的优势 由于给定观测值的模型结果是确定性的，因此从经过区分训练的神经网络中提取模型不确定性是复杂的。大多数情况下，贝叶斯神经网络用于提取模型不确定性，但需要对网络结构进行重大重组[20]。此外，即使是近似形式，如马尔可夫链蒙特卡罗[20]或变分方法[21]–[23]，也会带来大量计算成本，并具有与样本相关的精度[2]、[20]、[24]。我们的工作使用Monte Carlo Dropout（MC Dropout）[25]和bootstrapping[26]给出了神经网络的可并行和计算上可行的不确定性估计，而无需显著重构网络结构[27]，[28]。</description></item><item><title/><link>https://jieye-ericx.github.io/3-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/3-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</guid><description>1 逻辑架构剖析 1.1 服务器处理客户端请求 服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢?这里以查询请求为例展示:
1.2 Connectors 1.3 第1层:连接层 系统(客户端)访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。 经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。</description></item><item><title/><link>https://jieye-ericx.github.io/6-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/6-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>6 索引的数据结构 1. 为什么使用索引 索弓是存储弓|擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分， 通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL 中也是一样的道理， 进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。
假如给数据使用 二叉树 这样的数据结构进行存储，如下图所示
二叉搜索树， 采用这种存储结构搜索数据的时间，复杂度是 log2N。
2. 索引及其优缺点 2.1 索引概述 MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。</description></item><item><title/><link>https://jieye-ericx.github.io/9-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/9-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>9 性能分析工具的使用 1.数据库服务器的优化步骤 当我们遇到数据库调优问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。 整个流程划分成了 观察（Show status） 和 行动（Action） 两个部分。字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。
我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的SQL都有哪些，查看具体的SQL执行计划，甚至是SQL执行中的每一步的成本代价， 这样才能定位问题所在，找到了问题，再采取相应的行动。 详细解释一下这张图:
首先在S1部分，我们需要观察服务器的状态是否存在周期性的波动。如果存在周期性波动，有可能是周期性节点的原因，比如双十一、促销活动等。这样的话，我们可以通过A1这一步骤解决，也就是加缓存，或者更改缓存失效策略。 如果缓存策略没有解决，或者不是周期性波动的原因，我们就需要进一步分析查询延迟和卡顿的原因。接下来进入S2这一步,我们需要开启慢查询。慢查询可以帮我们定位执行慢的SQL语句。我们可以通过设置long_ query_ time参数定义“慢”的阈值，如果SQL执行时间超过了long_query_time, 则会认为是慢查询。当收集上来这些慢查询之后，我们就可以通过分析工具对慢查询日志进行分析。 在S3这一步骤中，我们就知道了执行慢的SQL,这样就可以针对性地用EXPLAIN查看对应SQL语句的执行计划，或者使用show profile 查看SQL中每个步骤的时间成本。这样我们就可以了解SQL查询慢是因为执行时间长，还是等待时间长。 如果是SQL等待时间长，我们进入A2步骤。在这一步骤中， 我们可以调优服务器的参数，比如适当增加数据库缓冲池等。 如果是SQL执行时间长，就进入A3步骤,这一步中我们需要考虑是索引设计的问题?</description></item><item><title/><link>https://jieye-ericx.github.io/CDN/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/CDN/</guid><description>一、什么是 CDN CDN 的全称是(Content Delivery Network)，即内容分发网络。其目的是通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因，提高用户访问网站的响应速度。
简单的说，CDN 的工作原理就是将您源站的资源缓存到位于全球各地的 CDN 节点上，用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都回您的源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验。
CDN 对网络的优化作用主要体现在如下几个方面
解决服务器端的“第一公里”问题 缓解甚至消除了不同运营商之间互联的瓶颈造成的影响 减轻了各省的出口带宽压力 缓解了骨干网的压力 优化了网上热点内容的分布 二、CDN工作原理 传统访问过程</description></item><item><title/><link>https://jieye-ericx.github.io/CSRFXSS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/CSRFXSS/</guid><description>CSRF 跨站请求伪造（Cross Site Request Forgery），是指黑客诱导用户打开黑客的网站，在黑客的网站中，利用用户的登陆状态发起的跨站请求。CSRF攻击就是利用了用户的登陆状态，并通过第三方的站点来做一个坏事。
要完成一次CSRF攻击,受害者依次完成两个步骤:
登录受信任网站A，并在本地生成Cookie 在不登出A的情况，访问危险网站B CSRF攻击
在a.com登陆后种下cookie, 然后有个支付的页面，支付页面有个诱导点击的按钮或者图片，第三方网站域名为 b.com，中的页面请求 a.com的接口，b.com 其实拿不到cookie，请求 a.com会把Cookie自动带上（因为Cookie种在 a.com域下）。这就是为什么在服务端要判断请求的来源，及限制跨域（只允许信任的域名访问），然后除了这些还有一些方法来防止 CSRF 攻击，下面会通过几个简单的例子来详细介绍 CSRF 攻击的表现及如何防御。</description></item><item><title/><link>https://jieye-ericx.github.io/css/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/css/</guid><description>1. 怎么让一个 div 水平垂直居中 1 2 3 &amp;lt;div class=&amp;#34;parent&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 简单粗暴
1 2 3 4 5 6 7 8 9 10 11 12 div.</description></item><item><title/><link>https://jieye-ericx.github.io/Docker%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Docker%E5%9F%BA%E7%A1%80/</guid><description>1 Docker简介 1.1 为什么会有docker？ 一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验 Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。 环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装?也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用Docker可以消除协作编码时“在我的机器上可正常工作”的问题。 之前在服务器配置一个应用的运行环境，要安装各种软件，就拿尚硅谷电商项目的环境来说，Java/TomcatMySQL/JDBC驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在Windows上安装的这些环境，到了Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。
传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等java为例)。而为了让这程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker镜 像的设计，使得Docker得以打过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运.作。
1.2 docker理念 Docker是基于Go语言实现的云开源项目。 Docker的主要目标是“Build, Ship[ and Run Any App,Anywhere&amp;quot;，也就是通过对应用组件的封装、分发、部署、运行等生命期的管理，使用户的APP (可以是一个WEB应用或数据库应用等等)及其运行环境能够做到“一次封装，到处运行”。</description></item><item><title/><link>https://jieye-ericx.github.io/ESLint/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/ESLint/</guid><description>关于 ESLint 关于 ESLint，它的 Slogan 是 Find and fix problems in your JavaScript code。如上文所说，它可以发现并修复你 JavaScript 代码中的问题。来看一下官网上描述 ESLint 具备的三个特性：
Find Problems。ESLint 通过静态代码分析可以快速发现代码中的问题。ESLint 可以运行在大多数文本编辑器中，并且也可以在工作流中接入 ESLint Fix Automatically。ESLint 发现的很多问题都可以自动修复 Customize。可以定制 ESLint 检查规则 基于以上描述，我们在前端工程化中可以这样使用 ESLint：</description></item><item><title/><link>https://jieye-ericx.github.io/From-Church-and-Prior-to-PSL/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/From-Church-and-Prior-to-PSL/</guid><description>1 1-4
2 4-11
3，4，5 11-16
3 Dynamic and Branching-Time Logics 3.1 Dynamic Logics 1976年，在Pnueli提议使用LTL来验证复杂计算机系统的前一年，沃恩·罗纳德普拉特（Vaughan Ronald Pratt）建议使用动态逻辑（dynamic logic）来描述指定程序，dynamic logic是模态逻辑（modal logic）的一种延伸[96]。</description></item><item><title/><link>https://jieye-ericx.github.io/Go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Go/</guid><description>输入输出 https://blog.csdn.net/weixin_44211968/article/details/124632136
字节 byte 类型也属于整型
证明了基于数组的切片，使用的底层数组还是原来的数组，一旦修改切片的元素值，那么底层数组对应的值也会被修改。
1.GMP goroutine machine processor 通知协程退出的方式 通过全局变量：如果全局变量为真就退出 如果worker中再启动goroutine，就不太好控制了 通过通道：协程在通道里面取到true就退出 使用全局变量在跨包调用时不容易实现规范和统一，需要维护一个共用的channel 通过context：通过调用ctx.Done()方法通知所有的协程退出 当子goroutine又开启另外一个goroutine时，只需要将ctx传入即可 context.</description></item><item><title/><link>https://jieye-ericx.github.io/Graph-Based-Algorithms-for-Boolean-Function-Manipulation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Graph-Based-Algorithms-for-Boolean-Function-Manipulation/</guid><description>Abstract 本文提出了一种新的表示布尔函数的数据结构和一组相关的操作算法。函数用有向无环图表示，其方式类似于Lee[1]和Akers[2]引入的表示，但对图中决策变量的顺序有进一步的限制。虽然在最坏的情况下，一个函数需要一个参数数量的大小指数图，但在典型应用程序中遇到的许多函数都有一个更合理的表示。我们的算法的时间复杂度与被操作的图的大小成正比，因此，只要图不变得太大，它就相当有效。我们给出了将这些算法应用于逻辑设计验证问题的实验结果，从而证明了我们的方法的实用性。</description></item><item><title/><link>https://jieye-ericx.github.io/GYM/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/GYM/</guid><description>Env 首先我们可以通过如下代码调用并展示（可视化）一个环境：
1 2 3 4 5 6 7 import gym env = gym.make(&amp;#39;CartPole-v0&amp;#39;) env.reset() for _ in range(1000): env.</description></item><item><title/><link>https://jieye-ericx.github.io/hexo%E4%B9%8B%E7%9C%8B%E6%9D%BF%E5%A8%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/hexo%E4%B9%8B%E7%9C%8B%E6%9D%BF%E5%A8%98/</guid><description>hexo二次元看板娘初探 基本配置好hexo后，便迫不及待地想把这萌萌的东西放在自己的博客中，配置使用整理一哈~
安装 ^93febc
根据其 官方文档的描述：
1 npm install --save hexo-helper-live2d 安装后打开博客，就能发现默认的看板娘已经出现在页面中了。
配置 整理了一份基本配置，放置在根目录下的_config.yml中：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # Live2D## https://github.</description></item><item><title/><link>https://jieye-ericx.github.io/HTTP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/HTTP/</guid><description>HTTP 基本概念 HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。
HTTP 的名字「超文本协议传输」，它可以拆成三个部分：
超文本
我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」。的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算做「文本」。
再来理解「超文本」，它就是超越了普通文本的文本，它是文字、图片、视频等的混合体最关键有超链接，能从一个超文本跳转到另外一个超文本。
HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，在经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。
OK，经过了对 HTTP 里这三个名词的详细解释，就可以给出比「超文本传输协议」这七个字更准确更有技术含量的答案：</description></item><item><title/><link>https://jieye-ericx.github.io/Image/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Image/</guid><description>一、基础知识 1.1 位图 「位图图像（bitmap），亦称为点阵图像或栅格图像，是由称作像素（图片元素）的单个点组成的。」 这些点可以进行不同的排列和染色以构成图样。当放大位图时，可以看见赖以构成整个图像的无数单个方块。扩大位图尺寸的效果是增大单个像素，从而使线条和形状显得参差不齐。
「用数码相机拍摄的照片、扫描仪扫描的图片以及计算机截屏图等都属于位图。」 位图的特点是可以表现色彩的变化和颜色的细微过渡，产生逼真的效果，缺点是在保存时需要记录每一个像素的位置和颜色值，占用较大的存储空间。常用的位图处理软件有 Photoshop、Painter 和 Windows 系统自带的画图工具等。
分辨率是位图不可逾越的壁垒，在对位图进行缩放、旋转等操作时，无法生产新的像素，因此会放大原有的像素填补空白，这样会让图片显得不清晰。
图中的小方块被称为像素，这些小方块都有一个明确的位置和被分配的色彩数值，小方格颜色和位置就决定该图像所呈现出来的样子。
可以将像素视为整个图像中不可分割的单位或者是元素。「不可分割的意思是它不能够再切割成更小单位抑或是元素，它是以一个单一颜色的小格存在。」 每一个点阵图像包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。
1.2 矢量图 所谓矢量图，就是使用直线和曲线来描述的图形，构成这些图形的元素是一些点、线、矩形、多边形、圆和弧线等，**「***它们都是通过数学公式计算获得的，具有编辑后不失真的特点。*」****例如一幅画的矢量图形实际上是由线段形成外框轮廓，由外框的颜色以及外框所封闭的颜色决定画显示出的颜色。
「矢量图以几何图形居多，图形可以无限放大，不变色、不模糊。」 常用于图案、标志、VI、文字等设计。常用软件有：CorelDraw、Illustrator、Freehand、XARA、CAD 等。</description></item><item><title/><link>https://jieye-ericx.github.io/JavaScript-%E4%B9%8B%E6%B7%B7%E6%B7%86%E7%9A%84%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/JavaScript-%E4%B9%8B%E6%B7%B7%E6%B7%86%E7%9A%84%E7%B1%BB/</guid><description>JavaScript之混淆的类 序言 学习JavaScript时，如果你已经对C++、Java等传统面向对象编程语言有一定了解，或者老师教导过你使用类(类是面向对象编程的实现核心)把过程化风格的代码转换成结构清晰的代码，那么你很自然地会想在js中使用类。如在万物皆为类的Java中，严格区分类和对象，对象由类实例化而成，继承实际上是类的扩展。但JavaScript中只有对象，没有类，这是本质上的区别，可在JavaScript中有许多模拟类的语法糖在试图掩盖这个事实，很多教程中并未对此作详细解释，而是直接教初学者使用这些语法糖，导致初学者会在无形中出现困惑。
虽然JavaScript中没有类，但俗话说“没有的才是最好的”，开发者们通过不断探索总结，成功地模拟出了“类”。由于大家定义类的方法五花八门，风格不一。对于模拟面向对象的封装、继承、多态，更有许多研究，实现办法更加晦涩，不利于JavaScript新手使用。
这就引出了本文的话题：JavaScript中类的机制。
类的封装、继承与多态 说到面向对象编程，不得不先了解类。
根据维基百科的定义，类(class)在面向对象编程中是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。有封装性、继承性、多态性三个最重要的特性。
类与继承抽象了一种代码的组织形式，一种编程领域对真实世界中问题的建模。比如，轮船可以被看做交通工具的一个特例，后者是更广泛的类，可以用Vehicle和Steamer两个类进行建模。Vehicle可以定义引擎、载人能力等几乎所有交通工具都具有的属性，而在具体的交通工具类中，定义同样的属性是没有意义的，所以在定义Steamer类时，只需声明它继承了Vehicle这个基类，那么它就能拥有基类的属性及方法。
有了Steamer类，就有了轮船的所有属性和行为，这便是类的封装。我们迫不及待地想上船航行，可类好比蓝图，正如轮船的图纸，并非真正可以交互的轮船，只有根据图纸建造出物理实物，才能上船。真的轮船便是蓝图的物理实例，本质上是对蓝图的复制，即实例化。
类的另一个核心概念是多态，指父类(基类)的通用行为可以被子类用特殊行为重写。如Vehicle类中为所有交通工具定义了一个decelerate()减速方法，默认操作是踩刹车，但在轮船的减速中，可能还需要抛锚，所以在Steamer类中，可以重写decelerate()方法，在引用Vehicle类中decelerate()方法的基础上再加一步抛锚操作。即任何方法都可引用继承层次中高层的方法(方法名可以不同)。
有以下伪代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Vehicle{ engines=1 startEngine(){ console.</description></item><item><title/><link>https://jieye-ericx.github.io/PM2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/PM2/</guid><description>简介 对于线上项目，如果直接通过 node app 来启动，如果报错了可能直接停止导致整个服务崩溃，一般监控 node 有几种方案。
supervisor: 一般用作开发环境的使用。 forever: 管理多个站点，一般每个站点的访问量不大的情况，不需要监控。 PM2: 一个进程管理工具，维护一个进程列表，可以用它来管理你的node进程，负责所有正在运行的进程，并查看node进程的状态，也支持性能监控，负载均衡等功能。 PM2 的主要特性 内建负载均衡（使用 Node cluster 集群模块） 后台运行 0 秒停机重载，我理解大概意思是维护升级的时候不需要停机.</description></item><item><title/><link>https://jieye-ericx.github.io/Python%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Python%E5%9F%BA%E7%A1%80/</guid><description>1 系统中的python 查看系统bin目录下所有的python
ls /usr/bin/python*
2 源 pip
配置文件位置：/Users/ericx/.config/pip/pip.conf
https://mirrors.tuna.tsinghua.edu.cn/help/pypi/
1 2 3 4 5 # 设置源 pip config set global.</description></item><item><title/><link>https://jieye-ericx.github.io/Pytorch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Pytorch/</guid><description>torch.dtype torch.dtype是表示torch.Tensor的数据类型的对象。PyTorch有八种不同的数据类型：
Data type dtype Tensor types 32-bit floating point torch.float32 or torch.</description></item><item><title/><link>https://jieye-ericx.github.io/Ray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Ray/</guid><description>my 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 &amp;#39;checkpoint_at_end&amp;#39; = {bool} True &amp;#39;checkpoint_freq&amp;#39; = {int} 4 &amp;#39;max_failures&amp;#39; = {int} 1000 &amp;#39;resume&amp;#39; = {bool} False &amp;#39;export_formats&amp;#39; = {list: 2} [&amp;#39;model&amp;#39;, &amp;#39;checkpoint&amp;#39;] &amp;#39;stop&amp;#39; = {dict: 1} {&amp;#39;time_total_s&amp;#39;: 14400} &amp;#39;config&amp;#39; = {dict: 8} { &amp;#39;log_level&amp;#39;: &amp;#39;ERROR&amp;#39;, &amp;#39;num_workers&amp;#39;: 1, &amp;#39;num_gpus&amp;#39;: 0, &amp;#39;horizon&amp;#39;: 1000, &amp;#39;env&amp;#39;: &amp;lt;class &amp;#39;baselines.</description></item><item><title/><link>https://jieye-ericx.github.io/react/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/react/</guid><description>第1章：React入门 1.1. React简介 1.1.1. 官网
英文官网: https://reactjs.org/
中文官网: https://react.docschina.org/
1.1.2. 介绍描述
用于动态构建用户界面的 JavaScript 库(只关注于视图)</description></item><item><title/><link>https://jieye-ericx.github.io/redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/redis/</guid><description>1.Redis 持久化机制 Redis主要提供了两种持久化机制：RDB和AOF;
RDB 默认开启，会按照配置的指定时间将内存中的数据快照到磁盛中，创建一个dump.rdb文件，Redis启动时再恢复到内存中。 Redis会单独创建fork一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。需要注意的是，每次快照持久化都会将主进程的数据库数据复制一遍，导致内存开销加倍，若此时内存不足，则会阻塞服务器运行，直到复制结束释放内存；都会将内存数据完整写入磁盛一次，所以如果数据量大的话，而且写操作频繁，必然会引起大量的 磁盘IO操作，严重影响性能，并且最后一次持久化后的数据可能会丟失。
AOF 以日志的形式记录每个写操作（读操作不记录），只需追加文件但不可以改写文件，Redis启动时会根据日志从头到尾全部执行一遍以完成数据的恢复工作。包括flushDB也会执行。 主要有两种方式触发：有写操作就写、每秒定时写（也会丢数据）。 因为AOF采用追加的方式，所以文件会越来越大，针对这个问题，新增了重写机制，就是当日志文件大到一定程度的时候，会fork出一条新进程来遍历进程内存中的数据，每条记录对应一条set语句，写到临时文件中，然后再替换到旧的日志文件（类似rdb的操作方式）。默认触发是当aof文件大小是上次重写后大小的一倍且文件大于64M时触发。当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。一般情况下，只要使用默认开启的RDB即可，因为相对于AOF,RDB便于进行数据库备份，并且恢复数据集的速度也要快很多。 开启持久化缓存机制，对性能会有一定的影响，特别是当设置的内存满了的时候，更是下降到几百reqs/s。所以如果只是用来做缓存的话，可以关掉持久化。
2.缓存雪崩、缓存穿透、缓存击穿 3.内存淘汰策略 Redis内存回收机制 Redis的内存回收主要围绕以下两个方面： 1.Redis过期策略:删除过期时间的key值 2.Redis淘汰策略:内存使用到达maxmemory上限时触发内存淘汰数据 Redis的过期策略和内存淘汰策略不是一件事，实际研发中不要弄混淆了，下面会完整的介绍两者。</description></item><item><title/><link>https://jieye-ericx.github.io/Redis%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Redis%E5%8E%9F%E7%90%86/</guid><description>1.数据类型 1 Redis键(key) keys 查看当前库所有key (匹配：keys 1) exists key判断某个key是否存在 type key 查看你的key是什么类型 del key 删除指定的key数据 unlink key 根据value选择非阻塞删除
仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</description></item><item><title/><link>https://jieye-ericx.github.io/RegExp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/RegExp/</guid><description>匹配字符规则 预定义类 量词符 边界符 \d 匹配数字,相当于[0-9] ***** 0个或者更多 ^ 一行的开头 \D 匹配非数字,相当于[^0-9] + 1个或更多，至少1个 $ 一行的结尾 \w 匹配数字、字母、下划线,相当于[A-Za-z0-9_] ?</description></item><item><title/><link>https://jieye-ericx.github.io/RL%E7%90%90%E7%A2%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/RL%E7%90%90%E7%A2%8E/</guid><description>基础 episode：从一个游戏开始到结束，叫做一个episode
loss:可以作为负的reward
Monte-Carlo(MC):
分类 是否理解环境？ 不理解环境：不尝试去理解环境，环境给什么就是什么 Model-free 理解环境：为真实世界建模 Model-based Model-based 就是在model free的基础上多一个虚拟环境 基于Policy-Based与基于Value-Based 基于概率：直接输出下一步要采取动作的概率，根据概率选取行动，可以支持连续动作 Policy Gradients 基于价值（连续动作无能为力）：而基于价值的方法输出则是所有动作的价值, 根据最高价值来选着动作 Q-Learning Sarsa 基于价值的谁价值高选谁，基于概率根据概率执行动作 更新 回合更新：回合结束后更新行为准则 基础Policy Gradients Monte-carlo Learning 单步更新：每一步都更新准则 Q-Learning Sarsa 升级版Policy Gradients 在线与否 在线学习 边玩边学，sarsa、sarsa(lambda) 离线学习 学完再玩，Q Learning、Deep Q Network 现在，如果我们知道MDP中的所有东西，那么我们可以不用在环境中做出动作便可直接求解，我们通常称在执行动作前作出的决策为规划(planning)，那么一些经典的规划算法能够直接求解MDP问题，包括值迭代和策略迭代等。</description></item><item><title/><link>https://jieye-ericx.github.io/Safe-Deep-Reinforcement-Learning-for-Multi-Agent-Systems-with-Continuous-Action-Spaces/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Safe-Deep-Reinforcement-Learning-for-Multi-Agent-Systems-with-Continuous-Action-Spaces/</guid><description>相关 Safe Exploration in Continuous Action Spaces (Dalal et al., 2018)
Multi-agent actor-critic for mixed cooperative competitive environments (Lowe et al.</description></item><item><title/><link>https://jieye-ericx.github.io/Safe-Exploration-in-Continuous-Action-Spaces/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Safe-Exploration-in-Continuous-Action-Spaces/</guid><description>Abstract 我们解决了在物理系统（如数据中心冷却装置或机器人）上部署强化学习（RL）代理的问题，在这些系统中，决不能违反关键约束。
我们展示了如何利用这些系统典型的平滑动力学，并使RL算法在学习过程中从不违反约束。**我们的技术是直接在策略中添加一个安全层，该安全层通过分析解决每个状态下的动作校正公式。**获得一个优雅的闭式解的新颖性是由于一个线性化模型得到的，该模型是根据过去由任意动作组成的轨迹得到的。这是为了模拟真实世界中的情况，在这种情况下，数据日志是使用无法用数学方法描述的行为策略生成的； 这种情况使得已知的安全意识的off-policy方法不适用。我们在新的基于物理的典型环境中证明了我们的方法的有效性，并在奖励塑造失败时，通过保持零约束违反而获胜。
1. Introduction 在过去二十年中，RL主要在玩具环境（Sutton&amp;amp;Barto，1998）和视频游戏（Mnih等人，2015）中进行探索，其中现实世界的应用仅限于一些典型的用例，如推荐系统（Shani等人，2005）。然而，RL最近也在物理世界中找到了工业应用的道路；e、 g.、数据中心冷却（Evans&amp;amp;Gao，2016）、机器人技术（Gu等人，2016）和自动驾驶车辆（Sallab等人，2017）。在所有这些使用案例中，安全性是一个关键因素 ：除非从部署的第一刻起就彻底解决并确保安全操作，否则RL被视为与它们不兼容。
在上述实际应用中，约束是问题描述不可或缺的一部分永远不违反这些原则通常是绝对必要的，因此，在这项工作中，我们的目标是在整个学习过程中保持零约束违反。请注意，对于离散动作空间，实现这一目标比对于连续动作空间更简单。例如，可以在脱机数据上预先训练约束冲突分类器，以修剪不安全的操作。然而，在我们的环境中，由于候选动作的数量是无限的，这一目标变得更具挑战性。尽管如此，我们确实能够在连续的行动空间中实现这一目标，并且在整个学习过程中从不违反约束。
具体来说，我们解决了物理系统中的安全控制问题，其中某些可观测量将受到约束。举例说明，在数据中心冷却的情况下，温度和压力应始终保持在各自阈值以下；机器人不得超过角度和扭矩限制；而且，自动驾驶车辆必须始终保持与障碍物的距离在一定范围内。在这项工作中，我们将这些量表示为安全信号。由于这些是物理量，我们利用它们的平滑性来避免意外的、不安全的操作。此外，我们通过可用的历史数据处理些常见情况；因此，它可以用于预训练模型，以帮助从初始RL部署时刻开始的安全性。
如上所述，安全勘探传统上要求访问使用某些已知行为策略生成的数据，并在此基础上进行逐步安全更新；参见（Thomas，2015）对此类off-policy方法的全面研究。这些数据是必要的，因为除非另有假设，否则一个state下的action可能会在未来产生灾难性后果。因此，在部署之前，应提前推断长期行为。相反，在这项工作中，我们不需要行为策略知识，因为我们关注的是物理系统，其行为具有相对短期的后果。避免行为政策知识是我们工作中的一个关键优势，因为缺乏此类数据是一个具有挑战性但又熟悉的现实情况。复杂系统中过去的轨迹很少是使用一致的能数学描述的行为策略生成的。？？这类系统传统上由人工或复杂软件控制，其逻辑很难理解。因此，在这种情况下， off-policy RL方法被视为不适用。相反，我们展示了如何有效利用单步过渡数据来确保安全性。为了证明我们的方法与行为策略的独立性，在我们的实验中，我们用纯粹随机的动作生成了预训练数据。
我们的方法依赖于一个模型的一次性初始预训练，该模型预测在单个时间步长内安全信号的变化。该模型的优点在于其简单性：它是关于action的一阶近似值，其系数是状态反馈神经网络（NN）的输出。然后，我们在安全层中使用该模型，该安全层在agent的策略之上，以便在需要时纠正action；也就是在每次策略查询之后，它解决了一个找到对action的最小更改以满足安全约束的优化问题，由于与动作有关的线性关系，可以解析地导出闭合形式的解，并相当于基本的算术运算。因此，我们的安全层是可微的，并且有一个简单的三行软件实现。请注意，与我们的安全机制相关的“安全层”纯粹是语义上的选择；它只是一个简单的计算，不局限于当今流行的深度策略网络，并且可以应用于任何连续控制算法（不一定基于RL）。
2. Related Work 由于这项工作侧重于具有连续状态和动作空间的控制问题，我们将比较局限于在策略优化的背景下安全RL的性质，该策略优化试图在学习过程中保持安全。例如（Achiam et al.</description></item><item><title/><link>https://jieye-ericx.github.io/Scalable-Synthesis-of-Verified-Controllers-in-Deep-Reinforcement-Learning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Scalable-Synthesis-of-Verified-Controllers-in-Deep-Reinforcement-Learning/</guid><description>Scalable Synthesis of Verified Controllers in Deep Reinforcement Learning 深度强化学习中验证控制器的可伸缩综合
Abstract 最近，人们对设计核查有着极大的兴趣管理关键安全的学习型控制器（LEC）技术系统。鉴于控制此类控制器行为的神经策略不透明且缺乏可解释性，许多现有方法通过使用 shields（一种动态监测和维修机制）加强安全性能，确保LEC不会发出将违反预期的安全条件。然而，随着问题维度和客观复杂性的增加，这些方法已显示出明显的可扩展性限制 。
在本文中，我们提出了一种新的自动验证pipeline，它能够合成高质量的安全shield，即使问题域涉及数百个维度，或者所需目标涉及随机扰动、liveness因素和其他复杂的非功能特性。
我们的主要见解涉及将安全验证与神经控制器培训分离，并使用预先计算的验证安全屏蔽来约束培训过程。在一系列高维深RL基准上的实验结果证明了我们方法的有效性。
1 Introduction 深度强化学习（DRL）已被证明是为各种网络物理系统（CPS）实施自主控制器的强大工具[20,13,24]。由于这些学习型控制器（LEC）旨在在安全关键环境中运行，因此最近人们对开发验证方法产生了极大兴趣，以确保其行为符合预期的安全特性[14,31,2,34,3,19]。虽然这些不同的方法都为控制器的安全性提供了强有力的保证，但在问题维度和客观复杂性方面，扩展它们的技术已被证明是具有挑战性的。试图静态验证神经控制器始终保持所需安全保证的方法可能会拒绝偶尔违反安全性的高质量控制器[14,31]。 或者，动态监控控制器动作的技术，当这些动作可能导致不安全状态时触发安全防护罩，要求防护罩的行为与神经控制器的行为紧密一致，神经控制器的行为通常除了安全性外，还接受各种性能目标的培训[3,34]。平衡这些相互竞争的目标，一方面确保安全，另一方面最大化目标回报，这本身就带来了一系列挑战，可能会损害可验证性、性能和安全性。</description></item><item><title/><link>https://jieye-ericx.github.io/Sharing-the-data-center-network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Sharing-the-data-center-network/</guid><description>Sharing the Data Center Network
Abstract 虽然今天的数据中心在许多不合作的应用程序之间进行多路复用，但它们缺乏有效的手段来共享网络。正如我们在生产数据中心的实验所显示的那样，依赖TCP的拥塞控制，网络将面临拒绝服务攻击和性能干扰。我们提出了Seawall，这是一种网络带宽分配方案，根据管理员指定的策略划分网络工作容量。 Seawall通过拥挤控制、点对多点、边对边隧道的隧道交通来计算和执行分配。无论应用程序的流量组合中有多少流、协议或目的地，最终的分配都保持稳定。与其他方案不同，Seawall可以轻松支持动态的政策更改，并可根据当今数据中心的应用程序数量和流失量进行扩展。通过对原型的评估，我们发现Seawall增加的开销很小，并且实现了很强的性能隔离。
1 INTRODUCTION 数据中心对于提供当今互联网业务（包括网络搜索、内容分发和社交网络）所需的大量计算和存储资源至关重要。为了实现成本效率和按需扩展，云数据中心[5,28]是高度复用的共享环境，来自多个租户的虚拟机和任务共存于同一集群中。由于这些应用程序来自不相关的客户，它们在很大程度上是不协调的，相互不信任的。因此，网络性能干扰和拒绝服务攻击的可能性很高，因此性能可预测性仍然是客户评估迁移到云数据中心的关键问题[8]。
虽然数据中心提供了许多机制来调度本地计算、内存和磁盘资源[10,15]，但现有的网络资源分配机制却存在不足。TCP拥塞控制等终端主机机制（或TFRC和DCCP等变体）已被广泛部署，可扩展到现有流量负载，并在很大程度上通过基于流的公平性概念来决定网络共享。然而，TCP并不能将租户彼此隔离开来：设计不良或恶意的应用程序可以通过打开更多流或使用忽略拥塞控制的不符合协议实现来消耗网络容量，从而损害其他应用程序。因此，虽然使用TCP的资源分配是可伸缩的，并实现了较高的网络利用率，但它不能提供健壮的性能隔离。
交换机和路由器机制（如CoS标签、加权公平排队、预订、QCN[29]）与租户不当行为脱钩。然而，这些继承自企业网络和互联网的功能在应用于要求苛刻的云数据中心环境时用途有限，因为它们无法跟上数据中心的规模和变化（例如租户数量、新虚拟机的到达率），只能以网络利用率为代价获得隔离，或者可能需要新的硬件。
为了更好的解决方案，我们提出了Seawall，这是一种基于边缘的机制，允许管理员规定如何共享他们的网络。无论流量、协议或参与者的数量等交通特征如何，Seawall都能发挥作用。Seawall提供了一个简单的抽象：为作为流量源（VM、进程等）的每个本地实体指定一个网络权重，Seawall确保在所有网络链路上，实体获得的带宽份额与其重量成正比。为了实现效率，Seawall正在节约工作，按比例将未使用的股份重新分配给当前活跃的资源。
除了通过减轻恶意租户的DoS攻击和推广现有的资源调配模型来提高安全性之外，每个实体的权重还可以更好地控制基础设施服务。数据中心通常将对延迟和吞吐量敏感的任务与后台基础设施服务相结合。例如，客户生成的web流量与VM部署和迁移任务的需求相抗衡。每个实体的权重消除了 hand-craft每个单独服务的需要。
此外，每个实体的权重还可以更好地控制应用程序级别的目标。网络分配决策可能会对端到端指标（如完成时间或吞吐量）产生重大影响。例如，在map reduce集群中，与共享同一瓶颈的map任务相比，具有高扇入的reduce任务可以打开更多的流。基于流的公平性优先考虑高风扇，减少任务，而不是其他任务，导致进程不平衡，导致CPU资源闲置，降低集群吞吐量。相比之下，海堤将网络分配与通信模式分离。
**Seawall通过将网络共享问题简化为分布式拥塞控制，实现了可伸缩的资源分配。**TCP的普遍性表明，这种算法可以扩展到大量参与者，快速适应变化，并且可以严格在边缘实现。虽然Seawall借鉴了TCP，但Seawall的体系结构和控制回路确保了对租户不当行为的鲁性。Seawall在发送方使用一个垫片层，通过强制所有交通进入拥堵控制隧道，强制遵守政策。为了防止租户绕过Seawall，垫片层在虚拟化或平台网络堆栈中运行，在那里它与租户代码很好地隔离。
简单地对每个目的地实施一个独立的类似TCP的隧道，将允许每个源通过与更多目的地通信来实现更高的速率。由于这无法实现基于每个实体权重的期望策略，因此Seawall使用了一种新的控制回路，将来自多个目的地的反馈结合起来。</description></item><item><title/><link>https://jieye-ericx.github.io/SMARTS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/SMARTS/</guid><description>1 介绍 自动驾驶被业界视为人工智能发展的下一个风口。
随着深度强化学习（DRL）的兴起，将相关技术应用于自动驾驶领域，以消除人为导致的交通事故、减少城市停车空间等，成为业界关注的焦点。然而，自动驾驶领域的研究更多的是侧重于感知和预测，与此相对应，在各大学术会议上举办的自动驾驶评测大赛（如CVPR WAD挑战赛、CARLA 自动驾驶挑战赛等）几乎都是以自动驾驶视觉为核心，而不是规划和决策。
另一方面，自动驾驶以及云计算、大数据的发展也推动了智慧交通这一更大领域的发展。阿里巴巴、腾讯、京东、华为、滴滴等公司均从交通切入智慧城市，大力推广“城市大脑”的概念，而未来的自动驾驶也将与智慧交通更紧密结合。可以预见，随着自动驾驶的发展和普及，未来的智慧交通系统中将以自动驾驶车辆为主，这正是目前的自动驾驶人类驾驶数据训练和学习的模型无法有效处理的。只有引入多车交互博弈的方式，才能更大程度地激发驾驶策略的进化。 SMARTS作为首个支持MARL的自动驾驶仿真平台，将提供Simulator Core（快速且灵活地创建RL模拟环境）、Algorithm Library（集成主流的强化学习算法）、Multi-Agent Trainer（支持大多数多智能体训练范式）、Policy Zoo（支持对社会车辆的实例化）和 Scenario Studio（支持灵活的场景设置），方便参赛者在比赛过程中实现对车辆动力学行为的真实建模，并利用丰富的交通场景进行研究和应用。
Track 1: 单智能体赛道 赛道1是单智能体赛道，聚焦单智能体多车道巡航，参赛者需要训练模型控制一辆车完成复杂城市道路和车流下的智能驾驶。场景中包含直行道、路口、匝道、环岛等。车辆需要遵循预设的路线，在保证安全的前提下，尽可能快的从起点出发达到终点。
Track 2：多智能体赛道 多智能体赛道，聚焦多车协同驾驶。参赛者提交的模型需要控制多辆车完成不同任务下的协同驾驶，包括匝道、路口、环岛等。车辆需要在保证安全的前提下，尽快达到各自的目标位置。</description></item><item><title/><link>https://jieye-ericx.github.io/SMARTS_eng/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/SMARTS_eng/</guid><description>Experiments preparation We try to convert the normal training process of Agent into abstract training on the SMARTS platform. For the convenience of comparison, the experimental environment is selected from the same baseline as that in the SMARTS paper.</description></item><item><title/><link>https://jieye-ericx.github.io/SMARTS_re_che/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/SMARTS_re_che/</guid><description>Experiments preparation 我们尝试在SMARTS平台上将Agent的正常训练过程转换为抽象训练，为了方便比较，实验环境选取和SMARTS论文中同样的baseline，他们分别是
Two-Way traffific: As Figure 5e shows, agents start from either of two opposite lanes, then drive straight to the other end without colliding into each other or into social vehicles.</description></item><item><title/><link>https://jieye-ericx.github.io/SSH/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/SSH/</guid><description>SSH 是 Linux 系统的登录工具，现在广泛用于服务器登录和各种加密通信。
SSH 基本知识 SSH（Secure Shell 的缩写）是一种网络协议，用于加密两台计算机之间的通信，并且支持各种身份验证机制。
实务中，它主要用于保证远程登录和远程通信的安全，任何网络服务都可以用这个协议来加密。
SSH 是什么 历史上，网络主机之间的通信是不加密的，属于明文通信。这使得通信很不安全，一个典型的例子就是服务器登录。登录远程服务器的时候，需要将用户输入的密码传给服务器，如果这个过程是明文通信，就意味着传递过程中，线路经过的中间计算机都能看到密码，这是很可怕的。
SSH 就是为了解决这个问题而诞生的，它能够加密计算机之间的通信，保证不被窃听或篡改。它还能对操作者进行认证（authentication）和授权（authorization）。明文的网络协议可以套用在它里面，从而实现加密。
历史 1995年，芬兰赫尔辛基工业大学的研究员 Tatu Ylönen 设计了 SSH 协议的第一个版本（现称为 SSH 1），同时写出了第一个实现（称为 SSH1）。</description></item><item><title/><link>https://jieye-ericx.github.io/Taming-Formal-Verification-of-DRL-Enabling-Systems-by-Training-on-Abstract-Domains/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Taming-Formal-Verification-of-DRL-Enabling-Systems-by-Training-on-Abstract-Domains/</guid><description>终于开始看学长的这篇了
Abstract 可验证的安全性和鲁棒性保证对于安全关键的深度强化学习（DRL）系统至关重要。然而，由于系统的动态连续性和嵌入式神经网络的黑盒特性，正式验证它们是一项具有挑战性的任务。 在本文中，我们提出了一种新的基于抽象的方法来训练有限抽象域上的DRL系统，而不是在无限具体系统状态上训练。它产生在有限输入状态下运行的神经网络，使得托管DRL系统可通过模型检查技术直接验证。我们的方法与现有的DRL算法和模型检查器是正交的。 我们实现了一个原型培训和验证框架，并对一组基准问题进行了广泛的实验。实验结果表明，用该方法训练的系统能够有效地、完整地进行验证，同时其性能与未经抽象训练的系统相当。
Introduction 可验证的安全性和鲁棒性保证对于部署前的安全关键型深度强化学习（DRL）系统非常重要（Hasanbeig、Kroning和Abate 2020）。一个典型的例子是自动驾驶，出于安全考虑，这一点还有很长的路要走（Gomes 2016）。不幸的是，由于系统行为的动态连续性和嵌入在系统中的AI模型的黑盒特性，正式验证DRL系统是一项具有挑战性的任务。动态连续性导致不可数无限状态空间，从而引发臭名昭著的模型检查状态空间爆炸问题（Zhu等人。2019），而黑盒特征导致神经网络的不可解释性（Huang等人，2020）。两者都是DRL系统形式化验证的关键。
现有的DRL系统形式化验证方法大多依赖于将系统转换为可验证模型。代表性工作包括提取决策树（Bastani、Pu和Solar Lezama 2018）和程序自动策略（Verma et al.2018），合成确定性程序（Zhu et al.2019）和线性控制器（Xiong和Jagannathan 2021），转化为混合系统（Ivanov et al.2019）和星集（Tran et al.</description></item><item><title/><link>https://jieye-ericx.github.io/Vuex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Vuex/</guid><description>##1.Vuex概述
Vuex是实现组件全局状态（数据）管理的一种机制，可以方便的实现组件之间的数据共享
使用Vuex管理数据的好处： A.能够在vuex中集中管理共享的数据，便于开发和后期进行维护 B.能够高效的实现组件之间的数据共享，提高开发效率 C.存储在vuex中的数据是响应式的，当数据发生改变时，页面中的数据也会同步更新
使用 Vue 我们就不可避免的会遇到组件间共享的数据或状态。应用的业务代码逐渐复杂，props、事件、事件总线等通信的方式的弊端就会愈发明显。这个时候我们就需要 Vuex 。Vuex 是一个专门为 Vue 设计的状态管理工具。
状态管理是 Vue 组件解耦的重要手段。
2.Vuex的基本使用 Vuex 不限制你的代码结构，但需要遵守一些规则：</description></item><item><title/><link>https://jieye-ericx.github.io/web-test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/web-test/</guid><description>单元测试 首先声明一点，长期以来，前端开发的单元测试并不是在前端的开发过程中所必须的，也不是每个前端开发工程师所注意和重视的，甚至扩大到软件开发过程中单元测试这一环也不是在章程上有书面规定所要求的。但是随着每个工程的复杂化、代码的高复用性要求和前端代码模块之间的高内聚低耦合的需求，前端工程中的单元测试流程就显得很有其必要。
1.前端单元测试是什么 首先我们要明确测试是什么：
​ 为检测特定的目标是否符合标准而采用专用的工具或者方法进行验证，并最终得出特定的结果。
​ 对于前端开发过程来说，这里的特定目标就是指我们写的代码，而工具就是我们需要用到的测试框架(库)、测试用例等。检测处的结果就是展示测试是否通过或者给出测试报告，这样才能方便问题的排查和后期的修正。
​ 基于测试“是什么”的说法，为便于刚从事前端开发的同行的进阶理解，那我们就列出单元测试它“不是什么”：
需要访问数据库的测试不是单元测试
需要访问网络的测试不是单元测试
需要访问文件系统的测试不是单元测试
&amp;mdash; 修改代码的艺术
对于单元测试“不是什么”的引用解释，至此点到为止。鉴于篇幅限制，对于引用内容，我想前端开发的同行们看到后会初步有一个属于自己的理解。</description></item><item><title/><link>https://jieye-ericx.github.io/webpack4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/webpack4/</guid><description>Webpack是什么 webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。 在 webpack 看来, 前端的所有资源文件(js/json/css/img/less/&amp;hellip;)都会作为模块处理。 它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。
webpack 五个核心概念 Entry 入口(Entry)指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图。
Output 输出(Output)指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名。</description></item><item><title/><link>https://jieye-ericx.github.io/Web%E6%80%A7%E8%83%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Web%E6%80%A7%E8%83%BD/</guid><description>性能优化涉及到的分类 网络层面 构建层面 浏览器渲染层面 服务端层面 涉及到的功能点 资源的合并与压缩 图片编解码原理和类型选择 浏览器渲染机制 懒加载预加载 浏览器存储 缓存机制 PWA Vue-SSR 资源合并与压缩 http请求的过程及潜在的性能优化点 理解减少http请求数量和减少请求资源大小两个优化要点 掌握压缩与合并的原理 掌握通过在线网站和fis3两种实现压缩与合并的方法 浏览器的一个请求从发送到返回都经历了什么 动态的加载静态的资源</description></item><item><title/><link>https://jieye-ericx.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/</guid><description>https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/24%E8%AE%B2%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AE%8C/01%20%20%E5%AF%BC%E8%AE%BA%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F%E8%81%8A%E8%81%8A%E5%AE%83%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.md
分布式数据库的核心——数据分片、数据同步
数据分片 该特性是分布式数据库的技术创新。它可以突破中心化数据库单机的容量限制，从而将数据分散到多节点，以更灵活、高效的方式来处理数据。这是分布式理论带给数据库的一份礼物。 分片方式包括两种。 水平分片：按行进行数据分割，数据被切割为一个个数据组，分散到不同节点上。 垂直分片：按列进行数据切割，一个数据表的模式（Schema）被切割为多个小的模式。 数据同步 它是分布式数据库的底线。由于数据库理论传统上是建立在单机数据库基础上，而引入分布式理论后，一致性原则被打破。因此需要引入数据库同步技术来帮助数据库恢复一致性。 简而言之，就是使分布式数据库用起来像“正常的数据库”。所以数据同步背后的推动力，就是人们对数据“一致性”的追求。这两个概念相辅相成，互相作用。 sql与nosql #sql与nosql 1 数据分片 -提高数据容量和性能 水平分片：在不同的数据库节点中存储同一表的不同行。 垂直分片：在不同的数据库节点中存储表不同的表列。 分片算法 分片算法一般指代水平分片所需要的算法。经过多年的演化，其已经在大型系统中得到了广泛的实践。下面我将介绍两种最常见的水平分片算法，并简要介绍一些其他的分片算法优化思路。</description></item><item><title/><link>https://jieye-ericx.github.io/%E5%88%A9%E7%94%A8Element%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%BC%E8%88%AA%E6%A0%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%88%A9%E7%94%A8Element%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%BC%E8%88%AA%E6%A0%8F/</guid><description>开始之前 按照计划，前端使用Vue.js+Element UI，但在设计导航栏时，发现element没有提供传统意义上的页面顶部导航栏组件，只有一个可以用在很多需要选择tab场景的导航菜单，便决定在其基础上改造，由于我认为实现移动端良好的体验是必须的，所以便萌生了给其增加响应式功能的想法。
需求分析与拆解 假设我们的导航栏有logo和四个el-menu-item。
给window绑定监听事件，当宽度小于a时，四个链接全部放入右侧el-submenu的子菜单：
当宽度大于a时，右侧el-submenu不显示，左侧el-menu-item正常显示：
所以，先创建一个数组，存储所有所需的item：
1 2 3 4 5 6 navItems: [ { name: &amp;#34;Home&amp;#34;, indexPath: &amp;#34;/home&amp;#34;, index: &amp;#34;1&amp;#34; }, { name: &amp;#34;Subscribe&amp;#34;, indexPath: &amp;#34;/subscribe&amp;#34;, index: &amp;#34;2&amp;#34;}, { name: &amp;#34;About&amp;#34;, indexPath: &amp;#34;/about&amp;#34;, index: &amp;#34;3&amp;#34; }, { name: &amp;#34;More&amp;#34;, indexPath: &amp;#34;/more&amp;#34;, index: &amp;#34;4&amp;#34; } ] 监听宽度 很明显功能实现的关键是随时监听窗口的变化，根据对应的宽度做出响应，在data中，我使用screenWidth变量来存储窗口大小,保存初始打开页面时的宽度:</description></item><item><title/><link>https://jieye-ericx.github.io/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</guid><description>前端工程本质上是软件工程的一种。软件工程化关注的是性能、稳定性、可用性、可维护性等方面，注重基本的开发效率、运行效率的同时，思考维护效率。一切以这些为目标的工作都是&amp;quot;前端工程化&amp;quot;。工程化是一种思想而不是某种技术。
模块化 简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。（方便了多人协作）。
分而治之是软件工程中的重要思想，是复杂系统开发和维护的基石，这点放在前端开发中同样适用。模块化是目前前端最流行的分治手段。
模块化开发的最大价值应该是分治！ 不管你将来是否要复用某段代码，你都有充分的理由将其分治为一个模块。
JS模块化方案 AMD/CommonJS/UMD/ES6 Module等等。
CommonJS的核心思想是把一个文件当做一个模块，要在哪里使用这个模块，就在哪里require这个模块，然后require方法开始加载这个模块并且执行其中的代码，最后会返回你指定的export对象。
1 2 3 4 5 6 7 8 module.export = function() { hello: function() { alert(&amp;#34;你好&amp;#34;); } } var a = require(&amp;#39;.</description></item><item><title/><link>https://jieye-ericx.github.io/%E5%89%91%E6%8C%87Offer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%89%91%E6%8C%87Offer/</guid><description>剑指Offer 1. 替换空格 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
1 2 3 4 5 class Solution { public: void replaceSpace(char *str,int length) { } }; 这题其实就是在给定地str中找到空格，并替换成%20，由于是一个字符替换成三个字符，所以需要移动元素，如果从前往后移动，假设有n个空格，则第n个空格后面的元素都要被移动n次，很浪费时间，所以从后往前移动，并且不需要额外的数组，先计算出填补后的长度`newlength=oldnumber+n*2`,然后从后遍历直接`str[pNewlength--]=str[pOldlength];` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: void replaceSpace(char *str,int length) { if (str == NULL || length &amp;lt; 0) return; int i=0,oldLength=strlen(str),newLength=0,blanks=0; while(str[i]!</description></item><item><title/><link>https://jieye-ericx.github.io/%E5%9B%A2%E5%91%98%E6%8E%A8%E4%BC%98%E8%87%AA%E6%88%91%E8%AF%84%E4%BB%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%9B%A2%E5%91%98%E6%8E%A8%E4%BC%98%E8%87%AA%E6%88%91%E8%AF%84%E4%BB%B7/</guid><description>20211112 尊敬的老师、同学们，大家好！
我叫李魁昊，作为软院2021级专硕团支部的一员，很荣幸能在这里做推优自我介绍，我将主要从思想汇报和学习生活两方面介绍自己。
首先是思想汇报，四年前本科刚入学时，我的思想还不成熟，很单纯地觉得我不配入党，但是在大二加入校党委宣传部新宣中心后，中心内的党员老师和同学们挺身而出接受困难任务、积极参加志愿活动等行为让我完成了从觉得入党是一种任务到入党是一种责任的思想转变。大三疫情期间，班上的党员同学以及当时的女票都奋不顾身投入到了社区防疫、远程学习的事务中，我被这种无私奉献、在关键时刻挺身而出的精神感染，这更加坚定了我在研究生阶段入党的决心。
其次是学习生活方面，距开学已经两月有余，作为软件科学与技术专业的学生，我在张民老师的实验室中稳定学习着验证相关内容，同时我也成为了研会对外交流中心的志愿者，在本周日举行的奔跑丽娃活动中负责报名管理和物资采购的部分任务。
最后，我能站在这离不开组织的培养和同学们的帮助和支持，如能得到大家的投票则不甚荣幸，无论结果与否，至少没有遗憾了，请组织在实践中考察我，谢谢。
20220514 各位同学们，大家好！我叫李魁昊。
上一次推优的场景还历历在目，2022的推优就开始了，最近几个月发生了太多事，我觉得我收获了难得的经历，思想发生了巨大的改变，我想要不就讲讲我的感悟吧。
从三月下旬开始，上海开始了静态管理，可能是第一次这么做吧，从中暴露出了很多问题，看到网上各种求助等信息的爆料，心中确实，但也只能陷落于自己无法改变什么的失落中。在这样的背景下，运气不好的我被迫带着对生活环境的恐惧而不是对病毒的恐惧体验了一下上海几十万居民所经历的那些流程。
我原本以为在方舱的日子平平无奇，靠整天躺在床上消磨时光度过，后来因为发现护士们人手不够，给几百人做核酸，发饭等活动都有点混乱，患者们自发无偿组织的志愿者队伍，我也加入了其中，志愿者们有纪律的承担了一些物资整理与发放、拉饭发饭、统计诉求等任务，因为核酸在每早六点做，平时晚上也会有新入舱的患者需要协助，所以本来是熬夜小能手的我也拥有了每晚十一点睡五点半起的健康作息。
方舱生活因为参与了志愿者，收获了从未预想过的经历，果然生活本没有意义，过着过着就找到了意义。用新认识的朋友的话来说：“在方舱里，我觉得上海还有救”。
在我所在的场馆里，我很认同，这里穿着层层防护服还能保持耐心、细心的外地支援医疗队因为能够真切地感受到每一个平凡的普通人的默默付出，为了变得让这里变得更好互帮互助，与在家时铺天盖地的负面新闻对比，也许实实在在的行动，让人更加安心。</description></item><item><title/><link>https://jieye-ericx.github.io/%E5%AA%92%E4%BD%93%E8%AE%A1%E5%88%92/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%AA%92%E4%BD%93%E8%AE%A1%E5%88%92/</guid><description>something 拖了起码一年，终于在20211204开始了关于自身信息建设的计划，用两年前大三看到牙语、木易杨说等写的博客、看到无数这样的技术大佬维护着自己的自有博客的同时，在掘金、CSDN、微信公众号等平台同步制作者技术输出，我也萌生了这样的想法（拖延症害死人），在这里做一下全平台的计划总结。
技术 最主要的为技术博客
工具、框架、库、RL的学习笔记（目前能力时间上最主要的） 特别地重难点总结（可以是开发相关，也可以各种数学名词的认识理解） 特别的东西 如博客、自己的小东西？如毒鸡汤小网站 掘金 https://juejin.cn/user/settings/profile 统一个人信息 多平台个人信息必须得同步、统一
头像</description></item><item><title/><link>https://jieye-ericx.github.io/%E5%AE%89%E5%85%A8%E7%BA%A6%E6%9D%9F%E5%AE%9E%E9%AA%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%AE%89%E5%85%A8%E7%BA%A6%E6%9D%9F%E5%AE%9E%E9%AA%8C/</guid><description/></item><item><title/><link>https://jieye-ericx.github.io/%E5%AE%9E%E8%AE%AD2%E7%BE%8E%E9%A3%9F%E5%9B%A2%E8%B4%AD%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%AE%9E%E8%AE%AD2%E7%BE%8E%E9%A3%9F%E5%9B%A2%E8%B4%AD%E7%B3%BB%E7%BB%9F/</guid><description>基于web的美食团购网站实习报告 1405170212 李魁昊
负责前端（故本报告仅阐述了整个前端的渲染、通信）
实习题目与要求 包括三大类用户：游客、注册用户和管理员
用户可以按类别浏览美食信息并且可以查看最新以及往期的团购信息；
用户可以在线注册，注册成功并登录后方进行美食团购；
注册后的用户可以对商家进行投诉或提建议；
注册后的用户可以对自己的购物车进行操作，可以查看自己的订单明细；</description></item><item><title/><link>https://jieye-ericx.github.io/%E5%B7%A5%E7%A8%8B%E4%BC%A6%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%B7%A5%E7%A8%8B%E4%BC%A6%E7%90%86/</guid><description>案例分析 第一页：
“同一家外卖，同一个配送位置，同一个下单时间节点，在开通会员后，为什么配送费比非会员要高？”2020年12月14日，自媒体“漂移神父”微信公众号发文《我被美团会员割了韭菜》，质疑美团对外卖会员“杀熟”，使得杀熟这一违规操作大规模进入大众视野。
由于美团让程序员背锅的回应没有信服力，股价跌了3%，市值蒸发逾400亿，这说明人们对个人隐私数据安全、互联网企业伦理的要求逐渐变高、意识逐渐觉醒。
第二页：
不仅仅是美团，大家耳熟能详的互联网+公司几乎都被曝出过有大数据杀熟的行为，这就涉及到他们大数据杀熟的原因
技术接受模型（TAM）是用来分析影响用户接受新技术的重要因素的一种理论模型
Technology Acceptance Model (TAM) is a theoretical model used to analyze the important factors that affect users&amp;rsquo; acceptance of new technologies.</description></item><item><title/><link>https://jieye-ericx.github.io/%E5%B7%A5%E7%A8%8B%E4%BC%A6%E7%90%86%E4%B8%AA%E4%BA%BA%E8%AE%BA%E6%96%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%B7%A5%E7%A8%8B%E4%BC%A6%E7%90%86%E4%B8%AA%E4%BA%BA%E8%AE%BA%E6%96%87/</guid><description>摘要 随着信息科学技术的发展突⻜猛进，⼤数据受到越来越多的关注，逐渐成为研究热点，其应⽤发展极⼤程度地改变了⼈们的⼯作⽣活和思维⽅式。在⼤数据与众多领域的结合中，健康医疗⼤数据不容忽视。同时由于深度学习和大数据技术的爆发式增长，人工智能渗透应用于医疗卫生各个领域，为患者带来高效优质的健康服务的同时，也涌现出一系列伦理和社会治理问题。为规避和消解医学人工智能发展中可以预见的伦理风险和治理挑战，建⽴相关法规和指南，本文提出塑造医学人工智能伦理共识，建立人类主体和责任权属规则，完善法律法规体系，确定人类决策和道德主体地位，兼顾跨学科人才伦理素养的培养等启示以期推进医学人工智能伦理治理发展。
1 健康医疗⼤数据概述 1.1 概念及特征 每个⼈从出⽣到死亡的整个⽣命周期中会产⽣⼤量与健康有关的数据，⼴义上都属于健康医疗⼤数据的范畴。有学者认为信息⽹络技术应⽤于医保、公共卫⽣、药品监管等传统医疗领域，以及远程医疗、精准诊断、⼈⼯智能等新兴领域所产⽣的⼤量与健康相关的数据，均可称为健康医疗⼤数据。
1.2 应⽤现状 基于人工智能的技术能力与应用情境，可将其在医疗卫生领域的发展划分为“用于加快工作流的操作工具［ 9］1、用于辅助诊断的协作工具、用于替代决策的支持工具”三个递次层面进行分析与归纳。
为加快临床工作流程提升效率，人工智能技术应用于海量医学信息数据的管理［ 10］。将电子病历、病案记录、实验室数据、基因组学数据等收集、存储、结构化、追踪［ 11］，通过各信息系统的互联和数据挖掘，从病案资料中挖掘更多信息。AI医生&amp;amp;线上问诊通过语音识别功能提取用户病情描述，与疾病数据库匹配后推荐诊疗方案人工智能技术还可简化日常诊疗流程，以更低的成本为更广泛的人群提高健康水平［ 12］如电子病历语音录入、智能导诊分诊机器人等。
作为辅助诊断的协作工具，人工智能在医学领域中应用的比较突出的是影像学辅助诊断［ 13］。如在皮肤癌、眼部疾病等领域应用较多的病变检测和识别分类技术［ 14］，为确诊新型冠状病毒肺炎研发的AI+COVID-19诊断系统采用器官组织分割技术对肺部病变CT影像分割和诊断分析［ 15］。此外，还有智能辅助个性化诊断、人机交互辅助诊断、精准治疗辅助决策等重要发展方向处于科学研究和产品研发过程中［ 17］。</description></item><item><title/><link>https://jieye-ericx.github.io/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B-%E6%9D%8E%E5%AE%8F%E6%AF%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B-%E6%9D%8E%E5%AE%8F%E6%AF%85/</guid><description>Reinforcement Learning 0 从监督学习到强化学习 那什么是 Reinforcement Learning 呢,到目前为止，我们讲的几乎都是 Supervised Learning,假设你要做一个 Image 的 Classifier,你不只要告诉机器,它的 Input 是什么,你还要告诉机器,它应该输出什么样的 Output,然后接下来呢,你就可以 Train 一个 Image 的 Classifier</description></item><item><title/><link>https://jieye-ericx.github.io/%E6%88%91%E7%9A%84%E9%9D%A2%E7%BB%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E6%88%91%E7%9A%84%E9%9D%A2%E7%BB%8F/</guid><description>后端 腾讯 云架构平台操作系统 后端 一面 20230313 14:30 #腾讯 0.自我介绍 1.介绍项目里一个关于文件系统的（因为该部门主要是linux编程调优相关 2.平时用哪些linux命令 3.有没有接触过linux编程
算法 很简单的一道题 大概是一个&amp;quot;aa bbb aa0aa fsadfas&amp;quot;这样的串，求合法单词的最大长度，即不包含数字的单词
最后反问问题后，我简历里写了“能积极google解决问题”，他就问了kxsw相关的，这种一下子还真不知道该不该说。
今天一看已挂，估计是没有linux编程经验吧</description></item><item><title/><link>https://jieye-ericx.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%83%A8%E7%BD%B2%E8%BF%90%E7%BB%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%83%A8%E7%BD%B2%E8%BF%90%E7%BB%B4/</guid><description>[[Docker基础]]
[[PM2]] [[Nginx]] [[Redis原理]]
[[Mysql 原理]] [[Mysql 命令速查]]</description></item><item><title/><link>https://jieye-ericx.github.io/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5ECNU-VPN/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5ECNU-VPN/</guid><description>总有在 Linux 环境下连回 ecnu 服务器的需求，但是又不想丧失使用 Google 的权利，怎么办？openconnect 是一个非常好的开源软件，可以实现这一需求。
openconnect 支持 AnyConnect、Pluse Connect 等诸多高校常用的校外访问平台，可以用包：
1 sudo apt install openconnect 或</description></item><item><title/><link>https://jieye-ericx.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9-notion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9-notion/</guid><description>什么是浏览器指纹? 我们常说的指纹，都是指人们手指上的指纹，因具有唯一性，所以可以被用来标识一个人的唯一身份。而浏览器指纹是指仅通过浏览器的各种 信息，如CPU核心数、显卡信息、系统字体、屏幕分辨率、浏览器插件等组合成的一个字符串，就能近乎绝对定位一个 用户，就算使用浏览器的隐私窗口模式，也无法避免。
这是一个被动的识别方式。也就是说，理论上你访问了某一个网站，那么这个网站就能识别到你，虽然不知道你是谁，但你有一个唯一的指纹，将来无论是广告投放、精准推送、安全防范，还是其他一些关于隐私的事情，都非常方便。
实现浏览器指纹的技术点有哪些? 1、基本指纹 浏览器基本指纹是任何浏览器都具有的特征标识，比如屏幕分辨率、硬件类型、操作系统、用户代理（User agent）、系统字体、语言、浏览器插件 、浏览器扩展、浏览器设置 、时区差等众多信息，这些指纹信息“类似”人类的身高、年龄等，有很大的冲突概率，只能作为辅助识别。可以在该网址进行查看本地浏览器的基本特征，https://www.whatismybrowser.com/
2、高级指纹 浏览器高级指纹与基本指纹的区别是，基本指纹就像是人的外貌特征，外貌可以用男女、身高、体重区分，然而这些特征不能对某个人进行唯一性标识，仅使用基本指纹也无法对客户端进行唯一性判定，基于HTML5的诸多高级功能就能 生成高级指纹了。
Canvas指纹 说到高级指纹，不得不提Canvas指纹，Canvas（画布）是HTML5中一种动态绘图的标签，可以使用其生成甚至处理高级图片。
Canvas指纹的原理大致如下：
相同的HTMLCanvasElement元素绘制操作，在不同操作系统、不同浏览器上，产生的图片内容不完全相同。在图片格式上，不同浏览器使用了不同的图形处理引擎、不同的图片导出选项、不同的默认压缩级别等。在像素级别来看，操作系统各自使用了不同的设置和算法来进行抗锯齿和子像素渲染操作。即使相同的绘图操作，产生的图片数据的CRC检验也不相同。Canvas几乎已被所有主流浏览器支持，可以通过大部分的PC、平板、智能手机访问。
在线测试地址：https://www.browserleaks.com/canvas，可查看浏览器的Canvas唯一性字符串。
WebGL指纹 通过HTMLCanvasElement元素可以获取到Webgl对象（canvas.</description></item><item><title/><link>https://jieye-ericx.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/</guid><description>1. 如何实现浏览器内多个标签页之间的通信? WebSocket SharedWorker 也可以调用 localstorge、cookies 等本地存储方式。 localstorge 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信。 注意：Safari 在无痕模式下设置 localstorge 值时会抛出QuotaExceededError 的异常~~~~
2.webSocket如何兼容低浏览器？ Adobe Flash Socket ActiveX HTMLFile (IE) 基于 multipart 编码发送 XHR 基于长轮询的 XHR 引用WebSocket.</description></item><item><title/><link>https://jieye-ericx.github.io/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/</guid><description>1. Scikit-learn与特征工程 数据决定了机器学习的上限，而算法只是尽可能逼近这个上限”，这句话很好的阐述了数据在机器学习中的重要性。大部分直接拿过来的数据都是特征不明显的、没有经过处理的或者说是存在很多无用的数据，那么需要进行一些特征处理，特征的缩放等等，满足训练数据的要求。
我们将初次接触到Scikit-learn这个机器学习库的使用
Scikit-learn
Python语言的机器学习工具 所有人都适用，可在不同的上下文中重用 基于NumPy、SciPy和matplotlib构建 开源、商业可用 - BSD许可 目前稳定版本0.18 自2007年发布以来，scikit-learn已经成为最给力的Python机器学习库（library）了。scikit-learn支持的机器学习算法包括分类，回归，降维和聚类。还有一些特征提取（extracting features）、数据处理（processing data）和模型评估（evaluating models）的模块。作为Scipy库的扩展，scikit-learn也是建立在Python的NumPy和matplotlib库基础之上。NumPy可以让Python支持大量多维矩阵数据的高效操作，matplotlib提供了可视化工具，SciPy带有许多科学计算的模型。 scikit-learn文档完善，容易上手，丰富的API，使其在学术界颇受欢迎。开发者用scikit-learn实验不同的算法，只要几行代码就可以搞定。scikit-learn包括许多知名的机器学习算法的实现，包括LIBSVM和LIBLINEAR。还封装了其他的Python库，如自然语言处理的NLTK库。另外，scikit-learn内置了大量数据集，允许开发者集中于算法设计，节省获取和整理数据集的时间。</description></item><item><title/><link>https://jieye-ericx.github.io/%E7%99%BD%E6%9D%BF-2023-05-02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%99%BD%E6%9D%BF-2023-05-02/</guid><description>==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==
Text Elements %%
Drawing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 N4KAkARALgngDgUwgLgAQQQDwMYEMA2AlgCYBOuA7hADTgQBuCpAzoQPYB2KqATL ZMzYBXUtiRoIACyhQ4zZAHoFAc0JRJQgEYA6bGwC2CgF7N6hbEcK4OCtptbErHAL RY8RMpWdx8Q1TdIEfARcZgRmBShcZQUARm0ADm0eADYaOiCEfQQOKGZuAG1wMFAw MogSbggANQArAHkATgAlAGkAFQBJAC1OuA4ADQAxBAAzZQBNAHV2gEV0sshYRCrA 7CiOZWCF8sxuZ1iAVniUgGYeBNieQ/5ymH2ea+0Ui8aABheb4sgKEnVuWJvHjaU7 HQ6fW6QSQIQjKaTcADshxBKQRsQSSMhEGsW3EqDeWOYUFIbAA1ggAMJsfBsUhVAD EbyZzJ2kE0uGwpOUJKEHGIVJpdIkxOszDguECuVZEFGhHw+AAyrBthJJByNIFpUS SeSpn9JADCcSyQglTAVehBB5pTy4Rxwvk0LEsWxxdg1PcnUysdzhHBOsRHagCgBd LE8vn25hB0qLaDwPGnb4AX0JCAQxABABYUuizjms1jGCx2Fw0Kdnd8GExWJwAHKc MTcLMIlJvWKNNtYwjMAAimSgGe4owIYSxmmEfIAosFsrkgxwhPKsUI4MRcIPM06U glTkDYi2Eu8EliiBxSdxF8uqzTOUO0CP8GFisnwGG6Lg4HAlRu8bHoNC2RVEQcJQ DsDCEAgFAAEIclyEb8tStIMqMqFoeB2AiJKUCdIO+hKjqlJIUK6CMsyTIYVhOQ4X hsGcr6vKIYKVQihwYoStRlGkNhuFZEMcqKsqeJSOqIhILcECYdx1G8fhxq6vqhrF JJVG5LJBEmmaFoQFalQSVJPF4c0wh2g6SnlAZMl4fUboegC3rKZZal4UMnBQEMuD 6HKnqoJWFmqTRfFuQqhBGHiPAEo5AWye0WBQAAgiBZboMEoxgfp0V4T+pAJdxbAU NCuBbqgV74Bl0nOVkU58vFeUFSExXYnV4HMNgJLygM3CnI0fDKa17X4BMXWNMiR4 JFmpyYspRhsAY3CxpA9AEEIeKxC+5WGVkxmMVGQYQAh4HciQIVhZeS5lY5xEAAoE AgMh/qmUUVVAGnkjZUClgu50SXAgRmMIzAAOKkMdoV4qV4CPZAsrBDGr7JkAA=== %%</description></item><item><title/><link>https://jieye-ericx.github.io/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</guid><description>旅行商问题是运筹学中的一个经典问题，被广泛应用于物流线路优化、飞机航班安排、PCBA测试等社会生产工作中，本报告以该算法为主题，介绍并分析旅行商问题的解决思路，并通过一道算法题进行实践验证。
1 简介 旅行商问题（Travelling salesman problem, TSP）是组合优化中的一个NP困难问题，在运筹学和理论计算机科学中非常重要。问题内容为“给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。”该问题在1930年首次被形式化，并且是在最优化中研究最深入的问题之一。许多优化方法都用它作为一个基准。尽管问题在计算上很困难，但已经有了大量的启发式和精确方法，因此可以完全求解城市数量上万的实例，并且甚至能在误差1%范围内估计上百万个城市的相关问题。
上述经典TSP问题一般被称为CTSP，在生产实践中，针对不同的需求，又衍生出了不对称TSP即ATSP（两个城市间的距离不对称）、配送收集TSP即TSPPD（适应了物流系统中配送货物的需求）和多旅行商问题即MTSP（多个旅行商遍历多个城市）等实际问题。
2 理论分析 从图论的角度来看，该问题实质是在一个带权无向图中，找一个权值最小的哈密顿回路。目前成熟的方法有匈牙利算法、蚁群算法、破圈法等算法，本文主要介绍动态规划（Dynamic programming） 结合状态压缩的解法。
令$G=(V,E)$为带权重完全无向图，顶点集$V={0,1,2,\cdots,n}$,代表着n个城市，邻接矩阵$C$如下所示： $$ \begin{bmatrix} c_{11} &amp;amp; c_{12} &amp;amp; \cdots &amp;amp; c_{1(n-1)} &amp;amp; c_{1n} \ c_{21} &amp;amp; c_{22} &amp;amp; \cdots &amp;amp; c_{2(n-1)} &amp;amp; c_{2n} \ \vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \vdots \ c_{(n-1)1} &amp;amp; c_{(n-1)2} &amp;amp; \cdots &amp;amp; c_{(n-1)(n-1)} &amp;amp; c_{(n-1)n} \ c_{n1} &amp;amp; c_{n2} &amp;amp; \cdots &amp;amp; c_{n(n-1)} &amp;amp; c_{nn} \end{bmatrix} $$ 若节点$i$与$j$之间无直接路径，则$c_{ij}=\infin$.</description></item><item><title/><link>https://jieye-ericx.github.io/%E7%BA%A2%E6%97%97%E7%A0%94%E4%BC%9A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%BA%A2%E6%97%97%E7%A0%94%E4%BC%9A/</guid><description>加强自身建设，深化组织改革 P3
这是我们研究生会的组织架构，我们积极响应改革号召，缩减研会人数，强化凝聚作用，实行“主席团+工作部门”模式，明确职能定位，坚持精简原则，坚持从严治会，其中主席团设3人，五个中心各设1-3位中心负责人。
P4
为贯彻落实习近平总书记致全国青联十三届全委会和全国学联二十七大的贺信和党中央致词精神，我们仔细检查各项改革措施落实落细，考核评分标准表中的15项改革情况也都全部完成
助力重点工作，服务同学成长 当然我们也不忘助力重点工作，服务同学成长。去年9月我们特别邀请了蚂蚁财富的HR和校友为大家进行就业指导。
在学院组织建设方面，我们也积极参与优干评选等重大事项的举办
在志愿服务方面，我们充分发挥了学院特色，在校研会的支持下连续多年举办电脑义诊活动，帮助同学们解决电脑上的难题，同时今年新的电脑义诊会在3月12日下周日植树节举办，有需要的同学可以关注一下。
争做志愿工作，践行青年责任 去年4月至6月，中北校区划分成了三个片区分开封闭管理，对软院同学们的日常学习生活造成了较大影响，为了帮助同学们解决学习生活问题，研究生会的志愿者们积极响应号召，争先恐后地报名成为疫情防控志愿者，据不完全统计，共有30+软院研究生学子报名担任了层长，物资，搬饭志愿者等岗位，其中研会成员约有10名。
在志愿者们保证同学们物质生活的同时，精神生活也不能落下。4月1日，在校园“经典阅读季”来临之际，结合疫情形势，软件工程学院团委、学生会、研究生会举办「“疫”尽春来,心声可“阅”」线上文艺作品评论征集活动，同学们积极发表了自己制作的正能量音频、影评等文艺作品，为艰难的抗疫生活增添了不少色彩。</description></item><item><title/><link>https://jieye-ericx.github.io/%E7%BB%84%E4%BB%B6%E5%BA%93%E8%AE%BE%E8%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%BB%84%E4%BB%B6%E5%BA%93%E8%AE%BE%E8%AE%A1/</guid><description>1.前端组件库的设计原则 1.1 细粒度的考量 我们在学习设计模式的时候会遇到很多种设计原则,其中一个设计原则就是单一职责原则,在组件库的开发中同样适用,我们原则上一个组件只专注一件事情,单一职责的组件的好处很明显,由于职责单一就可以最大可能性地复用组件,但是这也带来一个问题,过度单一职责的组件也可能会导致过度抽象,造成组件库的碎片化。
举个例子，一个自动完成组件(AutoComplete),他其实是由 Input 组件和 Select 组件组合而成的,因此我们完全可以复用之前的相关组件,就比如 Antd 的AutoComplete组件中就复用了Select组件,同时Calendar、 Form 等等一系列组件都复用了 Select 组件,那么Select 的细粒度就是合适的,因为 Select 保持的这种细粒度很容易被复用.
那么还有一个例子,一个徽章数组件(Badge),它的右上角会有红点提示,可能是数字也可能是 icon,他的职责当然也很单一，这个红点提示也理所当然也可以被单独抽象为一个独立组件,但是我们通常不会将他作为独立组件,因为在其他场景中这个组件是无法被复用的，因为没有类似的场景再需要小红点这个小组件了，所以作为独立组件就属于细粒度过小,因此我们往往将它作为 Badge 的内部组件,比如在 Antd 中它以ScrollNumber的名称作为Badge的内部组件存在。</description></item><item><title/><link>https://jieye-ericx.github.io/%E8%80%83%E7%A0%94%E5%88%86%E4%BA%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E8%80%83%E7%A0%94%E5%88%86%E4%BA%AB/</guid><description>泻药~很荣幸能作为一位利益相关者分享下考研的经验。关于考研，有一说一，这件事大家懂得都懂，不懂的?那不妨参考下我的经历。
备考 政治 政治这门课呢算是道路最清晰透明的，简单概括即：背！
政治正确,拥护党的领导-&amp;gt;不及格都难。
学习大纲知识点-&amp;gt;刷选择题-&amp;gt;学习时政-&amp;gt;刷选择题-&amp;gt;做模拟卷-&amp;gt;背诵押题讲义（大题）
时间（月份） 事件 视频 书籍 占用时间 注 7、8、9 徐涛强化班视频、刷1000题 徐涛强化班 《肖秀荣1000题》 晚上1~2小时 可以看完某一章视频或书后立刻做对应选择以加深印象，空闲时可再看看错题 10 复习1000题，背诵重点如党的会议时间线、马原知识梳理图等。 腿姐强化班（看的不多） 《徐涛背诵手册》《肖秀荣1000题》 晚上1~2小时 11 隔天做一套肖8，腿4，结合背诵手册背诵重点事件。 《肖秀荣八套卷》《腿姐四套卷》 晚上1~2小时 仅做了选择题 12 肖4：完成选择，熟练背诵大题答案（即押题）；复习肖8选择题；熟练背诵腿姐押题讲义。 腿姐冲刺班 《肖秀荣四套卷》《肖秀荣八套卷》《腿姐押题讲义》 晚上3-4小时 视频(技巧or心理安慰 最后71。。不求有功但求无过</description></item><item><title/><link>https://jieye-ericx.github.io/%E8%8B%B1%E6%96%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E8%8B%B1%E6%96%87/</guid><description>闲聊 自我介绍-HR Hello interviewer, my name is Li Kuihao, I am from East China Normal University, majoring in software engineering. I am currently a graduate student, and I am looking forward to finding a post for the 24th summer internship.</description></item><item><title/><link>https://jieye-ericx.github.io/%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/</guid><description>3-1. The following data fragment occurs in the middle of a data stream for which the byte stuffing algorithm described in the text is used: A B ESC C ESC FLAG FLAG D.</description></item><item><title/><link>https://jieye-ericx.github.io/%E8%AE%A1%E7%BD%91%E7%AC%AC%E5%85%AD%E7%AB%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E8%AE%A1%E7%BD%91%E7%AC%AC%E5%85%AD%E7%AB%A0/</guid><description>6-1 In our example transport primitives of Fig. 6-2, LISTEN is a blocking call. Is this strictly necessary? If not, explain how a nonblocking primitive could be used.</description></item><item><title/><link>https://jieye-ericx.github.io/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</guid><description>趣谈网络协议 00 我是如何创作“趣谈网络协议”专栏的 我用将近半年的时间在“极客时间”写了一个专栏“趣谈网络协议”。对于我自己来讲，这真的是个非常特殊而又难忘的经历。
很多人都很好奇，这个专栏究竟是怎么一步步创作出来的，每一篇文章是怎么写出来的？自己录音频又是什么样的感受？写完整个专栏之后，我终于有时间回顾、整理一下这半年的所感所想。对我来说，这是一次难得的体验，也是一次与“极客时间”的深度沟通。
专栏是写给谁的？ 和极客时间的编辑谈妥主题之后，他们首先要求我基于约定的主题，写一个36节至50节的大纲，之后会以每周三篇的频率，文字加音频的方式发布。每篇文章的体量要求在3000字左右，录成音频大约就是10分钟。
我本来觉得写这么一个专栏根本就不是个事儿。毕竟咱也是在IT圈摸爬滚打了许多年的“老司机”，干货积累得也不少。只要是熟悉的领域，不用准备，聊个把小时都没啥问题。况且我原来还写过书、写过博客、写过公众号。所以，我对自己文字方面的能力很有自信。
至于语言方面，咱常年出入各大技术论坛，什么场子没趟过。一个两天的线下培训，咱都能扛过来。每篇10分钟，总共36篇，那不才是6个小时嘛，肯定没问题。
但是，写了之后我发现，自己会是一回事儿，能讲给别人是另一回事儿，而能讲给“看不见的陌生人”听，是这世上最难的事儿。
我知道，很多技术人都有这样一个“毛病”，就是觉得掌握技术本身是最重要的，其他什么产品、市场、销售，都没技术含量。这种思维导致很多技术比较牛的人会以自我为中心，仅站在自己的角度思考问题。所以，常常是自己讲得很爽，完全不管听的人是不是真的接受了。写专栏的时候，这绝对是个大忌。
除此之外，这种思维对职业发展的影响也是很大的。单打独斗，一个人搞定一个软件的时代已经过去了。学会和别人合作，才是现代社会的生存法则，而良好的合作源于沟通。
但沟通不易，高质量的沟通更难。面对的人越多，沟通的难度就越大。因为每个人的背景、知识、基础都不同，想听的内容肯定更是千差万别。况且不是每个人都能准确地表达出自己的需求，加之需求的表达、转述都会因表达方式和传递媒介而发生变形，这样一来，接收信息的一方自然很难把握真实的需求。
写专栏的时候，“极客时间”的编辑不断地告诉我，我的受众只有一个人，就是“你”。我心想，这个简单啊，因为面对的人最少嘛！可是，事实上证明，我又“错”了。
这个抽象的“你”，看起来只有一个，其实却是看不到、摸不着的许许多多的人。所以，这个其实是最难的。协议专栏上线10天，就有10000多人订阅，而订阅专栏的用户里，只有少数人会留言。所以，对于很多读者的真实情况，我都无从得知，你可能每天都听但是没有留言的习惯，也可能买了之后觉得我讲得不好，骂一句“这钱白花了”，然后再也不听。
所以，如何把控内容，写给广大未知受众，是我写这个专栏面临的最大挑战。而这里面，文章的深度、广度，音频的语调、语气，每一个细节都非常重要。
专栏文章是怎么写的？ 经过大纲和前几篇文稿的打磨，我对“极客时间”和专栏创作也有了更深的了解。我私下和很多人交流过一个问题，那就是，咱们平时聊一个话题的时候，有很多话可以说。但是真正去写一篇文章的时候，好像又没有什么可讲的，尤其是那些看起来很基础的内容。
我在写专栏的过程中，仔细思考过这样一个问题：很多人对某一领域或者行业研究得很深入，也有自己长期的实践，但是有多少人可以从感性认识上升到理性认知的高度呢？
现在技术变化这么快，我们每个人的精力都是有限的，不少人学习新知识的方式就是看看书，看看博客、技术文章，或者听同事讲一下，了解个大概就觉得可以直接上手去做了。我也是这样的。可是一旦到写专栏的时候，基础掌握不扎实的问题一下子全都“暴露”出来了。</description></item><item><title/><link>https://jieye-ericx.github.io/%E8%BD%AF%E4%BB%B6%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-%E9%83%A8%E5%88%86%E6%91%98%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E8%BD%AF%E4%BB%B6%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-%E9%83%A8%E5%88%86%E6%91%98%E5%BD%95/</guid><description>软件理论基础 部分摘录 参考资料 写给学生看的系统分析与验证课程笔记
有疑问的直接搜索“疑问”
公式 1 命题逻辑 1.1 命题逻辑系统语法结构 1.1.2 命题逻辑公式 由于$A\vee B$可以写成$\neg A\rightarrow B$,$A\wedge B$可以写成$\neg (A\rightarrow \neg B)$,所以上述公式可以简写为：</description></item><item><title/><link>https://jieye-ericx.github.io/%E8%BD%AF%E8%B7%AF%E7%94%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E8%BD%AF%E8%B7%AF%E7%94%B1/</guid><description>00:e0:4c:02:70:b0 0
00:e0:4c:02:70:b1 1
00:0c:29:a5:5f:ed openwrt</description></item><item><title/><link>https://jieye-ericx.github.io/%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/</guid><description>部署文档 本文档介绍了将期刊论文投稿系统部署到服务器上的过程，服务器ip为：47.103.212.239
前端部署 前端地址：http://47.103.212.239:9876
前端借助于与Github集成的持续集成部署CI/CD，使用travis自动部署服务，可以实现在使用git将本地代码提交到Github后，自动触发travis action来执行打包项目并上传到部署服务器的操作，travis配置文件如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 language:node_jsnode_js:- 16.</description></item><item><title/><link>https://jieye-ericx.github.io/-%E8%8A%B1%E5%9B%AD%E5%AF%BC%E8%A7%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/-%E8%8A%B1%E5%9B%AD%E5%AF%BC%E8%A7%88/</guid><description/></item><item><title/><link>https://jieye-ericx.github.io/-%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/-%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/</guid><description/></item><item><title>browser</title><link>https://jieye-ericx.github.io/browser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/browser/</guid><description>JS 的单线程 很多人都知道的是，JavaScript 是一门动态的解释型的语言，具有跨平台性。在被问到 JavaScript 为什么是一门单线程的语言，有的人可能会这么回答：“语言特性决定了 JavaScript 是一个单线程语言，JavaScript 天生是一个单线程语言”，这只不过是一层糖衣罢了。
JavaScript 从诞生起就是单线程，原因大概是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。
准确的来说，我认为 JavaScript 的单线程是指 JavaScript 引擎是单线程的，JavaScript 的引擎并不是独立运行的，跨平台意味着 JavaScript 依赖其运行的宿主环境 &amp;mdash; 浏览器(大部分情况下是浏览器)。</description></item><item><title>canvas</title><link>https://jieye-ericx.github.io/Canvas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Canvas/</guid><description>canvas &amp;lt;canvas&amp;gt; 是 HTML5 新增的元素，可用于通过使用JavaScript中的脚本来绘制图形，创建动画。&amp;lt;canvas&amp;gt; 最早由Apple引入WebKit.
我们可以使用&amp;lt;canvas&amp;gt;标签来定义一个canvas元素。
canvas元素默认具有高宽
width： 300px
height：150px
1.整体API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 1.</description></item><item><title>CSS3</title><link>https://jieye-ericx.github.io/CSS3-no/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/CSS3-no/</guid><description>CSS3 优势：
使用CSS3技术来控制页面元素CSS属性的变化 不需要js也能写 由浏览器执行，更加流畅 减少代码量 应用场景：
网页特效 用户交互 抽奖动画 网页小游戏 transition transition CSS 属性是 transition-property， transition-duration， transition-timing-function 和 transition-delay 的一个 简写属性。</description></item><item><title>HOMEPAGE</title><link>https://jieye-ericx.github.io/HOMEPAGE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/HOMEPAGE/</guid><description>最近编辑的笔记 1 2 3 4 table WITHOUT ID file.link AS &amp;#34;标题&amp;#34;,file.mtime as &amp;#34;时间&amp;#34; from &amp;#34;&amp;#34; sort file.mtime desc limit 10 七天内创建的笔记 1 2 3 4 5 table file.</description></item><item><title>HTML</title><link>https://jieye-ericx.github.io/html/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/html/</guid><description>iframe框架有那些优缺点 优点：
iframe能够原封不动的把嵌入的网页展现出来。 如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。 缺点：
搜索引擎的爬虫程序无法解读这种页面 框架结构中出现各种滚动条 使用框架结构时，保证设置正确的导航链接。 iframe页面会增加服务器的http请求 label标签有什么作用 label 标签通常是写在表单内，它关联一个控件，使用 label 可以实现点击文字选取对应的控件。</description></item><item><title>html</title><link>https://jieye-ericx.github.io/Html%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Html%E5%9F%BA%E7%A1%80/</guid><description>h5的文档声明，声明当前的网页是按照HTML5标准编写的
编写网页时一定要将h5的文档声明写在网页的最上边
如果不写文档声明，则会导致有些浏览器会进入一个怪异模式，
进入怪异模式以后，浏览器解析页面会导致页l面无法正常显示，所以为了避免进入该模式，一定要写文档声明
1 &amp;lt;!doctype *html*&amp;gt; 实体 1 2 3 4 5 6 7 8 9 10 11 12 13 &amp;lt;!</description></item><item><title>javaScript</title><link>https://jieye-ericx.github.io/javascript/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/javascript/</guid><description>1. mouseenter和mouseover的区别 mouseover事件：不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。
mouseenter事件：只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。
以及
mouseout事件：不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件。
mouseleave事件：只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。
2. alert（1&amp;amp;&amp;amp;2），alert（1||0） &amp;amp;&amp;amp;运算符，前面的true，返回后面的。前面的为false，返回前面的。
||运算符，前面的为true，返回前面的。前面的为false，返回后面的。
3. 为什么TCP连接需要三次握手，两次不可以吗，为什么 感觉自己还没懂，先占坑，可看知乎</description></item><item><title>Javascript基础</title><link>https://jieye-ericx.github.io/Javascript%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Javascript%E5%9F%BA%E7%A1%80/</guid><description>继承 1、原型链继承 Array.includes Array.indexOf() 构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。
继承的本质就是复制，即重写原型对象，代之以一个新类型的实例。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function SuperType() { this.</description></item><item><title>linux常用命令与环境变量</title><link>https://jieye-ericx.github.io/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid><description>linux的目录结构 打开终端，输入ls查看linux根目录下的情况
1 2 3 $ ls / ---------------- bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var /bin (/usr/bin /usr/local/bin )</description></item><item><title>Linux性能优化</title><link>https://jieye-ericx.github.io/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid><description>Linux性能优化 00开篇词 别再让Linux性能问题成为你的绊脚石 你好，我是倪朋飞，微软 Azure 的资深工程师，同时也是 Kubernetes 项目维护者，主要负责开源容器编排系统 Kubernetes 在 Azure 的落地实践。
一直以来，我都在云计算领域工作。对于服务器性能的关注，可以追溯到我刚参加工作那会儿。为什么那么早就开始探索性能问题呢？其实是源于一次我永远都忘不了的“事故”。
那会儿我在盛大云工作，忙活了大半夜把产品发布上线后，刚刚躺下打算休息，却突然收到大量的告警。匆忙爬起来登录到服务器之后，我发现有一些系统进程的 CPU 使用率高达 100%。
当时我完全是两眼一抹黑，可以说是只能看到症状，却完全不知道该从哪儿下手去排查和解决它。直到最后，我也没能想到好办法，这次发布也成了我心中之痛。
从那之后，我开始到处查看各种相关书籍，从操作系统原理、到 Linux 内核，再到硬件驱动程序等等。可是，学了那么多知识之后，我还是不能很快解决类似的性能问题。</description></item><item><title>Linux目录</title><link>https://jieye-ericx.github.io/Linux/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Linux/</guid><description>[[Linux常用命令与环境变量]] [[Linux性能优化]]
[[排坑]]</description></item><item><title>Mysql 原理</title><link>https://jieye-ericx.github.io/Mysql-%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Mysql-%E5%8E%9F%E7%90%86/</guid><description>[[1 MySQL的数据目录]]
[[2 用户与权限管理]]
[[3 逻辑架构]]
[[6 索引的数据结构]]
[[9 性能分析工具的使用]]
[[11 数据库设计规范（范式）]]
[[13 事务基础知识]]
[[15 锁]]
[[16 多版本并发控制]]
[[17 其他数据库日志]]</description></item><item><title>Nginx</title><link>https://jieye-ericx.github.io/Nginx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Nginx/</guid><description>Nginx 的产生 Nginx 同 Apache 一样都是一种 Web 服务器。基于 REST 架构风格，以统一资源描述符（Uniform Resources Identifier）URI 或者统一资源定位符（Uniform Resources Locator）URL 作为沟通依据，通过 HTTP 协议提供各种网络服务。
然而，这些服务器在设计之初受到当时环境的局限，例如当时的用户规模，网络带宽，产品特点等局限并且各自的定位和发展都不尽相同。这也使得各个 Web 服务器有着各自鲜明的特点。</description></item><item><title>Node 定时器</title><link>https://jieye-ericx.github.io/nodejs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/nodejs/</guid><description>child_process 在介绍child_process模块之前，先来看一个例子。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const http = require(&amp;#39;http&amp;#39;); const longComputation = () =&amp;gt; { let sum = 0; for (let i = 0; i &amp;lt; 1e10; i++) { sum += i; }; return sum; }; const server = http.</description></item><item><title>Obsidian探索</title><link>https://jieye-ericx.github.io/Obsidian%E6%8E%A2%E7%B4%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Obsidian%E6%8E%A2%E7%B4%A2/</guid><description>看上ob最重要的当然是其和vsc媲美的插件系统，这里整理了一些我用的插件
obsidian 插件 改成name而非id 是否必装 原因 待考察 [[Word Splitting for Simplified Chinese in Edit Mode]] y 和[[Omnisearch]]插件配合才能支持中文搜索 [[Advanced Slides]] y 预览效果不错，也可以网页打开，基于 revealjs 已经相当成熟 [[Advanced Tables]] y 这个表格就是用它写的，贼方便 [[Advanced URL]] y 别的软件link到obsidian，直达目的，[[万物互联]] 必备 [[Bartender]] 编辑左侧和下方菜单显示和顺序，有用 [[Commander]] y 自定义ob界面的各种按钮 [[DB Folder]] 界面编辑用起来还是不舒服，没有notion的体验好 [[Daily Notes Editor]] 批量处理每日日志，挺好用，但感觉要期待官方收编[[Calendar]]插件 [[Dataview]] y 待学习，有点麻烦，别人都说是神器 [[DigitalGarden]] 替代官方发布的免费方案，后面有机会尝试 [[ExcaliBrain]] 类 thebrain 的插件，给图谱引入父子和兄弟的关系 [[Janitor]] y 目前最好的批量清理笔记插件 [[LiveSync]] 通过自己的 server，进行多端同步 [[ProZen]] y 禅模式目前ob中最好的实现 [[QuickAdd]] 半自动化批量添加模板 [[Templater]] 快速插入模板，很重要 [[Admonition|admonition]] 引用美化，鲜活页面 美化quote样式，已经被内置[[Callout]] 取代 [[auto-link-title]] y 复制的网址自动获取其 title，爆赞 [[calendar]] 如果能坚持每日日记，必装 [[Linter]] y 标准化、美化 markdown [[Supercharged Links]] y 给链接加上样式，提高可识别性👍 [[Text expand]] advanced-cursors 目前不需要多光标操作 annotator 插件太重，而且读书笔记做在这里太不轻便了 chronology 以日历的形式显式文件编辑历史 cmenu 编辑菜单很重要，而且支持定制 [[cmenu学习笔记]]，貌似没多大用，用命令行就行了 code-block-copy 程序员必备：复制代码太方便了，以后应该会自带 creases 长文的局部折叠局部展开工具 customizable-menu 自定义右键菜单 customizable-page-header-buttons y 可以给每个 page 加按钮，以及最右上角，有用，符合使用逻辑 customizable-sidebar 自定义侧边图标 cycle-through-panes 用快捷键快速在已打开的 pages 切换 dynamic-toc 动态目录，发布的时候很有用 excalidraw-plugin 图中加入双链的场景很诱人，待持续探索 没看到内置画图的必要性，可以用更专业工具 find-unlinked-files 批量整理悬空文件，有利于回顾 focus-mode y 页面最大化或全局最大化都很有用 footnotes 便捷插入 footnote 有用 hider 就是美化用的，隐藏界面各个面板，但感觉没必要 hover-editor y 预览的窗口也可以有更多操作 icon-folder 给文件列表的文件夹和文件加 emoji，更有视觉美感和记忆感 icons-plugin 很有用，各种网站 logo 都能快速搜索到 image-auto-upload-plugin y 神器，markdown 一键粘贴图片 link-favicon 给外链添加图标，增加可识别性，和 [[Supercharged Links]] 互补 longform 将日记批量合并到月记里面，以及其他写小说场景 mrj-text-obsidian y 将搜索结果记录下来，从而实现 dataview 的补充效果 note-refactor [[note-refactor学习笔记]] 待真正场景使用 notion-like-tables 通过最少侵入，引入好用表格 obsidian-git 它自动刷 commit，挺好，目前自动的时候会卡 不行，太卡了，自己自动 git 更好 obsidian42-brat y 装未上架的插件方便 outliner 装了它，高频使用的多级列表的编辑非常爽 pandoc 目前还没用到导出功能 pane-relief y 给返回前进按钮加上历史记录 periodic-notes 和 calendar 一样，能坚持必装 quick-explorer y 在菜单栏显示当前文件所在文件夹路径，不知道是否有性能问题？ recent-files y 自带的 cmd +o 只能查看近 10 个，这个有 30 个而且有常驻按钮 sliding-panes y 横向无限滑动场景有时候很有用 spaced-repetition y 间隔复习，知识完美闭环，必装 [[Spaced Repetition]] tag-wrangler y 批量更改标签必用 timelines time 使用起来太麻烦了 tracker 使用起来太麻烦了 various-complements y 自动补全智能提示 vault-statistics 快捷查看统计当前库的总数据 weread-plugin y 将微信读书的笔记批量自动同步过来 zoom 目前感觉不实用，而且有 bug 点击没反应有时</description></item><item><title>Python目录</title><link>https://jieye-ericx.github.io/Python/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Python/</guid><description>[[强化学习课程-李宏毅]]
[[特征工程]]
[[GYM]]
[[Python基础]]
[[Pytorch]]
[[Ray]]
[[RL琐碎]]</description></item><item><title>typescript</title><link>https://jieye-ericx.github.io/typescript/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/typescript/</guid><description>一、TypeScript 是什么 TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。
TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。下图显示了 TypeScript 与 ES5、ES2015 和 ES2016 之间的关系：</description></item><item><title>Vue</title><link>https://jieye-ericx.github.io/Vue2%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Vue2%E5%9F%BA%E7%A1%80/</guid><description>之前学习很有问题，只看视频不记笔记，直接把机构的笔记复制来也不整理，痛定思痛，特整理如下。
Vue 是什么？ Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架 Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue.</description></item><item><title>Vue&amp;React</title><link>https://jieye-ericx.github.io/vuereact/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/vuereact/</guid><description>Vue和React区别 监听数据变化的实现原理不同 Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能 React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的VDOM的重新渲染 为什么 React 不精确监听数据变化呢？这是因为 Vue 和 React 设计理念上的区别，Vue 使用的是可变数据，而React更强调数据的不可变。所以应该说没有好坏之分，Vue更加简单，而React构建大型应用的时候更加鲁棒。
因为一般都会用一个数据层的框架比如 Vuex 和 Redux，所以这部分不作过多解释，在最后的 vuex 和 redux的区别 中也会讲到。</description></item><item><title>Vue3快速上手</title><link>https://jieye-ericx.github.io/Vue3%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Vue3%E5%9F%BA%E7%A1%80/</guid><description>Vue3快速上手 1.Vue3简介 2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王） 耗时2年多、 2600+次提交、 30+个RFC、 600+次PR、 99位贡献者 github上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0 2.Vue3带来了什么 1.性能的提升 打包大小减少41% 初次渲染快55%, 更新渲染快133% 内存减少54%
…… 2.</description></item><item><title>上下文</title><link>https://jieye-ericx.github.io/%E4%B8%8A%E4%B8%8B%E6%96%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E4%B8%8A%E4%B8%8B%E6%96%87/</guid><description>上下文
Context 在许多编程语言/框架中都出现，曾几何时，我难以理解这个单词的含义</description></item><item><title>分布式目录</title><link>https://jieye-ericx.github.io/%E5%88%86%E5%B8%83%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%88%86%E5%B8%83%E5%BC%8F/</guid><description>关于分布式 20230314 也看过不少面试题和博客了，但感觉一直无法完全理解，所以有了这篇总结
分布式数据库</description></item><item><title>前端</title><link>https://jieye-ericx.github.io/%E5%89%8D%E7%AB%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%89%8D%E7%AB%AF/</guid><description>前端是学的最久最多的了，bilibili的实习也是前端居多，在转后端面前，这些好像又失去了作用
浏览器相关
[[browser]]
Web安全
[[同源策略]]
[[CSRFXSS]]
[[包管理工具]]
[[移动Web与响应式]]
框架
[[react]]
[[Vue2基础]]
[[Vue3基础]]
[[Vuex]]
[[Diff]]
构建工具
[[webpack4]]
webpack5相关在notion中，等待搬运
基础知识
[[CSS3 no]]</description></item><item><title>前端面试题</title><link>https://jieye-ericx.github.io/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>[[浏览器相关]]
[[css]]
[[html]]
[[javascript]]
[[vue&amp;amp;react]]</description></item><item><title>包管理工具</title><link>https://jieye-ericx.github.io/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>npm 1 2 3 # 查看文件路径 npm config get userconfig npm config get globalconfig proxy 1 2 3 4 5 npm config set proxy http://127.</description></item><item><title>同源策略</title><link>https://jieye-ericx.github.io/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</guid><description>同源的定义 同源策略是一个重要的安全策略，它用于限制一个 origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。
Origin
Web内容的源由用于访问它的 URL 的方案(协议)，主机(域名)和端口定义。只有当方案，主机和端口都匹配时，两个对象具有相同的起源。
同源的例子
http://example.com/app1/index.html http://example.com/app2/index.html same origin because same scheme (http) and host (example.</description></item><item><title>命令速查</title><link>https://jieye-ericx.github.io/Mysql-%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Mysql-%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</guid><description>命令速查 重要！进行用户相关操作后记得刷新权限！！！FLUSH PRIVILEGES;
列出所有数据库
show databases;
删除数据库
drop database name;
新建数据库
create database name;</description></item><item><title>基本知识</title><link>https://jieye-ericx.github.io/%E7%A7%BB%E5%8A%A8Web%E4%B8%8E%E5%93%8D%E5%BA%94%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%A7%BB%E5%8A%A8Web%E4%B8%8E%E5%93%8D%E5%BA%94%E5%BC%8F/</guid><description>基本知识 视口 视口（viewport）就是浏览器显示页面内容的屏幕区域。最先由 Apple 引入，用于解决移动端页面的显示问题，通过一个叫 &amp;lt;meta&amp;gt; 的 DOM 标签，允许我们可以定义视口的各种行为，比如宽度，高度，初始缩放比例等，视口可以分为布局视口、视觉视口和理想视口。
布局视口 layout viewport 一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的PC端页面在手机上显示的问题。
layout viewport 是一个固定的值，由浏览器厂商设定，
IOS 和 Android 基本都是 980px 黑莓（BlackBerry）和 IE10 是 1024px 在PC端上，布局视口等于浏览器窗口的宽度 所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。</description></item><item><title>排坑</title><link>https://jieye-ericx.github.io/%E6%8E%92%E5%9D%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E6%8E%92%E5%9D%91/</guid><description>locale 的报错 LC_CTYPE / LC_ALL 问题 如果输入 locale 查看系统字体编码，可能会出现如下报错
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 locale: Cannot set LC_CTYPE to default locale: No such file or directory locale: Cannot set LC_ALL to default locale: ?</description></item><item><title>数字花园</title><link>https://jieye-ericx.github.io/%E6%95%B0%E5%AD%97%E8%8A%B1%E5%9B%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E6%95%B0%E5%AD%97%E8%8A%B1%E5%9B%AD/</guid><description>定义 数字花园是通过借助网络数字工具，对想法、笔记和思考等一切你感兴趣的信息或进行收集、整理和创作，文字之间用标签或链接创建连接，形成一座独具个人浓厚色彩的信息与知识型花园。
这个花园是开放的，不可避免地至少要经常打理。
数字花园介于笔记本和博客之间的交叉空间，具有半公开性质。
不像笔记内容的纯私人性一样，数字花园鼓励用户发布自己的想法、草稿，这在很大程度上降低了我们的发布压力。
同时，数字花园不像博客那样完全公开，以建立个人品牌作为内容发布的主要目的。</description></item><item><title>系统</title><link>https://jieye-ericx.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid><description>进程间通信 1、无名管道( pipe )；2、高级管道(popen)；3、有名管道 (named pipe)；4、消息队列( message queue )；5、信号量( semophore )；7、共享内存( shared memory )；8、套接字( socket )。
线程间通信 1.锁机制：包括互斥锁、条件变量、读写锁 2.信号量机制(Semaphore) 3.信号机制(Signal)</description></item><item><title>综合</title><link>https://jieye-ericx.github.io/%E7%BD%91%E7%BB%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%BD%91%E7%BB%9C/</guid><description>综合 1.当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？ 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。 下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。 最后一步是 TCP 断开连接的四次挥手过程。 2.</description></item><item><title>网络与媒体</title><link>https://jieye-ericx.github.io/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AA%92%E4%BD%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AA%92%E4%BD%93/</guid><description>[[趣谈网络协议]]
[[CDN]]
[[HTTP]]
[[Image]]
[[RegExp]]
[[SSH]]</description></item><item><title>虚拟DOM和diff算法</title><link>https://jieye-ericx.github.io/Diff/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/Diff/</guid><description>虚拟DOM和diff算法 snabbdom安装配置 snabbdom是瑞典语单词，单词原意“速度”,在IT方面是著名的虚拟DOM库，是diff算法的鼻祖，Vue源码就借鉴了snabbdom。官方git：https://github.com/snabbdom/snabbdom。
在git上的snabbdom源码是用TypeScript写的，git上并不提供编译好的JavaScript版本，因此如果要直接使用build出来的JavaScript版的snabbdom库，可以从npm上下载：
npm i -D snabbdom
snabbdom库是DOM库，当然不能在nodejs环境运行，所以我们需要搭建webpack和webpack-dev-server开发环境，好消息是不需要安装任何loader。
这里需要注意，必须安装最新版webpack@5，不能安装webpack@4，这是因为webpack4没有读取身份证中exports的能力。
npm i -D webpack@5 webpack-cli@3webpack-dev-server@3
webpack.config.js配置为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 从https://www.</description></item><item><title>长度单位</title><link>https://jieye-ericx.github.io/CSS%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/CSS%E5%9F%BA%E7%A1%80/</guid><description>长度单位 像素 px
像素是我们在网页中使用的最多的一个单位，一个像素就相当于我们屏幕中的一个小点，我们的屏幕实际上就是由这些像素点构成的但是这些像素点，是不能直接看见。不同显示器一个像素的大小也不相同，显示效果越好越清晰，像素就越小，反之像素越大。
百分比 %
也可以将单位设置为一个百分比的形式，这样浏览器将会根据其父元素的样式来计算该值使用百分比的好处是，当父元素的属性值发生变化时，子元素也会按照比例发生改变。在我们创建一个自适应的页面时，经常使用百分比作为单位。
em
em和百分比类似，它是相对于当前元素的字体大小来计算的
1em = 1font-size 使用em时，当字体大小发生改变时，em也会随之改变 当设置字体相关的样式时，经常会使用em 颜色单位 在CSS可以直接使用颜色的单词来表示不同的颜色</description></item><item><title>面试题</title><link>https://jieye-ericx.github.io/%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>[[剑指Offer]]
[[redis]]
[[Go]]
[[操作系统]]
[[网络]]
![[前端面试题]]</description></item><item><title>💻技术学习笔记</title><link>https://jieye-ericx.github.io/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid><description>从18年大二开始整理技术笔记至今，看了看文件目录，记录了太多从未看过的内容，借这次重新发布[[数字花园]]的机会，在这里梳理下需要继续学习维护的部分
想想从大二到研二，好像什么都做过，但又好像什么都做不精
![[前端]]
![[分布式]]
![[Python]]
![[数据库、部署、运维]]
![[Linux]]
![[网络与媒体]]
![[面试题]]</description></item><item><title>💽博文分享</title><link>https://jieye-ericx.github.io/%E5%8D%9A%E6%96%87%E5%88%86%E4%BA%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E5%8D%9A%E6%96%87%E5%88%86%E4%BA%AB/</guid><description>这里展示了本人摸鱼划水时写的一些以发布为目的的博客
[[hexo之看板娘]]
[[利用Element实现响应式导航栏]]
[[JavaScript 之混淆的“类”]]</description></item></channel></rss>