<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="1 逻辑架构剖析 1.1 服务器处理客户端请求 服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢?这里以查询请求为例展示:
  1.2 Connectors 1.3 第1层:连接层 系统(客户端)访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。 经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。"><meta property="og:title" content="3 逻辑架构"><meta property="og:description" content="1 逻辑架构剖析 1.1 服务器处理客户端请求 服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢?这里以查询请求为例展示:
  1.2 Connectors 1.3 第1层:连接层 系统(客户端)访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。 经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。"><meta property="og:type" content="website"><meta property="og:image" content="https://jieye-ericx.github.io/icon.png"><meta property="og:url" content="https://jieye-ericx.github.io/3-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="3 逻辑架构"><meta name=twitter:description content="1 逻辑架构剖析 1.1 服务器处理客户端请求 服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢?这里以查询请求为例展示:
  1.2 Connectors 1.3 第1层:连接层 系统(客户端)访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。 经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。"><meta name=twitter:image content="https://jieye-ericx.github.io/icon.png"><title>3 逻辑架构</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://jieye-ericx.github.io//icon.png><link href=https://jieye-ericx.github.io/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://jieye-ericx.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://jieye-ericx.github.io/js/darkmode.48459b7116d092b4e98d2cab704cad80.min.js></script>
<script src=https://jieye-ericx.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://jieye-ericx.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://jieye-ericx.github.io/",fetchData=Promise.all([fetch("https://jieye-ericx.github.io/indices/linkIndex.a91535da5bc472c24479fcf5acf89c4d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://jieye-ericx.github.io/indices/contentIndex.47f5e87592082c2dcd2e4b6783c6cd0d.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://jieye-ericx.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://jieye-ericx.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/jieye-ericx.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=jieye-ericx.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://jieye-ericx.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://jieye-ericx.github.io/>jieye の 数字花园</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>3 逻辑架构</h1><p class=meta>Last updated
Nov 14, 2022</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#1-逻辑架构剖析>1 逻辑架构剖析</a><ol><li><a href=#11-服务器处理客户端请求>1.1 服务器处理客户端请求</a></li><li><a href=#12-connectors>1.2 Connectors</a></li><li><a href=#13-第1层连接层>1.3 第1层:连接层</a></li><li><a href=#14-第2层服务层>1.4 第2层:服务层</a></li><li><a href=#15-第3层引擎层>1.5 第3层:引擎层</a></li><li><a href=#16-存储层>1.6 存储层</a></li><li><a href=#17-小结>1.7 小结</a></li></ol></li><li><a href=#2-sql执行流程>2 SQL执行流程</a><ol><li><a href=#22-mysql8中sql执行原理>2.2 MySQL8中SQL执行原理</a></li><li><a href=#24-sql语法顺序>2.4 SQL语法顺序</a></li></ol></li><li><a href=#3-数据库缓冲池buffer-pool>3 数据库缓冲池(buffer pool)</a><ol><li><a href=#31-缓冲池-vs-查询缓存>3.1 缓冲池 vs 查询缓存</a></li><li><a href=#32-缓冲池如何读取数据>3.2 缓冲池如何读取数据</a></li><li><a href=#33-查看设置缓冲池的大小>3.3 查看/设置缓冲池的大小</a></li><li><a href=#34-多个buffer-pool实例>3.4 多个Buffer Pool实例</a></li></ol></li></ol></nav></details></aside><a href=#1-逻辑架构剖析><h2 id=1-逻辑架构剖析><span class=hanchor arialabel=Anchor># </span>1 逻辑架构剖析</h2></a><a href=#11-服务器处理客户端请求><h3 id=11-服务器处理客户端请求><span class=hanchor arialabel=Anchor># </span>1.1 服务器处理客户端请求</h3></a><p>服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢?这里以查询请求为例展示:</p><p><img src=https://jieye-ericx.github.io//file///Users/ericx/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/TechIsAll/pics/image-20220915111525491.pnglastModify1668423115 width=auto alt=image-20220915111525491></p><p><img src=https://jieye-ericx.github.io//file///Users/ericx/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/TechIsAll/pics/image-20220915111543027.png width=auto alt=image-20220915111543027></p><a href=#12-connectors><h3 id=12-connectors><span class=hanchor arialabel=Anchor># </span>1.2 Connectors</h3></a><a href=#13-第1层连接层><h3 id=13-第1层连接层><span class=hanchor arialabel=Anchor># </span>1.3 第1层:连接层</h3></a><p>系统(客户端)访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。 经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。</p><p><strong>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行 用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依 赖于此时读到的权限</strong></p><p>TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后 面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><a href=#14-第2层服务层><h3 id=14-第2层服务层><span class=hanchor arialabel=Anchor># </span>1.4 第2层:服务层</h3></a><ul><li><p>SQL Interface: SQL接口</p><p>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface MySQL支持DML(数据操作语言)、DDL(数据定义语言)、存储过程、视图、触发器、自定 义函数等多种SQL语言接口</p></li><li><p>Parser: 解析器</p><p>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句<strong>分解成数据结构</strong>，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</p><p>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其<strong>创建语法树</strong> ，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限 。创建好语法树后，MySQL还会对SQl查询进行<strong>语法上的优化，进行查询重写</strong>。</p></li><li><p>Optimizer: <strong>查询优化器</strong></p><p>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个 执行计划 。</p><p>这个执行计划表明应该使用哪些索引进行查询(全表检索还是使用索引检索)，表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</p><p>它使用“ 选取-投影-连接 ”策略进行查询。例如:SELECT id,name FROM student WHERE gender = &lsquo;女&rsquo;;这个SELECT查询先根据WHERE语句进行选取 ，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性投影 ，而不是将属性全部取出以后再进行过 滤，将这两个查询条件连接起来生成最终查询结果。</p></li><li><p>Caches & Buffers**: 查询缓存组件**</p></li><li><p>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结 果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过 程了，直接将结果反馈给客户端。</p><p>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</p><p>这个查询缓存可以在不同客户端之间共享 。</p><p><strong>从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。</strong></p></li></ul><a href=#15-第3层引擎层><h3 id=15-第3层引擎层><span class=hanchor arialabel=Anchor># </span>1.5 第3层:引擎层</h3></a><p>插件式存储引擎层( Storage Engines)，<strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别 维护的底层数据执行操作</strong> ，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样 我们可以根据自己的实际需要进行选取。</p><p>MySQL 8.0.25默认支持的存储引擎如下:</p><p><img src=https://jieye-ericx.github.io//file///Users/ericx/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/TechIsAll/pics/image-20220915112616863.pnglastModify1668423115 width=auto alt=image-20220915112616863></p><a href=#16-存储层><h3 id=16-存储层><span class=hanchor arialabel=Anchor># </span>1.6 存储层</h3></a><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在<strong>文件系统</strong>上，以文件的方式存 在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用 DAS、NAS、SAN等各种存储系统。</p><a href=#17-小结><h3 id=17-小结><span class=hanchor arialabel=Anchor># </span>1.7 小结</h3></a><p><img src=https://jieye-ericx.github.io//file///Users/ericx/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/TechIsAll/pics/image-20220915112713156.pnglastModify1668423115 width=auto alt=image-20220915112713156></p><a href=#2-sql执行流程><h2 id=2-sql执行流程><span class=hanchor arialabel=Anchor># </span>2 SQL执行流程</h2></a><p><img src=https://jieye-ericx.github.io//file///Users/ericx/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/TechIsAll/pics/image-20220915112749246.pnglastModify1668423115 width=auto alt=image-20220915112749246></p><p>MySQL<strong>查询流程:</strong></p><ol><li><strong>查询缓存</strong><br>Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端;如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以<strong>在 MySQL8.0 之后就抛弃了这个功能。</strong></li></ol><p>大多数情况查询缓存就是个鸡肋，为什么呢?</p><blockquote><p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的<strong>鲁棒性降低</strong>只有。两个查询请求<strong>在任何字符上的不同(例如:空格、注释、 大小写)</strong>，都会导致缓存不会命中。因此 MySQL 的 查询缓存命中率不高。</p><p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数 NOW ，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次 查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询 的结果就是错误的!</p><p>此外，既然是缓存，那就有它<strong>缓存失效的时间</strong>， mysql的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改那使用该表的所有高速缓存查询都将变为无效，并从高速缓存中删除，对于更新压力大的数据库来说查询缓存的命中率非常低。</p></blockquote><ol start=2><li><strong>解析器</strong> 在解析器中对 SQL 语句进行语法分析、语义分析。<br><img src=https://jieye-ericx.github.io//file///Users/ericx/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/TechIsAll/pics/image-20220915113320707.pnglastModify1668423115 width=auto alt=image-20220915113320707></li></ol><p>分析器先做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面 的字符串分别<strong>是什么，代表什么</strong>。 MySQL从你输入的"select"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>接着，要做“ 语法分析”。根据词法分析的结果，语法分析器(比如:Bison)会根据语法规则，判断你输 入的这个SQL语句是否满足 MySQL 语法。<br><code>select department_id,job_id,avg(salary) from employees group by department_id;</code><br><img src=https://jieye-ericx.github.io//file///Users/ericx/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/TechIsAll/pics/image-20220915113450605.pnglastModify1668423115 width=auto alt=image-20220915113450605><br>3. <strong>优化器</strong><br>在优化器中会确定 SQL 语句的执行路径，比如是根据全表检索 ，还是根据索引检索等。 举例:如下语句是执行两个表的 join:<br><code>select * from test1 join test2 using(ID) where test1.name='zhangwei' and test2.name='mysql高级课程';</code></p><p>方案1:可以先从表 test1 里面取出 name=&lsquo;zhangwei&rsquo;的记录的 ID 值，再根据 ID 值关联到表 test2，再判断 test2 里面 name的值是否等于 &lsquo;mysql高级课程&rsquo;。 方案2:可以先从表 test2 里面取出 name=&lsquo;mysql高级课程&rsquo; 的记录的 ID 值，再根据 ID 值关联到 test1， 再判断 test1 里面 name的值是否等于 zhangwei。</p><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈。</p><p>在查询优化器中，可以分为 <strong>逻辑查询 优化阶段和 物理查询 优化阶段</strong>。</p><ol start=4><li>执行器</li></ol><p>截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了 执行器阶段 。<br><img src=https://jieye-ericx.github.io//file///Users/ericx/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/TechIsAll/pics/image-20220915114115407.pnglastModify1668423115 width=auto alt=image-20220915114115407><br>在执行之前需要判断该用户是否 具备权限 。如果没有，就会返回权限错误。如果具备权限，就执行 SQL 查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。<br><code>select * from test where id=1;</code><br>比如:表test中，ID字段没有索引，那么执行器的执行流程是这样的:<br>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是1，如果不是则跳过，如果是则将这行存在结果集中; 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。<br>至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。 SQL 语句在 MySQL 中的流程是: SQL语句→查询缓存→解析器→优化器→执行器 。<br><img src=https://jieye-ericx.github.io//file///Users/ericx/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/TechIsAll/pics/image-20220915114505957.pnglastModify1668423115 width=auto alt=image-20220915114505957></p><a href=#22-mysql8中sql执行原理><h3 id=22-mysql8中sql执行原理><span class=hanchor arialabel=Anchor># </span>2.2 MySQL8中SQL执行原理</h3></a><ol><li>确认profiling 是否开启<br><code>mysql> select @@profiling; mysql> show variables like 'profiling';</code><br><a class="internal-link broken">300</a><br>profiling=0 代表关闭，我们需要把 profiling 打开，即设置为 1：<br><code>mysql> set profiling=1;</code></li><li>多次执行相同SQL查询,然后我们执行一个 SQL 查询(你可以执行任何一个 SQL 查询):<code>mysql> select * from employ</code></li><li>查看当前会话所产生的所有 profiles:<br><code>mysql> show profiles; # 显示最近的几次查询</code><br><img src=https://jieye-ericx.github.io//file///Users/ericx/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/TechIsAll/pics/image-20220915115000321.pnglastModify1668423115 width=auto alt=image-20220915115000321></li><li><strong>查看</strong>profile 显示执行计划，查看程序的执行步骤:<br><code>mysql> show profile;</code><br><img src=https://jieye-ericx.github.io//file///Users/ericx/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/TechIsAll/pics/image-20220915115033150.pnglastModify1668423115 width=auto alt=image-20220915115033150><br>当然你也可以查询指定的 Query ID，比如: <code>mysql> show profile for query 7;</code><br>查询 SQL 的执行时间结果和上面是一样的,此外，还可以查询更丰富的内容:<code>mysql> show profile cpu,block io for query 6;</code><br><img src=https://jieye-ericx.github.io//file///Users/ericx/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/TechIsAll/pics/image-20220915115120346.pnglastModify1668423115 width=auto alt=image-20220915115120346><br>继续:<code>mysql> show profile cpu,block io for query 7;</code><br><img src=https://jieye-ericx.github.io//file///Users/ericx/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/TechIsAll/pics/image-20220915115139323.pnglastModify1668423115 width=auto alt=image-20220915115139323></li></ol><a href=#24-sql语法顺序><h3 id=24-sql语法顺序><span class=hanchor arialabel=Anchor># </span>2.4 SQL语法顺序</h3></a><p>随着Mysql版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而动态调整执行顺序。 需求:查询每个部门年龄高于20岁的人数且高于20岁人数不能少于2人，显示人数最多的第一名部门信息 下面是经常出现的查询顺序:<br><img src=https://jieye-ericx.github.io//file///Users/ericx/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/TechIsAll/pics/image-20220915120603828.pnglastModify1668423115 width=auto alt=image-20220915120603828></p><a href=#3-数据库缓冲池buffer-pool><h2 id=3-数据库缓冲池buffer-pool><span class=hanchor arialabel=Anchor># </span>3 数据库缓冲池(buffer pool)</h2></a><p>Innodb存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面(包括读页面、写页面、创建新页面等操作)。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS会申请占用，内存来作为缓冲池，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的<strong>缓冲池</strong>之后才可以访问。<br>这样做的好处是可以让磁盘活动最小化，<strong>从而减小磁盘IO的时间</strong>。要知道，这种策略对提 升SQL语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p><a href=#31-缓冲池-vs-查询缓存><h3 id=31-缓冲池-vs-查询缓存><span class=hanchor arialabel=Anchor># </span>3.1 缓冲池 vs 查询缓存</h3></a><p>缓冲池和查询缓存是一个东西吗？不是。</p><ol><li>缓冲池（Buffer Pool）<br>首先我们需要了解在 InnoDB 存储引擎中，缓冲池都包括了哪些。 在InnoDB存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，如下图所示：
<img src=https://jieye-ericx.github.io//file///Users/ericx/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/TechIsAll/pics/image-20220915151003679.pnglastModify1668423115 width=auto alt=image-20220915151003679></li></ol><blockquote><p>缓存池的重要性：对于使用InnoDB作为存储引擎的表来说，不管是用于存储用户数据的索引(包括聚簇索引和二级索引)，还是各种系统数据，都是以页的形式存放在表空间中的，而所谓的表空间只不过是InnoDB对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。但是各位也都知道，磁盘的速度慢的跟乌龟一样,怎么能配得上“快如风，疾如电”的CPU呢?这里，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟。所以InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中,也就是说即使我们只需要访问一个页的一条记录,那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉,而是将其缓存起来,这样将来有请求再次访问该页面时，就可以省去磁盘I0的开销了。</p></blockquote><blockquote><p>缓存原则：“ 位置 * 频次 ” 这个原则，可以帮我们对 I/O 访问效率进行优化。首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。 其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会优先对使用频次高 的热数据进行加载 。</p></blockquote><blockquote><p>缓冲池的预读特性:了解了缓冲池的作用之后，我们还需要了解缓冲池的另一个特性:预读。缓冲池的作用就是提升I/0效率,而我们进行读取数据的时候存在一个“ <strong>局部性原理</strong>”，也就是说我们使用了一些数据，大概率还会使用它周围的一些数据 ，因此采用‘预读’’的机制提前加载，可以减少未来可能的磁盘/0操作。</p></blockquote><ol start=2><li>查询缓存<br>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且<strong>只要数据表发生变化，查询缓存就会失效，因此命中率低</strong>。</li></ol><a href=#32-缓冲池如何读取数据><h3 id=32-缓冲池如何读取数据><span class=hanchor arialabel=Anchor># </span>3.2 缓冲池如何读取数据</h3></a><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面 是否在缓冲池中，如果存在就直接读取，<strong>如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取</strong>。<br><img src=https://jieye-ericx.github.io//file///Users/ericx/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/TechIsAll/pics/image-20220915151640224.pnglastModify1668423115 width=auto alt=image-20220915151640224></p><p>如果我们执行 SQL 语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？<br>实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会以一定的频率刷新到磁盘上。注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做checkpoint的机制将数据回写到磁盘上,这样做的好处就是提升了数据库的整体性能。 比如，当缓冲池不够用时，需要释放掉一些不常用的页，此时就可以强行采用checkpoint的方式，<strong>将不常用的脏页回写到磁盘上,然后再从缓冲池中将这些页释放掉。这里脏页(dirty page)指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。</strong></p><a href=#33-查看设置缓冲池的大小><h3 id=33-查看设置缓冲池的大小><span class=hanchor arialabel=Anchor># </span>3.3 查看/设置缓冲池的大小</h3></a><p>如果你使用的是 InnoDB 存储引擎，可以通过查看<code>innodb_buffer_pool_size</code>变量来查看缓冲池的大 小。<br><img src=https://jieye-ericx.github.io//file///Users/ericx/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/TechIsAll/pics/image-20220915152021622.pnglastModify1668423115 width=auto alt=image-20220915152021622></p><p>你能看到此时 InnoDB 的缓冲池大小只有 134217728/1024/1024=128MB。我们可以修改缓冲池大小，比如 改为256MB:<code>set global innodb_buffer_pool_size = 268435456;</code></p><a href=#34-多个buffer-pool实例><h3 id=34-多个buffer-pool实例><span class=hanchor arialabel=Anchor># </span>3.4 多个Buffer Pool实例</h3></a><p>[server]<br>innodb_buffer_pool_instances = 2</p><p>这样就表明我们要创建2个 Buffer Pool 实例。 我们看下如何查看缓冲池的个数，使用命令：<code>show variables like 'innodb_buffer_pool_instances';</code></p><p>那每个 Buffer Pool 实例实际占多少内存空间呢？其实使用这个公式算出来的：<code>innodb_buffer_pool_size/innodb_buffer_pool_instances</code>也就是总共的大小除以实例的个数，结果就是每个 Buffer Pool 实例占用的大小。</p><p>不过也不是说Buffer Pool实例创建的越多越好，分别管理各个Buffer Pool也是 需要性能开销的，InnoDB规定: 当<code>innodb_buffer_pool_size</code>的值小于1G的时候设置多个实例是无效的，InnoDB会默认把<code>innodb_buffer_pool_instances</code> 的值修改为1。而我们鼓励在Buffer Pool大于或等于1G的时候设置多个Buffer Pool实例。</p><p>3.5 引申问题<br>Buffer Pool是MySQL内存结构中十分核心的一个组成，你可以先把它想象成一个黑盒子。 黑盒下的更新数据流程：</p><p>当我们查询数据的时候，会先去Buffer Pool中查询。如果Buffer Pool中不存在，存储弓|擎会先将数据从磁盘加载到Buffer Pool中，然后将数据返回给客户端;同理，当我们更新某个数据的时候，如果这个数据不存在于Buffer Pool,同样会先数据加载进来,然后修改修改内存的数据。被修改过的数据会在之后统一刷入磁盘。</p><p><img src=https://jieye-ericx.github.io//file///Users/ericx/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/TechIsAll/pics/image-20220915154858925.pnglastModify1668423115 width=auto alt=image-20220915154858925></p><p>这个过程看似没啥问题，实则是有问题的。假设我们修改Buffer Pool中的数据成功，但是还没来得及将数据刷入磁盘MySQL就挂了怎么办?按照上图的逻辑，此时更新之后的数据只存在于Buffer Pool中，如果此时MySQL宕机了，这部分数据将会永久地丢失;</p><p>我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回滚都做不到还谈什么崩溃恢复？ 答案：Redo Log & Undo Log</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/Mysql-%E5%8E%9F%E7%90%86/ data-ctx="3 逻辑架构" data-src=/Mysql-%E5%8E%9F%E7%90%86 class=internal-link>Mysql 原理</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://jieye-ericx.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Jieye ericx using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://jieye-ericx.github.io/>Home</a></li><li><a href=https://github.com/jieye-ericx>Github</a></li></ul></footer></div></div></body></html>