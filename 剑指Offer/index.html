<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="剑指Offer 1. 替换空格 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
1 2 3 4 5  class Solution { public: void replaceSpace(char *str,int length) { } };    这题其实就是在给定地str中找到空格，并替换成%20，由于是一个字符替换成三个字符，所以需要移动元素，如果从前往后移动，假设有n个空格，则第n个空格后面的元素都要被移动n次，很浪费时间，所以从后往前移动，并且不需要额外的数组，先计算出填补后的长度`newlength=oldnumber+n*2`,然后从后遍历直接`str[pNewlength--]=str[pOldlength];` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { public: void replaceSpace(char *str,int length) { if (str == NULL || length < 0) return; int i=0,oldLength=strlen(str),newLength=0,blanks=0; while(str[i]!"><meta property="og:title" content><meta property="og:description" content="剑指Offer 1. 替换空格 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
1 2 3 4 5  class Solution { public: void replaceSpace(char *str,int length) { } };    这题其实就是在给定地str中找到空格，并替换成%20，由于是一个字符替换成三个字符，所以需要移动元素，如果从前往后移动，假设有n个空格，则第n个空格后面的元素都要被移动n次，很浪费时间，所以从后往前移动，并且不需要额外的数组，先计算出填补后的长度`newlength=oldnumber+n*2`,然后从后遍历直接`str[pNewlength--]=str[pOldlength];` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { public: void replaceSpace(char *str,int length) { if (str == NULL || length < 0) return; int i=0,oldLength=strlen(str),newLength=0,blanks=0; while(str[i]!"><meta property="og:type" content="website"><meta property="og:image" content="https://jieye-ericx.github.io/icon.png"><meta property="og:url" content="https://jieye-ericx.github.io/%E5%89%91%E6%8C%87Offer/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="剑指Offer 1. 替换空格 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
1 2 3 4 5  class Solution { public: void replaceSpace(char *str,int length) { } };    这题其实就是在给定地str中找到空格，并替换成%20，由于是一个字符替换成三个字符，所以需要移动元素，如果从前往后移动，假设有n个空格，则第n个空格后面的元素都要被移动n次，很浪费时间，所以从后往前移动，并且不需要额外的数组，先计算出填补后的长度`newlength=oldnumber+n*2`,然后从后遍历直接`str[pNewlength--]=str[pOldlength];` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { public: void replaceSpace(char *str,int length) { if (str == NULL || length < 0) return; int i=0,oldLength=strlen(str),newLength=0,blanks=0; while(str[i]!"><meta name=twitter:image content="https://jieye-ericx.github.io/icon.png"><title>jieye の 数字花园</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://jieye-ericx.github.io//icon.png><link href=https://jieye-ericx.github.io/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://jieye-ericx.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://jieye-ericx.github.io/js/darkmode.48459b7116d092b4e98d2cab704cad80.min.js></script>
<script src=https://jieye-ericx.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://jieye-ericx.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://jieye-ericx.github.io/",fetchData=Promise.all([fetch("https://jieye-ericx.github.io/indices/linkIndex.d562e04b781c4ee6550d42b2193dcfd6.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://jieye-ericx.github.io/indices/contentIndex.9ef4d52afa6226058d80e32da437f549.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://jieye-ericx.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://jieye-ericx.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/jieye-ericx.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=jieye-ericx.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://jieye-ericx.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://jieye-ericx.github.io/>jieye の 数字花园</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#剑指offer>剑指Offer</a><ol><li><a href=#1-替换空格>1. 替换空格</a></li><li><a href=#2-从头到尾打印链表>2. 从头到尾打印链表</a></li><li><a href=#3-重建二叉树>3. 重建二叉树</a></li><li><a href=#4-两个栈实现队列>4. 两个栈实现队列</a></li><li><a href=#6-调整数组顺序>6. 调整数组顺序</a></li><li><a href=#7-链表中倒数第k个结点>7. 链表中倒数第k个结点</a></li><li><a href=#8-反转链表>8. 反转链表</a></li><li><a href=#9-合并两个排序的链表>9. 合并两个排序的链表</a></li><li><a href=#10-顺时针打印矩阵>10. 顺时针打印矩阵</a></li><li><a href=#12-栈的压入弹出>12. 栈的压入弹出</a></li><li><a href=#13字符串的排列>13.字符串的排列</a></li><li><a href=#14-数组中出现次数超过一半的数字>14. 数组中出现次数超过一半的数字</a></li><li><a href=#15连续子数组的最大和>15.连续子数组的最大和</a></li><li><a href=#16-丑数>16. 丑数</a></li><li><a href=#17数字在排序数组中出现的次数>17.数字在排序数组中出现的次数</a></li><li><a href=#18二叉树深度>18.二叉树深度</a></li><li><a href=#19剪绳子>19.剪绳子</a></li><li><a href=#20判断子结构>20.判断子结构</a></li><li><a href=#21二叉树镜像>21.二叉树镜像</a></li></ol></li></ol></nav></details></aside><a href=#剑指offer><h2 id=剑指offer><span class=hanchor arialabel=Anchor># </span>剑指Offer</h2></a><a href=#1-替换空格><h3 id=1-替换空格><span class=hanchor arialabel=Anchor># </span>1. 替换空格</h3></a><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=n>replaceSpace</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>str</span><span class=p>,</span><span class=kt>int</span> <span class=n>length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><hr>这题其实就是在给定地str中找到空格，并替换成%20，由于是一个字符替换成三个字符，所以需要移动元素，如果从前往后移动，假设有n个空格，则第n个空格后面的元素都要被移动n次，很浪费时间，所以从后往前移动，并且不需要额外的数组，先计算出填补后的长度`newlength=oldnumber+n*2`,然后从后遍历直接`str[pNewlength--]=str[pOldlength];`<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=n>replaceSpace</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>str</span><span class=p>,</span><span class=kt>int</span> <span class=n>length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>str</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>||</span> <span class=n>length</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span><span class=n>oldLength</span><span class=o>=</span><span class=n>strlen</span><span class=p>(</span><span class=n>str</span><span class=p>),</span><span class=n>newLength</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span><span class=n>blanks</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=p>(</span><span class=n>str</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>!=</span><span class=sc>&#39;\0&#39;</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=c1>//oldLength++;
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span><span class=p>(</span><span class=n>str</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>==</span><span class=sc>&#39; &#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>blanks</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>newLength</span><span class=o>=</span><span class=n>oldLength</span><span class=o>+</span><span class=n>blanks</span><span class=o>*</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>newLength</span><span class=o>&gt;</span><span class=n>length</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=p>(</span><span class=n>newLength</span><span class=o>&gt;</span><span class=n>oldLength</span><span class=o>&amp;&amp;</span><span class=n>oldLength</span><span class=o>&gt;=</span><span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>str</span><span class=p>[</span><span class=n>oldLength</span><span class=p>]</span><span class=o>==</span><span class=sc>&#39; &#39;</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=n>str</span><span class=p>[</span><span class=n>newLength</span><span class=o>--</span><span class=p>]</span><span class=o>=</span><span class=sc>&#39;0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>str</span><span class=p>[</span><span class=n>newLength</span><span class=o>--</span><span class=p>]</span><span class=o>=</span><span class=sc>&#39;2&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>str</span><span class=p>[</span><span class=n>newLength</span><span class=o>--</span><span class=p>]</span><span class=o>=</span><span class=sc>&#39;%&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>str</span><span class=p>[</span><span class=n>newLength</span><span class=p>]</span><span class=o>=</span><span class=n>str</span><span class=p>[</span><span class=n>oldLength</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=n>newLength</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>oldLength</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><a href=#2-从头到尾打印链表><h3 id=2-从头到尾打印链表><span class=hanchor arialabel=Anchor># </span>2. 从头到尾打印链表</h3></a><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><hr>```c++
class Solution {
public:
vector<int> printListFromTailToHead(ListNode* head) {
vector<int> arr;
while(head){
arr.insert(arr.begin(),head->val);
head=head->next;
}
return arr;
}
};
```
<a href=#3-重建二叉树><h3 id=3-重建二叉树><span class=hanchor arialabel=Anchor># </span>3. 重建二叉树</h3></a><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Definition for binary tree
</span></span></span><span class=line><span class=cl><span class=cm> * struct TreeNode {
</span></span></span><span class=line><span class=cl><span class=cm> *     int val;
</span></span></span><span class=line><span class=cl><span class=cm> *     TreeNode *left;
</span></span></span><span class=line><span class=cl><span class=cm> *     TreeNode *right;
</span></span></span><span class=line><span class=cl><span class=cm> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span></span></span><span class=line><span class=cl><span class=cm> * };
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>TreeNode</span><span class=o>*</span> <span class=n>reConstructBinaryTree</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>pre</span><span class=p>,</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vin</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><hr><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/blogs/%e5%89%91%e6%8c%87Offer20210214204350.png width=auto alt=图片说明></p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/blogs/%e5%89%91%e6%8c%87Offer20210214204401.png width=auto alt=图片说明></p><p>思路：</p><ol><li><p>由先序序列第一个**<code>pre[0]</code><strong>在中序序列中找到根节点位置</strong><code>gen</code>**</p></li><li><p>以</p><p><code>gen</code></p><p>为中心遍历</p><ul><li><p><code>0~gen</code></p><p>左子树</p><ul><li>子中序序列：<strong><code>0~gen-1</code></strong>，放入**<code>vin_left[]</code>**</li><li>子先序序列：<strong><code>1~gen</code><strong>放入</strong><code>pre_left[]</code></strong>，**<code>+1</code>**可以看图，因为头部有根节点</li></ul></li><li><p><code>gen+1~vinlen</code></p><p>为右子树</p><ul><li>子中序序列：<strong><code>gen+1 ~ vinlen-1</code><strong>放入</strong><code>vin_right[]</code></strong></li><li>子先序序列：<strong><code>gen+1 ~ vinlen-1</code><strong>放入</strong><code>pre_right[]</code></strong></li></ul></li></ul></li><li><p>由先序序列**<code>pre[0]</code>**创建根节点</p></li><li><p>连接左子树，按照左子树子序列递归（<strong><code>pre_left[]</code><strong>和</strong><code>vin_left[]</code></strong>）</p></li><li><p>连接右子树，按照右子树子序列递归（<strong><code>pre_right[]</code><strong>和</strong><code>vin_right[]</code></strong>）</p></li><li><p>返回根节点</p></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Definition for binary tree
</span></span></span><span class=line><span class=cl><span class=cm> * struct TreeNode {
</span></span></span><span class=line><span class=cl><span class=cm> *     int val;
</span></span></span><span class=line><span class=cl><span class=cm> *     TreeNode *left;
</span></span></span><span class=line><span class=cl><span class=cm> *     TreeNode *right;
</span></span></span><span class=line><span class=cl><span class=cm> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span></span></span><span class=line><span class=cl><span class=cm> * };
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>TreeNode</span><span class=o>*</span> <span class=n>reConstructBinaryTree</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>pre</span><span class=p>,</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vin</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>mid</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span><span class=n>len</span><span class=o>=</span><span class=n>vin</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>len</span><span class=o>==</span><span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>preL</span><span class=p>,</span><span class=n>preR</span><span class=p>,</span><span class=n>vinL</span><span class=p>,</span><span class=n>vinR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>TreeNode</span><span class=o>*</span> <span class=n>root</span><span class=o>=</span><span class=k>new</span> <span class=n>TreeNode</span><span class=p>(</span><span class=n>pre</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>len</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>vin</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>==</span><span class=n>pre</span><span class=p>[</span><span class=mi>0</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>                <span class=n>mid</span><span class=o>=</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>mid</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>preL</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>pre</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=n>vinL</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>vin</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=n>mid</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>len</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>preR</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>pre</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=n>vinR</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>vin</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>root</span><span class=o>-&gt;</span><span class=n>left</span><span class=o>=</span><span class=n>reConstructBinaryTree</span><span class=p>(</span><span class=n>preL</span><span class=p>,</span><span class=n>vinL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>root</span><span class=o>-&gt;</span><span class=n>right</span><span class=o>=</span><span class=n>reConstructBinaryTree</span><span class=p>(</span><span class=n>preR</span><span class=p>,</span><span class=n>vinR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><a href=#4-两个栈实现队列><h3 id=4-两个栈实现队列><span class=hanchor arialabel=Anchor># </span>4. 两个栈实现队列</h3></a><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><hr>```c++
class Solution
{
public:
void push(int node) {
if(stack2.empty()&&stack1.empty()){
            stack2.push(node);
}else
stack1.push(node);
}<pre><code>int pop() {
    if(!stack2.empty()){
        
    }else{
        if(stack1.empty()){
            return -1;
        }n
        trans();
    }
    int ans= stack2.top();
    stack2.pop();
    if(stack2.empty()){
        trans();
    }
    return ans;
}

void trans(){
    while(!stack1.empty()){
        stack2.push(stack1.top());
        stack1.pop();
    }
}
</code></pre><p>private:
stack<int> stack1;
stack<int> stack2;
};</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>### 5.二进制中1的个数
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>输入一个整数，该数二进制表示中1的个数。其中负数用补码表示。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&lt;hr&gt;
</span></span><span class=line><span class=cl>1.利用一个结论：一个二进制数n减1后与原二进制数进行&amp;运算( 即n&amp;(n-1) )会消去最右边的1。
</span></span><span class=line><span class=cl>2.这个结论怎么来的？
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>- 假设二进制数101进行减1运算，刚好最右边是1，则得到100，此时用100跟101做&amp;运算，得到的是100，故消去了101左右边的1。 
</span></span><span class=line><span class=cl>- 100减1呢？最低位是0,跟十进制减法一样啊，向高位借。(可以脑补一下十进制100减1的过程) 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>**所以二进制100减1的运算过程如下：** 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>- 最右边的0向右数第二位借1得：2-1=1， 
</span></span><span class=line><span class=cl>- 右数第二位还是0，却要借给最右边那位1，所以它也得向高位借。 
</span></span><span class=line><span class=cl>- 这样右数第三位的1借给它1之后变成0，右数第二位借1得：2-1=1。 
</span></span><span class=line><span class=cl>- 所以得到新数为011。 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>**观察一下刚刚的运算过程可以发现：** 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>- 如果最右边刚好是1(如101)，进行减1运算就不用向高位借，直接得0，高位则保持原样不变(得100)。 
</span></span><span class=line><span class=cl>- 再把减1后得到的数与原数&amp;运算(即101&amp;100=100)可知高位都不变那就是消去最右边的1！(由这可能还不太明显是消去最右边的1，继续看下面的) 
</span></span><span class=line><span class=cl>- 如果最右边是0(如100)，进行减1运算，则需要像高位借，而最终会导致最近的高位1因为被借走1而变0，而比它高的高位保持原样不变(得011),再跟原来的数进行&amp;运算(即100&amp;011=000)； 
</span></span><span class=line><span class=cl>- 所以由以上两点可知二进制数每次减1后与原数进行&amp;运算会消去最右边的1。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>```c++
</span></span><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>public:
</span></span><span class=line><span class=cl>     int  NumberOf1(int n) {
</span></span><span class=line><span class=cl>         int count=0;
</span></span><span class=line><span class=cl>         while(n!=0)
</span></span><span class=line><span class=cl>         {
</span></span><span class=line><span class=cl>             n=n&amp;(n-1);
</span></span><span class=line><span class=cl>             count++;
</span></span><span class=line><span class=cl>         }
</span></span><span class=line><span class=cl>         return count;
</span></span><span class=line><span class=cl>     }
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><a href=#6-调整数组顺序><h3 id=6-调整数组顺序><span class=hanchor arialabel=Anchor># </span>6. 调整数组顺序</h3></a><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><hr><p>我写了个很弱智的方法,时间复杂度不高空间挺复杂的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>reOrderArray</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>array</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>tmp2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>array</span><span class=p>.</span><span class=n>size</span><span class=p>();</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>array</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>&amp;</span><span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=n>tmp</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>array</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>tmp2</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>array</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>tmp2</span><span class=p>.</span><span class=n>size</span><span class=p>();</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>tmp</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>tmp2</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>array</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>tmp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><a href=#7-链表中倒数第k个结点><h3 id=7-链表中倒数第k个结点><span class=hanchor arialabel=Anchor># </span>7. 链表中倒数第k个结点</h3></a><p>输入一个链表，输出该链表中倒数第k个结点。</p><hr>```c++
class Solution {
public:
ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {
int cnt=0;
ListNode * L;
ListNode * ans;
L=pListHead;ans=pListHead;
while(L){
cnt++;
if(cnt>k){
ans=ans->next;
}
L=L->next;
}
if(cnt<k){ return null; } return ans; } }; ``` <p>没啥难度，但是指针定义那一块要小心<code> ListNode * L,ans;</code>是错误的，应为<code> ListNode * L,*ans;</code></p><a href=#8-反转链表><h3 id=8-反转链表><span class=hanchor arialabel=Anchor># </span>8. 反转链表</h3></a><p>输入一个链表，反转链表后，输出新链表的表头。</p><hr>```c++
class Solution {
public:
ListNode* ReverseList(ListNode* pHead) {
ListNode * p0=nullptr,*p1=pHead,*p2=nullptr;
while(p1){
p2=p1->next;
p1->next=p0;
p0=p1;
p1=p2;
}
return p0;
}
};
```<p>没啥难度，但要小心。</p><p><img src=https://jieye-ericx.github.io//../../../../../Desktop/Algorithm.assets/815472960_1566642098849_C3B4D3532589FC2990420BCEA62A8DBF.jfif width=auto alt=反转链表></p><a href=#9-合并两个排序的链表><h3 id=9-合并两个排序的链表><span class=hanchor arialabel=Anchor># </span>9. 合并两个排序的链表</h3></a><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><hr>搜集了一个递归写法，不算太懂<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>ListNode</span><span class=o>*</span> <span class=n>Merge</span><span class=p>(</span><span class=n>ListNode</span><span class=o>*</span> <span class=n>pHead1</span><span class=p>,</span> <span class=n>ListNode</span><span class=o>*</span> <span class=n>pHead2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>pHead1</span><span class=o>==</span><span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>pHead2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=nf>if</span><span class=p>(</span><span class=n>pHead2</span><span class=o>==</span><span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>pHead1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ListNode</span><span class=o>*</span> <span class=n>p1</span><span class=o>=</span><span class=n>pHead1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ListNode</span><span class=o>*</span> <span class=n>p2</span><span class=o>=</span><span class=n>pHead2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ListNode</span><span class=o>*</span> <span class=n>newHead</span><span class=o>=</span><span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>p1</span><span class=o>-&gt;</span><span class=n>val</span><span class=o>&lt;</span><span class=n>p2</span><span class=o>-&gt;</span><span class=n>val</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>newHead</span><span class=o>=</span><span class=n>p1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>newHead</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>=</span><span class=n>Merge</span><span class=p>(</span><span class=n>p1</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>,</span><span class=n>p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>newHead</span><span class=o>=</span><span class=n>p2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>newHead</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>=</span><span class=n>Merge</span><span class=p>(</span><span class=n>p2</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>,</span><span class=n>p1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>newHead</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>这其实就是归并排序，等回头数据结构学完得好好写一下。</p><a href=#10-顺时针打印矩阵><h3 id=10-顺时针打印矩阵><span class=hanchor arialabel=Anchor># </span>10. 顺时针打印矩阵</h3></a><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><hr>```c++
class Solution {
public:
vector<int> printMatrix(vector<vector<int> > matrix) {
int dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}},di=0,i=0,j=0,cnt=0;
int vis[matrix.size()][matrix[0].size()],num=matrix.size()*matrix[0].size();
vector<int> arr;
if(num==0){
return arr;
}<pre><code>    while(1){
            //cout&lt;&lt;matrix[i][j];
        arr.push_back(matrix[i][j]);
        vis[i][j]=1;
        i+=dir[di][0];
        j+=dir[di][1];
      //判断增加后是否超出数组范围或者下一个元素已被访问，则转向
        if(vis[i][j]<mark>1||i</mark>matrix.size()||j==matrix[0].size()||i&lt;0||j&lt;0){
                i-=dir[di][0];
                j-=dir[di][1];
                di=(di+1)%4;
                i+=dir[di][0];
                j+=dir[di][1];
        }
        if(++cnt==num){//最后判断输出个数达到数组元素个数时则结束
            break;
        }
    }
return arr;
}
</code></pre><p>};</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>其实有点找回以前刷题时用dir方向数组+vis数组的感觉了，题目在以前算简单，现在居然花了好一会才出来。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>### 11.包含min函数的栈
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&lt;hr&gt;
</span></span><span class=line><span class=cl>```c++
</span></span><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>public:
</span></span><span class=line><span class=cl>    void push(int value) {
</span></span><span class=line><span class=cl>        if(ptr&gt;=9999) return;
</span></span><span class=line><span class=cl>        if(value&lt;minNum) {
</span></span><span class=line><span class=cl>            stack[++ptr]=minNum;
</span></span><span class=line><span class=cl>            minNum=value;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        stack[++ptr]=value;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    void pop() {
</span></span><span class=line><span class=cl>        if(ptr==-1) return;
</span></span><span class=line><span class=cl>        if(stack[ptr]==minNum){
</span></span><span class=line><span class=cl>            ptr--;
</span></span><span class=line><span class=cl>            minNum=stack[ptr--];
</span></span><span class=line><span class=cl>        }else{
</span></span><span class=line><span class=cl>            ptr--;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    int top() {
</span></span><span class=line><span class=cl>        if(ptr==-1) return -1;
</span></span><span class=line><span class=cl>        return stack[ptr];
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    int min() {
</span></span><span class=line><span class=cl>        return minNum==0xffffff?-1:minNum;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    int minNum=0xffffff;
</span></span><span class=line><span class=cl>    int ptr=-1;
</span></span><span class=line><span class=cl>    int stack[10000];
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><p>本来对于目前的最小值被pop后如何处理没什么办法，查看题解后明白可以在插入时判断，如果此值为新的最小值，则在插入此值之前先插入上一个最小值，在pop时判断取出的是不是当前最小值，若是则pop两次，第二次pop出的则为当前的最小值。</p><a href=#12-栈的压入弹出><h3 id=12-栈的压入弹出><span class=hanchor arialabel=Anchor># </span>12. 栈的压入弹出</h3></a><p>要看一个序列是否可以作为一个给定入栈序列的弹出序列，可以用一个栈进行模拟（也可用数组代替，我就偷个懒），设一个指向popV第一个元素的指针j，按照pushV的顺序插入，插入时检索插入的值和popV[J]是否一样，若一样则说明当前出栈序列正好出到这个值，那就直接弹出，j++（匹配出栈序列的下一个），最后pushV全插入后，若j未到popV末尾，说明栈中剩下的内容一次性全部弹出，直接边弹出边和popV中的作比较即可。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>IsPopOrder</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>pushV</span><span class=p>,</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>popV</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>stack</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>sta</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span><span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=p>(</span><span class=n>i</span><span class=o>!=</span><span class=n>pushV</span><span class=p>.</span><span class=n>size</span><span class=p>()){</span>
</span></span><span class=line><span class=cl>            <span class=n>sta</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>pushV</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>pushV</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>==</span><span class=n>popV</span><span class=p>[</span><span class=n>j</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>                <span class=n>sta</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=n>j</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>popV</span><span class=p>.</span><span class=n>size</span><span class=p>();</span><span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>sta</span><span class=p>.</span><span class=n>top</span><span class=p>()</span><span class=o>!=</span><span class=n>popV</span><span class=p>[</span><span class=n>j</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>sta</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><a href=#13字符串的排列><h3 id=13字符串的排列><span class=hanchor arialabel=Anchor># </span>13.字符串的排列</h3></a><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><hr>```c++
class Solution {
public:
vector<string> Permutation(string str) {
if (str.empty()) return {};
sort(str.begin(), str.end());
vector<string> ans;
ans.push_back(str);
while (next_permutation(str.begin(), str.end()))
ans.push_back(str);
return ans;
}
};
```
<a href=#14-数组中出现次数超过一半的数字><h3 id=14-数组中出现次数超过一半的数字><span class=hanchor arialabel=Anchor># </span>14. 数组中出现次数超过一半的数字</h3></a><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><hr>```c++
class Solution {
public:
int MoreThanHalfNum_Solution(vector<int> numbers) {
sort(numbers.begin(),numbers.end());
int len=numbers.size()/2;
int tmp,j;
for(int i=0;i<numbers.size();i++){ j=i+len; if(j<numbers.size()){ if(numbers[j]="=numbers[i]){" return numbers[i]; } }else{ return 0; } } } }; ``` <p>这个办法不是很满意，看了看他人的，普遍有找中间数的方法</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>int</span> <span class=nf>MoreThanHalfNum_Solution</span><span class=o>(</span><span class=kt>int</span> <span class=o>[]</span> <span class=n>array</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Arrays</span><span class=o>.</span><span class=na>sort</span><span class=o>(</span><span class=n>array</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=n>array</span><span class=o>[</span><span class=n>array</span><span class=o>.</span><span class=na>length</span><span class=o>/</span><span class=n>2</span><span class=o>];</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>IntStream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=n>array</span><span class=o>).</span><span class=na>filter</span><span class=o>(</span><span class=n>k</span><span class=o>-&gt;</span><span class=n>k</span><span class=o>==</span><span class=n>i</span><span class=o>).</span><span class=na>count</span><span class=o>()&gt;</span><span class=n>array</span><span class=o>.</span><span class=na>length</span><span class=o>/</span><span class=n>2</span><span class=o>?</span><span class=n>i</span><span class=o>:</span><span class=n>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>或者用count++</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>MoreThanHalfNum</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>numbers</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=n>size_t</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>numbers</span><span class=p>.</span><span class=n>size</span><span class=p>();</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=n>ret</span> <span class=o>=</span> <span class=n>numbers</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=n>n</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=n>numbers</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                    <span class=n>n</span> <span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span>
</span></span><span class=line><span class=cl>                    <span class=n>n</span><span class=o>--</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><a href=#15连续子数组的最大和><h3 id=15连续子数组的最大和><span class=hanchor arialabel=Anchor># </span>15.连续子数组的最大和</h3></a><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p><hr>```c++
class Solution {
public:
int FindGreatestSumOfSubArray(vector<int> array) {
int dp[array.size()],maxn=array[0];
dp[0]=array[0];
for(int i=1;i<array.size();i++){ dp[i]=max(array[i],dp[i-1]+array[i]); maxn=max(maxn,dp[i]); } return maxn; } }; ``` <p>最简单的动态规划，dp作为规划数组，dp[i]存储从前面最佳位置到array[i]的和，由于dp[i-1]存储从前面最佳位置到array[i-1]的和，所以如果dp[i-1]+array[i]&lt;array[i]，即前面最佳位置到i-1的值是负的，说明还不如从i位置重新开始寻找，此时dp[i]=array[i]，同时maxn密切追踪最大值，最后的值就是整个的最大值。</p><p>也可以待循环结束后遍历整个dp数组找到最大值。</p><a href=#16-丑数><h3 id=16-丑数><span class=hanchor arialabel=Anchor># </span>16. 丑数</h3></a><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><hr><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>GetUglyNumber_Solution</span><span class=p>(</span><span class=kt>int</span> <span class=n>index</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>ans</span><span class=p>[</span><span class=n>index</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=c1>//ans[0]=0;
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>memset</span><span class=p>(</span><span class=n>ans</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=k>sizeof</span><span class=p>(</span><span class=n>ans</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>ans</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>p2</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span><span class=n>p3</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span><span class=n>p5</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>index</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>ans</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=n>min</span><span class=p>(</span><span class=n>ans</span><span class=p>[</span><span class=n>p2</span><span class=p>]</span><span class=o>*</span><span class=mi>2</span><span class=p>,</span><span class=n>min</span><span class=p>(</span><span class=n>ans</span><span class=p>[</span><span class=n>p3</span><span class=p>]</span><span class=o>*</span><span class=mi>3</span><span class=p>,</span><span class=n>ans</span><span class=p>[</span><span class=n>p5</span><span class=p>]</span><span class=o>*</span><span class=mi>5</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>ans</span><span class=p>[</span><span class=n>p2</span><span class=p>]</span><span class=o>*</span><span class=mi>2</span><span class=o>==</span><span class=n>ans</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=n>p2</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>ans</span><span class=p>[</span><span class=n>p3</span><span class=p>]</span><span class=o>*</span><span class=mi>3</span><span class=o>==</span><span class=n>ans</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=n>p3</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>ans</span><span class=p>[</span><span class=n>p5</span><span class=p>]</span><span class=o>*</span><span class=mi>5</span><span class=o>==</span><span class=n>ans</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=n>p5</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ans</span><span class=p>[</span><span class=n>index</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>利用动态规划，由于每个丑数可以理解为``2^x3^y5^z`的形式,用ans[i]表示第i个丑数，则ans[i]等于ans[a]*2、ans[b]*3、ans[c]*5中最小的一个，a、b、c均小于i。所以用三个指针记录a、b、c即可，由于有可能ans[a]*2==ans[b]*3，所以最后指针++时得用三个独立的if。</p><a href=#17数字在排序数组中出现的次数><h3 id=17数字在排序数组中出现的次数><span class=hanchor arialabel=Anchor># </span>17.数字在排序数组中出现的次数</h3></a><p>统计一个数字在排序数组中出现的次数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>GetNumberOfK</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>data</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><hr>一道三分钟的题被我写成了三小时。
自己想法是先二分找到这个数然后再遍历寻找个数。主要是好久不写二分，一些细节都忘了。<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>GetNumberOfK</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>data</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>le</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>ri</span> <span class=o>=</span> <span class=n>data</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>mid</span><span class=p>,</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span> <span class=n>le</span> <span class=o>&lt;=</span> <span class=n>ri</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>ri</span> <span class=o>+</span> <span class=n>le</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>k</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>ri</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span><span class=c1>//注意需要-1，不然可能出现13+14/2=13一直访问不到14的情况
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>k</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>le</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>mid</span><span class=o>&gt;=</span><span class=n>data</span><span class=p>.</span><span class=n>size</span><span class=p>()</span><span class=o>||</span><span class=n>mid</span><span class=o>&lt;</span><span class=mi>0</span><span class=p>)</span><span class=c1>//判断是找到退出还是le&gt;ri退出时，不能用data[mid]<mark>k，因为mid可能&lt;0或</mark>data.size()造成越界
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>cnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>mid</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>data</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>k</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>k</span><span class=p>;</span> <span class=n>i</span><span class=o>--</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>cnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>还有更好的方法是，直接upper_bound-lower_bound就是个数，相当于两次都用二分。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kt>int</span> <span class=nf>upper_bound</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>array</span><span class=o>,</span> <span class=kt>int</span> <span class=n>val</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>l</span> <span class=o>=</span> <span class=n>0</span><span class=o>,</span> <span class=n>r</span> <span class=o>=</span> <span class=n>array</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=n>1</span><span class=o>,</span> <span class=n>mid</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=o>(</span><span class=n>l</span> <span class=o>&lt;=</span> <span class=n>r</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>mid</span> <span class=o>=</span> <span class=o>(</span><span class=n>l</span> <span class=o>+</span> <span class=n>r</span><span class=o>)</span> <span class=o>&gt;&gt;</span> <span class=n>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>array</span><span class=o>[</span><span class=n>mid</span><span class=o>]</span> <span class=o>&lt;=</span> <span class=n>val</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>l</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>r</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>-</span> <span class=n>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>l</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kt>int</span> <span class=nf>lower_bound</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>array</span><span class=o>,</span> <span class=kt>int</span> <span class=n>val</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>l</span> <span class=o>=</span> <span class=n>0</span><span class=o>,</span> <span class=n>r</span> <span class=o>=</span> <span class=n>array</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=n>1</span><span class=o>,</span> <span class=n>mid</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=o>(</span><span class=n>l</span> <span class=o>&lt;=</span> <span class=n>r</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>mid</span> <span class=o>=</span> <span class=o>(</span><span class=n>l</span> <span class=o>+</span> <span class=n>r</span><span class=o>)</span> <span class=o>&gt;&gt;</span> <span class=n>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>array</span><span class=o>[</span><span class=n>mid</span><span class=o>]</span> <span class=o>&lt;</span> <span class=n>val</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>l</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>r</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>-</span> <span class=n>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>l</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#18二叉树深度><h3 id=18二叉树深度><span class=hanchor arialabel=Anchor># </span>18.二叉树深度</h3></a><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>struct TreeNode {
</span></span></span><span class=line><span class=cl><span class=cm>	int val;
</span></span></span><span class=line><span class=cl><span class=cm>	struct TreeNode *left;
</span></span></span><span class=line><span class=cl><span class=cm>	struct TreeNode *right;
</span></span></span><span class=line><span class=cl><span class=cm>	TreeNode(int x) :
</span></span></span><span class=line><span class=cl><span class=cm>			val(x), left(NULL), right(NULL) {
</span></span></span><span class=line><span class=cl><span class=cm>	}
</span></span></span><span class=line><span class=cl><span class=cm>};*/</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>maxDeep</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>getD</span><span class=p>(</span><span class=n>TreeNode</span><span class=o>*</span> <span class=n>pRoot</span><span class=p>,</span><span class=kt>int</span> <span class=n>dep</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>pRoot</span><span class=o>==</span><span class=nb>NULL</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>maxDeep</span><span class=o>=</span><span class=n>max</span><span class=p>(</span><span class=n>maxDeep</span><span class=p>,</span><span class=n>dep</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>dep</span><span class=o>+=</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>getD</span><span class=p>(</span><span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span><span class=n>dep</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>getD</span><span class=p>(</span><span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span><span class=n>dep</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>TreeDepth</span><span class=p>(</span><span class=n>TreeNode</span><span class=o>*</span> <span class=n>pRoot</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>maxDeep</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>pRoot</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>getD</span><span class=p>(</span><span class=n>pRoot</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>maxDeep</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>19.判断是否平衡二叉树</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>getH</span><span class=p>(</span><span class=n>TreeNode</span><span class=o>*</span> <span class=n>pRoot</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>pRoot</span><span class=o>==</span><span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>leftH</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span><span class=n>rightH</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>left</span><span class=o>!=</span><span class=nb>NULL</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>leftH</span><span class=o>=</span><span class=n>getH</span><span class=p>(</span><span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>right</span><span class=o>!=</span><span class=nb>NULL</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>rightH</span><span class=o>=</span><span class=n>getH</span><span class=p>(</span><span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>rightH</span><span class=o>==-</span><span class=mi>1</span><span class=o>||</span><span class=n>leftH</span><span class=o>==-</span><span class=mi>1</span><span class=o>||</span><span class=n>abs</span><span class=p>(</span><span class=n>rightH</span><span class=o>-</span><span class=n>leftH</span><span class=p>)</span><span class=o>&gt;</span><span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>max</span><span class=p>(</span><span class=n>rightH</span><span class=p>,</span><span class=n>leftH</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>IsBalanced_Solution</span><span class=p>(</span><span class=n>TreeNode</span><span class=o>*</span> <span class=n>pRoot</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>getH</span><span class=p>(</span><span class=n>pRoot</span><span class=p>)</span><span class=o>==-</span><span class=mi>1</span><span class=o>?</span><span class=nb>false</span><span class=o>:</span><span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><a href=#19剪绳子><h3 id=19剪绳子><span class=hanchor arialabel=Anchor># </span>19.剪绳子</h3></a><p>题目描述</p><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为k[0],k[1],&mldr;,k[m]。请问k[0]xk[1]x&mldr;xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>输入描述:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>输入一个数n，意义见题面。（2 &lt;= n &lt;= 60）
</span></span></code></pre></td></tr></table></div></div><p>输出描述:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>输出答案。
</span></span></code></pre></td></tr></table></div></div><p>示例1</p><p>输入</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>8
</span></span></code></pre></td></tr></table></div></div><p>输出</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>18
</span></span></code></pre></td></tr></table></div></div><p>思路</p><p>这题我是通过模拟了n=1-16的情况（挺快的，几分钟），发现4-6分两段、7-9分三段、10-12分四段。。。每段长度最接近时成绩最大，以此类推，从而利用数学特性解决，貌似题目初衷是使用动态规划，一位老哥给予了数学证明。</p><p>我的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>cutRope</span><span class=p>(</span><span class=nx>number</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>number</span> <span class=o>===</span> <span class=mi>2</span> <span class=o>||</span> <span class=nx>number</span> <span class=o>===</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>number</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// write code here
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=nx>m</span> <span class=o>=</span> <span class=nx>number</span> <span class=o>%</span> <span class=mi>3</span> <span class=o>===</span> <span class=mi>0</span> <span class=o>?</span> <span class=nx>number</span> <span class=o>/</span> <span class=mi>3</span> <span class=o>:</span> <span class=nb>Math</span><span class=p>.</span><span class=nx>ceil</span><span class=p>(</span><span class=nx>number</span> <span class=o>/</span> <span class=mi>3</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=nx>base</span> <span class=o>=</span> <span class=nb>Math</span><span class=p>.</span><span class=nx>floor</span><span class=p>(</span><span class=nx>number</span> <span class=o>/</span> <span class=nx>m</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=nx>remains</span> <span class=o>=</span> <span class=nx>number</span> <span class=o>%</span> <span class=nx>m</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>Math</span><span class=p>.</span><span class=nx>pow</span><span class=p>(</span><span class=nx>base</span><span class=p>,</span> <span class=nx>m</span> <span class=o>-</span> <span class=nx>remains</span><span class=p>)</span> <span class=o>*</span> <span class=nb>Math</span><span class=p>.</span><span class=nx>pow</span><span class=p>(</span><span class=nx>base</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>remains</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>动态规划</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>cutRope</span><span class=p>(</span><span class=kt>int</span> <span class=n>number</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>number</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>number</span> <span class=o>==</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>f</span><span class=p>(</span><span class=n>number</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=mi>4</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>number</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>i</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>j</span> <span class=o>*</span> <span class=n>f</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=n>j</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>f</span><span class=p>[</span><span class=n>number</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>数学证明</p><p><a href="https://www.nowcoder.com/questionTerminal/57d85990ba5b440ab888fc72b0751bf8?answerType=1&f=discussion" rel=noopener>https://www.nowcoder.com/questionTerminal/57d85990ba5b440ab888fc72b0751bf8?answerType=1&f=discussion</a></p><a href=#20判断子结构><h3 id=20判断子结构><span class=hanchor arialabel=Anchor># </span>20.判断子结构</h3></a><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><p>根据题意可知，需要一个函数判断树A和树B是否有相同的结构。显然是个递归程序。可考察递归程序3部曲。</p><ol><li>递归函数的功能：判断2个数是否有相同的结构，如果相同，返回true，否则返回false</li><li>递归终止条件：</li></ol><ul><li>如果树B为空，返回true，此时，不管树A是否为空，都为true</li><li>否则，如果树B不为空，但是树A为空，返回false，此时B还没空但A空了，显然false</li></ul><ol><li>下一步递归参数：</li></ol><ul><li>如果A的根节点和B的根节点不相等，直接返回false</li><li>否则，相等，就继续判断A的左子树和B的左子树，A的右子树和B的右子树</li></ul><p>代码</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>HasSubtree</span><span class=p>(</span><span class=n>TreeNode</span><span class=o>*</span> <span class=n>pRoot1</span><span class=p>,</span> <span class=n>TreeNode</span><span class=o>*</span> <span class=n>pRoot2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>pRoot1</span> <span class=o>||</span> <span class=o>!</span><span class=n>pRoot2</span><span class=p>)</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dfs</span><span class=p>(</span><span class=n>pRoot1</span><span class=p>,</span> <span class=n>pRoot2</span><span class=p>)</span> <span class=o>||</span> <span class=n>HasSubtree</span><span class=p>(</span><span class=n>pRoot1</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>pRoot2</span><span class=p>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>    <span class=n>HasSubtree</span><span class=p>(</span><span class=n>pRoot1</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>pRoot2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>TreeNode</span> <span class=o>*</span><span class=n>r1</span><span class=p>,</span> <span class=n>TreeNode</span> <span class=o>*</span><span class=n>r2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>r2</span><span class=p>)</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>r1</span><span class=p>)</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>r1</span><span class=o>-&gt;</span><span class=n>val</span><span class=o>==</span><span class=n>r2</span><span class=o>-&gt;</span><span class=n>val</span> <span class=o>&amp;&amp;</span> <span class=n>dfs</span><span class=p>(</span><span class=n>r1</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>r2</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>dfs</span><span class=p>(</span><span class=n>r1</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>r2</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=cm>/* function TreeNode(x) {
</span></span></span><span class=line><span class=cl><span class=cm>    this.val = x;
</span></span></span><span class=line><span class=cl><span class=cm>    this.left = null;
</span></span></span><span class=line><span class=cl><span class=cm>    this.right = null;
</span></span></span><span class=line><span class=cl><span class=cm>} */</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>HasSubtree</span><span class=p>(</span><span class=nx>r1</span><span class=p>,</span> <span class=nx>r2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>r1</span> <span class=o>||</span> <span class=o>!</span><span class=nx>r2</span><span class=p>)</span> <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>test</span><span class=p>(</span><span class=nx>r1</span><span class=p>,</span><span class=nx>r2</span><span class=p>)</span><span class=o>||</span><span class=nx>HasSubtree</span><span class=p>(</span><span class=nx>r1</span><span class=p>.</span><span class=nx>left</span><span class=p>,</span><span class=nx>r2</span><span class=p>)</span><span class=o>||</span><span class=nx>HasSubtree</span><span class=p>(</span><span class=nx>r1</span><span class=p>.</span><span class=nx>right</span><span class=p>,</span><span class=nx>r2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>test</span><span class=p>(</span><span class=nx>r1</span><span class=p>,</span><span class=nx>r2</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  	<span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=nx>r2</span><span class=p>)</span> <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>  	<span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=nx>r1</span><span class=p>)</span> <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>r1</span><span class=p>.</span><span class=nx>val</span><span class=o>===</span><span class=nx>r2</span><span class=p>.</span><span class=nx>val</span><span class=o>&amp;&amp;</span><span class=nx>test</span><span class=p>(</span><span class=nx>r1</span><span class=p>.</span><span class=nx>left</span><span class=p>,</span><span class=nx>r2</span><span class=p>.</span><span class=nx>left</span><span class=p>)</span><span class=o>&amp;&amp;</span><span class=nx>test</span><span class=p>(</span><span class=nx>r1</span><span class=p>.</span><span class=nx>right</span><span class=p>,</span><span class=nx>r2</span><span class=p>.</span><span class=nx>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>可能是20200612写的时候很困，看了半天才写出来，分为两步吧，第一步先遍历每个结点，如果这两个结点的值相同，则r1和r2都需要在检查左、右儿子是否相同，即<code>r1.val===r2.val&&test(r1.left,r2.left)&&test(r1.right,r2.right)</code>，如果值不同，则检查r1的左右儿子是否与r2的值相同，即<code>HasSubtree(r1.left,r2)||HasSubtree(r1.right,r2)</code>（r2不需要。left或。right），也仅在<code>test(r1,r2)||…</code>中test返回false时才会运行后面的函数。</p><a href=#21二叉树镜像><h3 id=21二叉树镜像><span class=hanchor arialabel=Anchor># </span>21.二叉树镜像</h3></a><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>struct TreeNode {
</span></span></span><span class=line><span class=cl><span class=cm>    int val;
</span></span></span><span class=line><span class=cl><span class=cm>    struct TreeNode *left;
</span></span></span><span class=line><span class=cl><span class=cm>    struct TreeNode *right;
</span></span></span><span class=line><span class=cl><span class=cm>    TreeNode(int x) :
</span></span></span><span class=line><span class=cl><span class=cm>            val(x), left(NULL), right(NULL) {
</span></span></span><span class=line><span class=cl><span class=cm>    }
</span></span></span><span class=line><span class=cl><span class=cm>};*/</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Mirror</span><span class=p>(</span><span class=n>TreeNode</span> <span class=o>*</span><span class=n>pRoot</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>pRoot</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>left</span><span class=o>==</span><span class=nb>NULL</span><span class=o>&amp;&amp;</span><span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>right</span><span class=o>==</span><span class=nb>NULL</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>TreeNode</span> <span class=o>*</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>left</span><span class=o>!=</span><span class=nb>NULL</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>tmp</span><span class=o>=</span><span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>right</span><span class=o>=</span><span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>left</span><span class=o>=</span><span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>tmp</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>left</span><span class=o>=</span><span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>left</span><span class=o>=</span><span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>right</span><span class=o>=</span><span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>Mirror</span><span class=p>(</span><span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Mirror</span><span class=p>(</span><span class=n>pRoot</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://jieye-ericx.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Jieye ericx using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://jieye-ericx.github.io/>Home</a></li><li><a href=https://github.com/jieye-ericx>Github</a></li></ul></footer></div></div></body></html>