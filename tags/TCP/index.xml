<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TCP on</title><link>https://jieye-ericx.github.io/tags/TCP/</link><description>Recent content in TCP on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://jieye-ericx.github.io/tags/TCP/index.xml" rel="self" type="application/rss+xml"/><item><title>缺陷</title><link>https://jieye-ericx.github.io/TCP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/TCP/</guid><description>状态 [[time_await]]
握手 [[三次握手与四次挥手时的Seq 与 ACK]] [[与quic协议TLS握手次数]]
特性 [[TCP 延迟确认机制]]
![[fast open]]
Keepalive TCP 的 Keepalive 这东西其实就是 TCP 的保活机制，它的工作原理我之前的文章写过，这里就直接贴下以前的内容。 如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。 如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。 如果对端主机宕机（注意不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机），或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。 ^a0811d (关于 HTTP 的 [[HTTP#^d5b1b1|keepalive]] 缺陷 针对 HTTPS 来说，TLS 是在应用层实现的握手，而 TCP 是在内核实现的握手，这两个握手过程是无法结合在一起的，总是得先完成 TCP 握手，才能进行 TLS 握手。</description></item><item><title>队头阻塞</title><link>https://jieye-ericx.github.io/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jieye-ericx.github.io/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E/</guid><description>导致接收窗口的队头阻塞问题，是因为 TCP 必须按序处理数据，也就是 TCP 层为了保证数据的有序性，只有在处理完有序的数据后，滑动窗口才能往前滑动，否则就停留，停留「接收窗口」会使得应用层无法读取新的数据。</description></item></channel></rss>