<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="1. Mouseenter 和 Mouseover 的区别 mouseover 事件：不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。
mouseenter 事件：只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。
以及
mouseout 事件：不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件。
mouseleave 事件：只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。"><meta property="og:title" content="javascript"><meta property="og:description" content="1. Mouseenter 和 Mouseover 的区别 mouseover 事件：不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。
mouseenter 事件：只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。
以及
mouseout 事件：不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件。
mouseleave 事件：只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。"><meta property="og:type" content="website"><meta property="og:image" content="https://jieye-ericx.github.io/icon.png"><meta property="og:url" content="https://jieye-ericx.github.io/javascript/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="javascript"><meta name=twitter:description content="1. Mouseenter 和 Mouseover 的区别 mouseover 事件：不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。
mouseenter 事件：只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。
以及
mouseout 事件：不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件。
mouseleave 事件：只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。"><meta name=twitter:image content="https://jieye-ericx.github.io/icon.png"><title>javascript</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://jieye-ericx.github.io//icon.png><link href=https://jieye-ericx.github.io/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://jieye-ericx.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://jieye-ericx.github.io/js/darkmode.48459b7116d092b4e98d2cab704cad80.min.js></script>
<script src=https://jieye-ericx.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://jieye-ericx.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://jieye-ericx.github.io/",fetchData=Promise.all([fetch("https://jieye-ericx.github.io/indices/linkIndex.a91535da5bc472c24479fcf5acf89c4d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://jieye-ericx.github.io/indices/contentIndex.d2e25530f3ca3ecf62396d5270cd9539.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://jieye-ericx.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://jieye-ericx.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/jieye-ericx.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=jieye-ericx.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://jieye-ericx.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://jieye-ericx.github.io/>jieye の 数字花园</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>javascript</h1><p class=meta>Last updated
Nov 1, 2021</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#1-mouseenter-和-mouseover-的区别>1. Mouseenter 和 Mouseover 的区别</a></li><li><a href=#2-alert12alert10>2. alert（1&&2），alert（1||0）</a></li><li><a href=#3-为什么-tcp-连接需要三次握手两次不可以吗为什么>3. 为什么 TCP 连接需要三次握手，两次不可以吗，为什么</a></li><li><a href=#4-js-字符串两边截取空白的-trim-的原型方法的实现>4. Js 字符串两边截取空白的 Trim 的原型方法的实现</a></li><li><a href=#5-1-2-3mapparseint-what--why->5. <code>['1', '2', '3'].map(parseInt)</code> What & Why ?</a></li><li><a href=#6-防抖与节流>6. 防抖与节流</a></li><li><a href=#7-介绍下-setmapweakset-和-weakmap-的区别>7. 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？</a><ol><li></li></ol></li><li><a href=#8-es5es6-的继承除了写法以外还有什么区别>8. ES5/ES6 的继承除了写法以外还有什么区别？</a></li><li><a href=#9-3-个判断数组的方法请分别介绍它们之间的区别和优劣>9. 3 个判断数组的方法，请分别介绍它们之间的区别和优劣</a></li><li><a href=#10介绍模块化发展历程>10.介绍模块化发展历程</a></li><li><a href=#11全局作用域中用-const-和-let-声明的变量不在-window-上那到底在哪里如何去获取>11.全局作用域中，用 Const 和 Let 声明的变量不在 Window 上，那到底在哪里？如何去获取？</a></li><li><a href=#12使用-sort-对数组-3-15-8-29-102-22-进行排序输出结果>12.使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果</a></li><li><a href=#13-js-javascript-demo-functioncall-javascript-demo-functionapply>13. JS **JavaScript Demo: Function.call() **JavaScript Demo: Function.apply()</a></li><li><a href=#14输出以下代码的执行结果并解释为什么>14.输出以下代码的执行结果并解释为什么</a></li><li><a href=#15-数组里-10-万个数据取第一个元素和第-99999-个元素时间相差多少>15. 数组里 10 万个数据，取第一个元素和第 99999 个元素时间相差多少</a></li><li><a href=#16输出以下代码运行结果>16.输出以下代码运行结果</a></li><li><a href=#17varlet-和-const-区别的实现原理是什么>17.var、let 和 Const 区别的实现原理是什么</a></li><li><a href=#18asyncawait-如何通过同步的方式实现异步>18.Async/Await 如何通过同步的方式实现异步</a></li><li><a href=#19输出运行结果>19.输出运行结果</a><ol><li><a href=#构造函数的返回值>构造函数的返回值</a></li></ol></li><li><a href=#20写出结果>20.写出结果</a></li><li><a href=#21写出结果>21.写出结果</a></li><li><a href=#22为什么-for-循环嵌套顺序会影响性能>22.为什么 For 循环嵌套顺序会影响性能？</a></li><li><a href=#23输出以下代码执行结果>23.输出以下代码执行结果</a></li><li><a href=#24理解任务队列-消息队列>24.理解任务队列 (消息队列)</a></li><li><a href=#25for-in-和-for-of-的区别>25.for In 和 for of 的区别</a></li><li><a href=#26数组扁平化处理实现一个-flatten-方法使得输入一个数组该数组里面的元素也可以是数组该方法会输出一个扁平化的数组>26.数组扁平化处理：实现一个 Flatten 方法，使得输入一个数组，该数组里面的元素也可以是数组，该方法会输出一个扁平化的数组</a></li><li><a href=#26asyncawait-和-promise>26.Async/await 和 Promise</a><ol><li><a href=#promisethen>Promise.then()</a></li><li><a href=#await>Await</a></li><li><a href=#结论>结论</a></li></ol></li><li><a href=#27commonjs-和-es6-模块化的区别以及如何解决让-commonjs-导出的模块也能改变其内部变量>27.CommonJS 和 ES6 模块化的区别以及如何解决让 CommonJS 导出的模块也能改变其内部变量</a><ol><li><a href=#es6-模块化>ES6 模块化</a></li><li><a href=#commonjs>CommonJs</a></li></ol></li><li><a href=#28webpack-中-loader-和-plugin-的区别是什么httpsgithubcomadvanced-frontenddaily-interview-questionissues308>28.<a href=https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/308#>webpack 中 loader 和 plugin 的区别是什么</a></a><ol><li></li></ol></li><li><a href=#29手写-callapplybind-实现及详解>29.手写 call、apply、bind 实现及详解</a><ol><li><a href=#call>Call</a></li><li><a href=#apply>Apply</a></li><li><a href=#bind>Bind</a></li></ol></li></ol></nav></details></aside><a href=#1-mouseenter-和-mouseover-的区别><h2 id=1-mouseenter-和-mouseover-的区别><span class=hanchor arialabel=Anchor># </span>1. Mouseenter 和 Mouseover 的区别</h2></a><p>mouseover 事件：不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。</p><p>mouseenter 事件：只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。</p><p>以及</p><p>mouseout 事件：不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件。</p><p>mouseleave 事件：只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。</p><a href=#2-alert12alert10><h2 id=2-alert12alert10><span class=hanchor arialabel=Anchor># </span>2. alert（1&&2），alert（1||0）</h2></a><p>&&运算符，前面的 true，返回后面的。前面的为 false，返回前面的。</p><p>||运算符，前面的为 true，返回前面的。前面的为 false，返回后面的。</p><a href=#3-为什么-tcp-连接需要三次握手两次不可以吗为什么><h2 id=3-为什么-tcp-连接需要三次握手两次不可以吗为什么><span class=hanchor arialabel=Anchor># </span>3. 为什么 TCP 连接需要三次握手，两次不可以吗，为什么</h2></a><p>感觉自己还没懂，先占坑，可看知乎</p><a href=#4-js-字符串两边截取空白的-trim-的原型方法的实现><h2 id=4-js-字符串两边截取空白的-trim-的原型方法的实现><span class=hanchor arialabel=Anchor># </span>4. Js 字符串两边截取空白的 Trim 的原型方法的实现</h2></a><a href=#5-1-2-3mapparseint-what--why-><h2 id=5-1-2-3mapparseint-what--why-><span class=hanchor arialabel=Anchor># </span>5. <code>['1', '2', '3'].map(parseInt)</code> What & Why ?</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=p>[</span><span class=s1>&#39;10&#39;</span><span class=p>,</span><span class=s1>&#39;10&#39;</span><span class=p>,</span><span class=s1>&#39;10&#39;</span><span class=p>,</span><span class=s1>&#39;10&#39;</span><span class=p>,</span><span class=s1>&#39;10&#39;</span><span class=p>].</span><span class=nx>map</span><span class=p>(</span><span class=nb>parseInt</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// [10, NaN, 2, 3, 4]
</span></span></span></code></pre></td></tr></table></div></div><p>奇怪吧</p><p>首先需要知道 parseInt：</p><p><strong>parseInt(string, radix)</strong> 将一个字符串 string 转换为 radix 进制的整数， radix 为介于 2-36 之间的数。即将 string 看作是 radix 进制的数，并返回其对应的十进制数。</p><ul><li><p><code>string</code></p><p>要被解析的值。如果参数不是一个字符串，则将其转换为字符串 (使用 <code>ToString</code> 抽象操作)。字符串开头的空白符将会被忽略。</p></li><li><p><code>radix</code></p><p>一个介于 2 和 36 之间的整数 (数学系统的基础)，表示上述字符串的<strong>基数</strong>。比如参数 10 表示使用十进制数值系统。<strong>始终指定此参数</strong>可以消除阅读该代码时的困惑并且保证转换结果可预测。当未指定基数时，不同的实现会产生不同的结果，通常认为其值默认为<strong>10</strong>，但是如果你的代码运行在过时的浏览器中，那么请在使用时<strong>总是显式地指定 radix</strong>。</p></li></ul><p>返回解析后的整数值（十进制）。 如果被解析参数的第一个字符无法被转化成数值类型，则返回
<a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN rel=noopener><code>NaN</code></a>。</p><p>注意：</p><ul><li><code>radix</code> 参数为 n 将会把第一个参数看作是一个数的 n 进制表示，而返回的值则是十进制的。例如：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl>parseInt(&#39;123&#39;, 5) // 将&#39;123&#39;看作5进制数，返回十进制数38 =&gt; 1*5^2 + 2*5^1 + 3*5^0 = 38
</span></span></code></pre></td></tr></table></div></div><ul><li><p>如果 <code>parseInt</code> 的字符不是指定基数中的数字，则忽略该字符和所有后续字符，并返回解析到该点的整数值。<code>parseInt</code> 将数字截断为整数值。允许使用前导空格和尾随空格。</p></li><li><p>使用 parseInt 去截取包含 e 字符数值部分会造成难以预料的结果。例如：</p><p>parseInt(&ldquo;6.022e23&rdquo;, 10); // 返回 6<br>parseInt(6.022e2, 10); // 返回 602</p></li><li><p>在基数为 <code>undefined</code>，或者基数为 0 或者没有指定的情况下，JavaScript 作如下处理：</p><ul><li>如果字符串 <code>string</code> 以 &ldquo;0x&rdquo; 或者 &ldquo;0X&rdquo; 开头, 则基数是 16 (16 进制).</li><li>如果字符串 <code>string</code> 以 &ldquo;0&rdquo; 开头, 基数是 8（八进制）或者 10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用 10，但是并不是所有的浏览器都遵循这个规定。因此，<strong>永远都要明确给出 radix 参数的值</strong>。</li><li>如果字符串 <code>string</code> 以其它任何值开头，则基数是 10 (十进制)。</li></ul><p>如果第一个字符不能被转换成数字，<code>parseInt</code> 返回 <code>NaN</code>。</p><p>算术上， <code>NaN</code> 不是任何一个进制下的数。 你可以调用
<a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN rel=noopener><code>isNaN</code></a> 来判断 <code>parseInt</code> 是否返回 <code>NaN</code>。<code>NaN</code> 参与的数学运算其结果总是 <code>NaN</code>。</p><p>将整型数值以特定基数转换成它的字符串值可以使用 <code>intValue.toString(radix)</code>.</p></li></ul><p>其次还得知道 map():<code>map()</code> 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>new_array</span> <span class=o>=</span> <span class=nx>arr</span><span class=p>.</span><span class=nx>map</span><span class=p>(</span><span class=kd>function</span> <span class=nx>callback</span><span class=p>(</span><span class=nx>currentValue</span><span class=p>[,</span><span class=nx>index</span><span class=p>[,</span> <span class=nx>array</span><span class=p>]])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=c1>// Return element for new_array
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=p>}[,</span> <span class=nx>thisArg</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>可以看到 <code>callback</code> 回调函数需要三个参数, 我们通常只使用第一个参数 (其他两个参数是可选的)。</p><p><code>currentValue</code> 是 callback 数组中正在处理的当前元素。</p><p><code>index</code> 可选, 是 callback 数组中正在处理的当前元素的索引。</p><p><code>array</code> 可选, 是 callback map 方法被调用的数组。</p><p>另外还有 <code>thisArg</code> 可选, 执行 callback 函数时使用的 this 值。</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=p>[</span><span class=s1>&#39;1&#39;</span><span class=p>,</span> <span class=s1>&#39;2&#39;</span><span class=p>,</span> <span class=s1>&#39;3&#39;</span><span class=p>].</span><span class=nx>map</span><span class=p>(</span><span class=nb>parseInt</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>对于每个迭代 <code>map</code>, <code>parseInt()</code> 传递两个参数: <strong>字符串和基数</strong>。 所以实际执行的的代码是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=p>[</span><span class=s1>&#39;1&#39;</span><span class=p>,</span> <span class=s1>&#39;2&#39;</span><span class=p>,</span> <span class=s1>&#39;3&#39;</span><span class=p>].</span><span class=nx>map</span><span class=p>((</span><span class=nx>item</span><span class=p>,</span> <span class=nx>index</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>parseInt</span><span class=p>(</span><span class=nx>item</span><span class=p>,</span> <span class=nx>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></td></tr></table></div></div><p>即返回的值分别为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nb>parseInt</span><span class=p>(</span><span class=s1>&#39;1&#39;</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>parseInt</span><span class=p>(</span><span class=s1>&#39;2&#39;</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=c1>// NaN
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>parseInt</span><span class=p>(</span><span class=s1>&#39;3&#39;</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> <span class=c1>// NaN, 3 不是二进制
</span></span></span></code></pre></td></tr></table></div></div><p>所以：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=p>[</span><span class=s1>&#39;1&#39;</span><span class=p>,</span> <span class=s1>&#39;2&#39;</span><span class=p>,</span> <span class=s1>&#39;3&#39;</span><span class=p>].</span><span class=nx>map</span><span class=p>(</span><span class=nb>parseInt</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 1, NaN, NaN
</span></span></span></code></pre></td></tr></table></div></div><p>由此，加里·伯恩哈德例子也就很好解释了，这里不再赘述</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=p>[</span><span class=s1>&#39;10&#39;</span><span class=p>,</span><span class=s1>&#39;10&#39;</span><span class=p>,</span><span class=s1>&#39;10&#39;</span><span class=p>,</span><span class=s1>&#39;10&#39;</span><span class=p>,</span><span class=s1>&#39;10&#39;</span><span class=p>].</span><span class=nx>map</span><span class=p>(</span><span class=nb>parseInt</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// [10, NaN, 2, 3, 4]
</span></span></span></code></pre></td></tr></table></div></div><p>如下解决</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=p>[</span><span class=s1>&#39;10&#39;</span><span class=p>,</span><span class=s1>&#39;10&#39;</span><span class=p>,</span><span class=s1>&#39;10&#39;</span><span class=p>,</span><span class=s1>&#39;10&#39;</span><span class=p>,</span><span class=s1>&#39;10&#39;</span><span class=p>].</span><span class=nx>map</span><span class=p>((</span><span class=nx>val</span><span class=p>,</span><span class=nx>index</span><span class=p>)=&gt;{</span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>val</span><span class=o>+</span><span class=s1>&#39;,&#39;</span><span class=o>+</span><span class=nx>index</span><span class=p>);</span><span class=k>return</span> <span class=nb>parseInt</span><span class=p>(</span><span class=nx>val</span><span class=p>,</span><span class=mi>10</span><span class=p>)})</span>
</span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>[</span><span class=s1>&#39;10&#39;</span><span class=p>,</span><span class=s1>&#39;10&#39;</span><span class=p>,</span><span class=s1>&#39;10&#39;</span><span class=p>,</span><span class=s1>&#39;10&#39;</span><span class=p>,</span><span class=s1>&#39;10&#39;</span><span class=p>].</span><span class=nx>map</span><span class=p>(</span><span class=nb>Number</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><a href=#6-防抖与节流><h2 id=6-防抖与节流><span class=hanchor arialabel=Anchor># </span>6. 防抖与节流</h2></a><p><a href=https://github.com/mqyqingfeng/Blog/issues/22 rel=noopener>参考</a></p><ol><li><strong>防抖</strong></li></ol><blockquote><p>触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间</p></blockquote><ul><li>思路：</li></ul><blockquote><p>每次触发事件时都取消之前的延时调用方法</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>debounce</span><span class=p>(</span><span class=nx>fn</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>timeout</span> <span class=o>=</span> <span class=kc>null</span> <span class=c1>// 创建一个标记用来存放定时器的返回值
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>clearTimeout</span><span class=p>(</span><span class=nx>timeout</span><span class=p>)</span> <span class=c1>// 每当用户输入的时候把前一个 setTimeout clear 掉
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>timeout</span> <span class=o>=</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nx>fn</span><span class=p>.</span><span class=nx>apply</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=nx>arguments</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=mi>500</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>sayHi</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;防抖成功&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>inp</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s1>&#39;inp&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>inp</span><span class=p>.</span><span class=nx>addEventListener</span><span class=p>(</span><span class=s1>&#39;input&#39;</span><span class=p>,</span> <span class=nx>debounce</span><span class=p>(</span><span class=nx>sayHi</span><span class=p>))</span> <span class=c1>// 防抖
</span></span></span></code></pre></td></tr></table></div></div><ol><li><strong>节流</strong></li></ol><blockquote><p>高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率</p></blockquote><ul><li>思路：</li></ul><blockquote><p>每次触发事件时都判断当前是否有等待执行的延时函数</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>throttle</span><span class=p>(</span><span class=nx>fn</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>canRun</span> <span class=o>=</span> <span class=kc>true</span> <span class=c1>// 通过闭包保存一个标记
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>canRun</span><span class=p>)</span> <span class=k>return</span> <span class=c1>// 在函数开头判断标记是否为true，不为true则return
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>canRun</span> <span class=o>=</span> <span class=kc>false</span> <span class=c1>// 立即设置为false
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 将外部传入的函数的执行放在setTimeout中
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nx>fn</span><span class=p>.</span><span class=nx>apply</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=nx>arguments</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nx>canRun</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=mi>500</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>sayHi</span><span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nx>target</span><span class=p>.</span><span class=nx>innerWidth</span><span class=p>,</span> <span class=nx>e</span><span class=p>.</span><span class=nx>target</span><span class=p>.</span><span class=nx>innerHeight</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nb>window</span><span class=p>.</span><span class=nx>addEventListener</span><span class=p>(</span><span class=s1>&#39;resize&#39;</span><span class=p>,</span> <span class=nx>throttle</span><span class=p>(</span><span class=nx>sayHi</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><a href=#7-介绍下-setmapweakset-和-weakmap-的区别><h2 id=7-介绍下-setmapweakset-和-weakmap-的区别><span class=hanchor arialabel=Anchor># </span>7. 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？</h2></a><p>Set 和 Map 主要的应用场景在于 <strong>数据重组</strong> 和 <strong>数据储存</strong></p><p>Set 是一种叫做<strong>集合</strong>的数据结构，Map 是一种叫做<strong>字典</strong>的数据结构</p><a href=#1-集合set><h4 id=1-集合set><span class=hanchor arialabel=Anchor># </span>1. 集合（Set）</h4></a><p>ES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。</p><p><strong>Set 本身是一种构造函数，用来生成 Set 数据结构。</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=k>new</span> <span class=nx>Set</span><span class=p>([</span><span class=nx>iterable</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><p>举个例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>s</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>].</span><span class=nx>forEach</span><span class=p>(</span><span class=nx>x</span> <span class=p>=&gt;</span> <span class=nx>s</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=nx>x</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=k>of</span> <span class=nx>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>	<span class=c1>// 1 2 3 4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 去重数组的重复对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span> <span class=nx>arr</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>[...</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>(</span><span class=nx>arr</span><span class=p>)]</span>	<span class=c1>// [1, 2, 3]
</span></span></span></code></pre></td></tr></table></div></div><p>Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用。</p><p>向 Set 加入值的时候，不会发生类型转换，所以 <code>5</code> 和 <code>"5"</code> 是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于<strong>精确相等</strong>运算符（<code>===</code>），主要的区别是**<code>NaN</code> 等于自身，而精确相等运算符认为 <code>NaN</code> 不等于自身。**</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>set</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>a</span> <span class=o>=</span> <span class=kc>NaN</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>b</span> <span class=o>=</span> <span class=kc>NaN</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>set</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=nx>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>set</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=nx>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>set</span> <span class=c1>// Set {NaN}
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>set1</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>set1</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>set1</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=s1>&#39;5&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>([...</span><span class=nx>set1</span><span class=p>])</span>	<span class=c1>// [5, &#34;5&#34;]
</span></span></span></code></pre></td></tr></table></div></div><ul><li><p>Set 实例属性</p><ul><li><p>constructor： 构造函数</p></li><li><p>size：元素数量</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>set</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>set</span><span class=p>.</span><span class=nx>length</span><span class=p>)</span>	<span class=c1>// undefined
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>set</span><span class=p>.</span><span class=nx>size</span><span class=p>)</span>	<span class=c1>// 3
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li><li><p>Set 实例方法</p><ul><li><p>操作方法</p><ul><li><p>add(value)：新增，相当于 array 里的 push</p></li><li><p>delete(value)：存在即删除集合中 value</p></li><li><p>has(value)：判断集合中是否存在 value</p></li><li><p>clear()：清空集合</p><hr><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>set</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>set</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=mi>1</span><span class=p>).</span><span class=nx>add</span><span class=p>(</span><span class=mi>2</span><span class=p>).</span><span class=nx>add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>set</span><span class=p>.</span><span class=nx>has</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>	<span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>set</span><span class=p>.</span><span class=nx>has</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>	<span class=c1>// false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>set</span><span class=p>.</span><span class=k>delete</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>	
</span></span><span class=line><span class=cl><span class=nx>set</span><span class=p>.</span><span class=nx>has</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>	<span class=c1>// false
</span></span></span></code></pre></td></tr></table></div></div><p><code>Array.from</code> 方法可以将 Set 结构转为数组</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>items</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>array</span> <span class=o>=</span> <span class=nb>Array</span><span class=p>.</span><span class=nx>from</span><span class=p>(</span><span class=nx>items</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>array</span><span class=p>)</span>	<span class=c1>// [1, 2, 3]
</span></span></span><span class=line><span class=cl><span class=c1>// 或
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>arr</span> <span class=o>=</span> <span class=p>[...</span><span class=nx>items</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span>	<span class=c1>// [1, 2, 3]
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li><li><p>遍历方法（遍历顺序为插入顺序）</p><ul><li><p>keys()：返回一个包含集合中所有键的迭代器</p></li><li><p>values()：返回一个包含集合中所有值得迭代器</p></li><li><p>entries()：返回一个包含 Set 对象中所有元素得键值对迭代器</p></li><li><p>forEach(callbackFn, thisArg)：用于对集合成员执行 callbackFn 操作，如果提供了 thisArg 参数，回调中的 this 会是这个参数，<strong>没有返回值</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>set</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>set</span><span class=p>.</span><span class=nx>keys</span><span class=p>())</span>	<span class=c1>// SetIterator {1, 2, 3}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>set</span><span class=p>.</span><span class=nx>values</span><span class=p>())</span>	<span class=c1>// SetIterator {1, 2, 3}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>set</span><span class=p>.</span><span class=nx>entries</span><span class=p>())</span>	<span class=c1>// SetIterator {1, 2, 3}
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>item</span> <span class=k>of</span> <span class=nx>set</span><span class=p>.</span><span class=nx>keys</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>	<span class=c1>// 1	2	 3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>item</span> <span class=k>of</span> <span class=nx>set</span><span class=p>.</span><span class=nx>entries</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>	<span class=c1>// [1, 1]	[2, 2]	[3, 3]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>set</span><span class=p>.</span><span class=nx>forEach</span><span class=p>((</span><span class=nx>value</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>key</span> <span class=o>+</span> <span class=s1>&#39; : &#39;</span> <span class=o>+</span> <span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>})</span>	<span class=c1>// 1 : 1	2 : 2	3 : 3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>([...</span><span class=nx>set</span><span class=p>])</span>	<span class=c1>// [1, 2, 3]
</span></span></span></code></pre></td></tr></table></div></div><p>Set 可默认遍历，默认迭代器生成函数是 values() 方法</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>Set</span><span class=p>.</span><span class=nx>prototype</span><span class=p>[</span><span class=nx>Symbol</span><span class=p>.</span><span class=nx>iterator</span><span class=p>]</span> <span class=o>===</span> <span class=nx>Set</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>values</span>	<span class=c1>// true
</span></span></span></code></pre></td></tr></table></div></div><p>所以， Set 可以使用 map、filter 方法</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>set</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nx>set</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>([...</span><span class=nx>set</span><span class=p>].</span><span class=nx>map</span><span class=p>(</span><span class=nx>item</span> <span class=p>=&gt;</span> <span class=nx>item</span> <span class=o>*</span> <span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>([...</span><span class=nx>set</span><span class=p>])</span>	<span class=c1>// [2, 4, 6]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>set</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>([...</span><span class=nx>set</span><span class=p>].</span><span class=nx>filter</span><span class=p>(</span><span class=nx>item</span> <span class=p>=&gt;</span> <span class=p>(</span><span class=nx>item</span> <span class=o>&gt;=</span> <span class=mi>4</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>([...</span><span class=nx>set</span><span class=p>])</span>	<span class=c1>//[4, 6]
</span></span></span></code></pre></td></tr></table></div></div><p>因此，Set 很容易实现交集（Intersect）、并集（Union）、差集（Difference）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>set1</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>set2</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>([</span><span class=mi>4</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>intersect</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>([...</span><span class=nx>set1</span><span class=p>].</span><span class=nx>filter</span><span class=p>(</span><span class=nx>value</span> <span class=p>=&gt;</span> <span class=nx>set2</span><span class=p>.</span><span class=nx>has</span><span class=p>(</span><span class=nx>value</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>union</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>([...</span><span class=nx>set1</span><span class=p>,</span> <span class=p>...</span><span class=nx>set2</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>difference</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>([...</span><span class=nx>set1</span><span class=p>].</span><span class=nx>filter</span><span class=p>(</span><span class=nx>value</span> <span class=p>=&gt;</span> <span class=o>!</span><span class=nx>set2</span><span class=p>.</span><span class=nx>has</span><span class=p>(</span><span class=nx>value</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>intersect</span><span class=p>)</span>	<span class=c1>// Set {2, 3}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>union</span><span class=p>)</span>		<span class=c1>// Set {1, 2, 3, 4}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>difference</span><span class=p>)</span>	<span class=c1>// Set {1}
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li></ul></li></ul><a href=#2-weakset><h4 id=2-weakset><span class=hanchor arialabel=Anchor># </span>2. WeakSet</h4></a><p>WeakSet 对象允许你将<strong>弱引用对象</strong>储存在一个集合中</p><p>WeakSet 与 Set 的区别：</p><ul><li>WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以</li><li>WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素</li></ul><p>属性：</p><ul><li><p>constructor：构造函数，任何一个具有 Iterable 接口的对象，都可以作参数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>arr</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>],</span> <span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>]]</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>weakset</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>WeakSet</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>weakset</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/blogs/%e9%9d%a2%e8%af%95/JavaScript/20210405162005.png width=auto alt=img></p><p>方法：</p><ul><li>add(value)：在 WeakSet 对象中添加一个元素 value</li><li>has(value)：判断 WeakSet 对象中是否包含 value</li><li>delete(value)：删除元素 value</li><li>clear()：清空所有元素，<strong>注意该方法已废弃</strong></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>ws</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>WeakSet</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>obj</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>foo</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>ws</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=nb>window</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>ws</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=nx>obj</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>ws</span><span class=p>.</span><span class=nx>has</span><span class=p>(</span><span class=nb>window</span><span class=p>)</span>	<span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>ws</span><span class=p>.</span><span class=nx>has</span><span class=p>(</span><span class=nx>foo</span><span class=p>)</span>	<span class=c1>// false
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>ws</span><span class=p>.</span><span class=k>delete</span><span class=p>(</span><span class=nb>window</span><span class=p>)</span>	<span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>ws</span><span class=p>.</span><span class=nx>has</span><span class=p>(</span><span class=nb>window</span><span class=p>)</span>	<span class=c1>// false
</span></span></span></code></pre></td></tr></table></div></div><a href=#3-字典map><h4 id=3-字典map><span class=hanchor arialabel=Anchor># </span>3. 字典（Map）</h4></a><p>集合 与 字典 的区别：</p><ul><li>共同点：集合、字典 可以储存不重复的值</li><li>不同点：集合 是以 [value, value] 的形式储存元素，字典 是以 [key, value] 的形式储存</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>m</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Map</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>o</span> <span class=o>=</span> <span class=p>{</span><span class=nx>p</span><span class=o>:</span> <span class=s1>&#39;haha&#39;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>m</span><span class=p>.</span><span class=nx>set</span><span class=p>(</span><span class=nx>o</span><span class=p>,</span> <span class=s1>&#39;content&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>m</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=nx>o</span><span class=p>)</span>	<span class=c1>// content
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>m</span><span class=p>.</span><span class=nx>has</span><span class=p>(</span><span class=nx>o</span><span class=p>)</span>	<span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>m</span><span class=p>.</span><span class=k>delete</span><span class=p>(</span><span class=nx>o</span><span class=p>)</span>	<span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>m</span><span class=p>.</span><span class=nx>has</span><span class=p>(</span><span class=nx>o</span><span class=p>)</span>	<span class=c1>// false
</span></span></span></code></pre></td></tr></table></div></div><p><strong>任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构</strong>都可以当作 <code>Map</code> 构造函数的参数，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>set</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>([</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=s1>&#39;foo&#39;</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=s1>&#39;bar&#39;</span><span class=p>,</span> <span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>m1</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Map</span><span class=p>(</span><span class=nx>set</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>m1</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=s1>&#39;foo&#39;</span><span class=p>)</span> <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>m2</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Map</span><span class=p>(<a class="internal-link broken">span><span class=s1>&</a>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>m3</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Map</span><span class=p>(</span><span class=nx>m2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>m3</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=s1>&#39;baz&#39;</span><span class=p>)</span> <span class=c1>// 3
</span></span></span></code></pre></td></tr></table></div></div><p>如果读取一个未知的键，则返回 <code>undefined</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=k>new</span> <span class=nx>Map</span><span class=p>().</span><span class=nx>get</span><span class=p>(</span><span class=s1>&#39;asfddfsasadf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// undefined
</span></span></span></code></pre></td></tr></table></div></div><p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>map</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Map</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>map</span><span class=p>.</span><span class=nx>set</span><span class=p>([</span><span class=s1>&#39;a&#39;</span><span class=p>],</span> <span class=mi>555</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>map</span><span class=p>.</span><span class=nx>get</span><span class=p>([</span><span class=s1>&#39;a&#39;</span><span class=p>])</span> <span class=c1>// undefined
</span></span></span></code></pre></td></tr></table></div></div><p>上面代码的 <code>set</code> 和 <code>get</code> 方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此 <code>get</code> 方法无法读取该键，返回 <code>undefined</code>。</p><p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p><p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如 <code>0</code> 和 <code>-0</code> 就是一个键，布尔值 <code>true</code> 和字符串 <code>true</code> 则是两个不同的键。另外，<code>undefined</code> 和 <code>null</code> 也是两个不同的键。虽然 <code>NaN</code> 不严格相等于自身，但 Map 将其视为同一个键。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>map</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Map</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>map</span><span class=p>.</span><span class=nx>set</span><span class=p>(</span><span class=o>-</span><span class=mi>0</span><span class=p>,</span> <span class=mi>123</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>map</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=o>+</span><span class=mi>0</span><span class=p>)</span> <span class=c1>// 123
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>map</span><span class=p>.</span><span class=nx>set</span><span class=p>(</span><span class=kc>true</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>map</span><span class=p>.</span><span class=nx>set</span><span class=p>(</span><span class=s1>&#39;true&#39;</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>map</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=kc>true</span><span class=p>)</span> <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>map</span><span class=p>.</span><span class=nx>set</span><span class=p>(</span><span class=kc>undefined</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>map</span><span class=p>.</span><span class=nx>set</span><span class=p>(</span><span class=kc>null</span><span class=p>,</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>map</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=kc>undefined</span><span class=p>)</span> <span class=c1>// 3
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>map</span><span class=p>.</span><span class=nx>set</span><span class=p>(</span><span class=kc>NaN</span><span class=p>,</span> <span class=mi>123</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>map</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=kc>NaN</span><span class=p>)</span> <span class=c1>// 123
</span></span></span></code></pre></td></tr></table></div></div><p>Map 的属性及方法</p><p>属性：</p><ul><li><p>constructor：构造函数</p></li><li><p>size：返回字典中所包含的元素个数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>map</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Map</span><span class=p>([</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>,</span> <span class=s1>&#39;An&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=s1>&#39;des&#39;</span><span class=p>,</span> <span class=s1>&#39;JS&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>map</span><span class=p>.</span><span class=nx>size</span> <span class=c1>// 2
</span></span></span></code></pre></td></tr></table></div></div></li></ul><p>操作方法：</p><ul><li>set(key, value)：向字典中添加新元素</li><li>get(key)：通过键查找特定的数值并返回</li><li>has(key)：判断字典中是否存在键 key</li><li>delete(key)：通过键 key 从字典中移除对应的数据</li><li>clear()：将这个字典中的所有元素删除</li></ul><p>遍历方法</p><ul><li>Keys()：将字典中包含的所有键名以迭代器形式返回</li><li>values()：将字典中包含的所有数值以迭代器形式返回</li><li>entries()：返回所有成员的迭代器</li><li>forEach()：遍历字典的所有成员</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>map</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Map</span><span class=p>([</span>
</span></span><span class=line><span class=cl>            <span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>,</span> <span class=s1>&#39;An&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>            <span class=p>[</span><span class=s1>&#39;des&#39;</span><span class=p>,</span> <span class=s1>&#39;JS&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>map</span><span class=p>.</span><span class=nx>entries</span><span class=p>())</span>	<span class=c1>// MapIterator {&#34;name&#34; =&gt; &#34;An&#34;, &#34;des&#34; =&gt; &#34;JS&#34;}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>map</span><span class=p>.</span><span class=nx>keys</span><span class=p>())</span> <span class=c1>// MapIterator {&#34;name&#34;, &#34;des&#34;}
</span></span></span></code></pre></td></tr></table></div></div><p>Map 结构的默认遍历器接口（<code>Symbol.iterator</code> 属性），就是 <code>entries</code> 方法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>map</span><span class=p>[</span><span class=nx>Symbol</span><span class=p>.</span><span class=nx>iterator</span><span class=p>]</span> <span class=o>===</span> <span class=nx>map</span><span class=p>.</span><span class=nx>entries</span>
</span></span><span class=line><span class=cl><span class=c1>// true
</span></span></span></code></pre></td></tr></table></div></div><p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>…</code>）。</p><p>对于 forEach ，看一个例子</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>reporter</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>report</span><span class=o>:</span> <span class=kd>function</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Key: %s, Value: %s&#34;</span><span class=p>,</span> <span class=nx>key</span><span class=p>,</span> <span class=nx>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>map</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Map</span><span class=p>([</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>,</span> <span class=s1>&#39;An&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=s1>&#39;des&#39;</span><span class=p>,</span> <span class=s1>&#39;JS&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nx>map</span><span class=p>.</span><span class=nx>forEach</span><span class=p>(</span><span class=kd>function</span><span class=p>(</span><span class=nx>value</span><span class=p>,</span> <span class=nx>key</span><span class=p>,</span> <span class=nx>map</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=p>.</span><span class=nx>report</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=nx>reporter</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Key: name, Value: An
</span></span></span><span class=line><span class=cl><span class=c1>// Key: des, Value: JS
</span></span></span></code></pre></td></tr></table></div></div><p>在这个例子中， forEach 方法的回调函数的 this，就指向 reporter</p><p><strong>与其他数据结构的相互转换</strong></p><ol><li><p>Map 转 Array</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>map</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Map</span><span class=p>([[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span> <span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>],</span> <span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>3</span><span class=p>]])</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>([...</span><span class=nx>map</span><span class=p>])</span>	<span class=c1>// [[1, 1], [2, 2], [3, 3]]
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>Array 转 Map</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>map</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Map</span><span class=p>([[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span> <span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>],</span> <span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>3</span><span class=p>]])</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>map</span><span class=p>)</span>	<span class=c1>// Map {1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3}
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>Map 转 Object</p><p>因为 Object 的键名都为字符串，而 Map 的键名为对象，所以转换的时候会把非字符串键名转换为字符串键名。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>mapToObj</span><span class=p>(</span><span class=nx>map</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nx>obj</span> <span class=o>=</span> <span class=nb>Object</span><span class=p>.</span><span class=nx>create</span><span class=p>(</span><span class=kc>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=p>[</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span><span class=p>]</span> <span class=k>of</span> <span class=nx>map</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>obj</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span> <span class=o>=</span> <span class=nx>value</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>obj</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>map</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Map</span><span class=p>().</span><span class=nx>set</span><span class=p>(</span><span class=s1>&#39;name&#39;</span><span class=p>,</span> <span class=s1>&#39;An&#39;</span><span class=p>).</span><span class=nx>set</span><span class=p>(</span><span class=s1>&#39;des&#39;</span><span class=p>,</span> <span class=s1>&#39;JS&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>mapToObj</span><span class=p>(</span><span class=nx>map</span><span class=p>)</span>  <span class=c1>// {name: &#34;An&#34;, des: &#34;JS&#34;}
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>Object 转 Map</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>objToMap</span><span class=p>(</span><span class=nx>obj</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nx>map</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Map</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>key</span> <span class=k>of</span> <span class=nb>Object</span><span class=p>.</span><span class=nx>keys</span><span class=p>(</span><span class=nx>obj</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>map</span><span class=p>.</span><span class=nx>set</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>obj</span><span class=p>[</span><span class=nx>key</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>map</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>objToMap</span><span class=p>({</span><span class=s1>&#39;name&#39;</span><span class=o>:</span> <span class=s1>&#39;An&#39;</span><span class=p>,</span> <span class=s1>&#39;des&#39;</span><span class=o>:</span> <span class=s1>&#39;JS&#39;</span><span class=p>})</span> <span class=c1>// Map {&#34;name&#34; =&gt; &#34;An&#34;, &#34;des&#34; =&gt; &#34;JS&#34;}
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>Map 转 JSON</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>mapToJson</span><span class=p>(</span><span class=nx>map</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>JSON</span><span class=p>.</span><span class=nx>stringify</span><span class=p>([...</span><span class=nx>map</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>map</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Map</span><span class=p>().</span><span class=nx>set</span><span class=p>(</span><span class=s1>&#39;name&#39;</span><span class=p>,</span> <span class=s1>&#39;An&#39;</span><span class=p>).</span><span class=nx>set</span><span class=p>(</span><span class=s1>&#39;des&#39;</span><span class=p>,</span> <span class=s1>&#39;JS&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>mapToJson</span><span class=p>(</span><span class=nx>map</span><span class=p>)</span>	<span class=c1>// [[&#34;name&#34;,&#34;An&#34;],[&#34;des&#34;,&#34;JS&#34;]]
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>JSON 转 Map</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>jsonToStrMap</span><span class=p>(</span><span class=nx>jsonStr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>objToMap</span><span class=p>(</span><span class=nx>JSON</span><span class=p>.</span><span class=nx>parse</span><span class=p>(</span><span class=nx>jsonStr</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>jsonToStrMap</span><span class=p>(</span><span class=s1>&#39;{&#34;name&#34;: &#34;An&#34;, &#34;des&#34;: &#34;JS&#34;}&#39;</span><span class=p>)</span> <span class=c1>// Map {&#34;name&#34; =&gt; &#34;An&#34;, &#34;des&#34; =&gt; &#34;JS&#34;}
</span></span></span></code></pre></td></tr></table></div></div></li></ol><a href=#4-weakmap><h4 id=4-weakmap><span class=hanchor arialabel=Anchor># </span>4. WeakMap</h4></a><p>WeakMap 对象是一组键值对的集合，其中的<strong>键是弱引用对象，而值可以是任意</strong>。</p><p><strong>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</strong></p><p>WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的 key 则变成无效的），所以，WeakMap 的 key 是不可枚举的。</p><p>属性：</p><ul><li>constructor：构造函数</li></ul><p>方法：</p><ul><li>has(key)：判断是否有 key 关联对象</li><li>get(key)：返回 key 关联对象（没有则则返回 undefined）</li><li>set(key)：设置一组 key 关联对象</li><li>delete(key)：移除 key 的关联对象</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>myElement</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s1>&#39;logo&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>myWeakmap</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>WeakMap</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>myWeakmap</span><span class=p>.</span><span class=nx>set</span><span class=p>(</span><span class=nx>myElement</span><span class=p>,</span> <span class=p>{</span><span class=nx>timesClicked</span><span class=o>:</span> <span class=mi>0</span><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>myElement</span><span class=p>.</span><span class=nx>addEventListener</span><span class=p>(</span><span class=s1>&#39;click&#39;</span><span class=p>,</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>logoData</span> <span class=o>=</span> <span class=nx>myWeakmap</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=nx>myElement</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>logoData</span><span class=p>.</span><span class=nx>timesClicked</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=kc>false</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><a href=#5-总结><h4 id=5-总结><span class=hanchor arialabel=Anchor># </span>5. 总结</h4></a><ul><li>Set<ul><li>成员唯一、无序且不重复</li><li>[value, value]，键值与键名是一致的（或者说只有键值，没有键名）</li><li>可以遍历，方法有：add、delete、has</li></ul></li><li>WeakSet<ul><li>成员都是对象</li><li>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏</li><li>不能遍历，方法有 add、delete、has</li></ul></li><li>Map<ul><li>本质上是键值对的集合，类似集合</li><li>可以遍历，方法很多可以跟各种数据格式转换</li></ul></li><li>WeakMap<ul><li>只接受对象作为键名（null 除外），不接受其他类型的值作为键名</li><li>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的</li><li>不能遍历，方法有 get、set、has、delete</li></ul></li></ul><a href=#6-扩展object-与-setmap><h4 id=6-扩展object-与-setmap><span class=hanchor arialabel=Anchor># </span>6. 扩展：Object 与 Set、Map</h4></a><ol><li><p>Object 与 Set</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// Object
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>properties1</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;width&#39;</span><span class=o>:</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;height&#39;</span><span class=o>:</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>properties1</span><span class=p>[</span><span class=s1>&#39;width&#39;</span><span class=p>]</span><span class=o>?</span> <span class=kc>true</span><span class=o>:</span> <span class=kc>false</span><span class=p>)</span> <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Set
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>properties2</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>properties2</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=s1>&#39;width&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>properties2</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=s1>&#39;height&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>properties2</span><span class=p>.</span><span class=nx>has</span><span class=p>(</span><span class=s1>&#39;width&#39;</span><span class=p>))</span> <span class=c1>// true
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>Object 与 Map</p></li></ol><p>JS 中的对象（Object），本质上是键值对的集合（hash 结构）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>data</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>element</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>getElementsByClassName</span><span class=p>(</span><span class=s1>&#39;App&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>data</span><span class=p>[</span><span class=nx>element</span><span class=p>]</span> <span class=o>=</span> <span class=s1>&#39;metadata&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>data</span><span class=p>[</span><span class=s1>&#39;[object HTMLCollection]&#39;</span><span class=p>])</span> <span class=c1>// &#34;metadata&#34;
</span></span></span></code></pre></td></tr></table></div></div><p>但当以一个 DOM 节点作为对象 data 的键，对象会被自动转化为字符串 [Object HTMLCollection]，所以说，Object 结构提供了 <strong>字符串 - 值</strong> 对应，Map 则提供了 <strong>值 - 值</strong> 的对应</p><a href=#8-es5es6-的继承除了写法以外还有什么区别><h2 id=8-es5es6-的继承除了写法以外还有什么区别><span class=hanchor arialabel=Anchor># </span>8. ES5/ES6 的继承除了写法以外还有什么区别？</h2></a><p>这个问题比较复杂，暂时还不懂
<a href=https://muyiy.cn/question/js/7.html rel=noopener>url</a></p><p>ES5 和 ES6 子类 <code>this</code> 生成顺序不同。ES5 的继承先生成了子类实例，再调用父类的构造函数修饰子类实例，ES6 的继承先生成父类实例，再调用子类的构造函数修饰父类实例。这个差别使得 ES6 可以继承内置对象。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>MyES5Array</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nb>Array</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=nx>arguments</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// it&#39;s useless
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>arrayES5</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>MyES5Array</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span> <span class=c1>// arrayES5: MyES5Array {}
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kr>class</span> <span class=nx>MyES6Array</span> <span class=kr>extends</span> <span class=nb>Array</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// it&#39;s ok
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>arrayES6</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>MyES6Array</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span> <span class=c1>// arrayES6: MyES6Array(3) []
</span></span></span></code></pre></td></tr></table></div></div><a href=#9-3-个判断数组的方法请分别介绍它们之间的区别和优劣><h2 id=9-3-个判断数组的方法请分别介绍它们之间的区别和优劣><span class=hanchor arialabel=Anchor># </span>9. 3 个判断数组的方法，请分别介绍它们之间的区别和优劣</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nb>Object</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span><span class=p>.</span><span class=nx>call</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>instanceof</span> 
</span></span><span class=line><span class=cl><span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=mf>1.</span> <span class=nb>Object</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span><span class=p>.</span><span class=nx>call</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>每一个继承</span> <span class=nb>Object</span> <span class=nx>的对象都有</span> <span class=nx>toString</span> <span class=nx>方法</span><span class=err>，</span><span class=nx>如果</span> <span class=nx>toString</span> <span class=nx>方法没有重写的话</span><span class=err>，</span><span class=nx>会返回</span> <span class=p>[</span><span class=nb>Object</span> <span class=nx>type</span><span class=p>]</span><span class=err>，</span><span class=nx>其中</span> <span class=nx>type</span> <span class=nx>为对象的类型</span><span class=err>。</span><span class=nx>但当除了</span> <span class=nb>Object</span> <span class=nx>类型的对象外</span><span class=err>，</span><span class=nx>其他类型直接使用</span> <span class=nx>toString</span> <span class=nx>方法时</span><span class=err>，</span><span class=nx>会直接返回都是内容的字符串</span><span class=err>，</span><span class=nx>所以我们需要使用call或者apply方法来改变toString方法的执行上下文</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>an</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;Hello&#39;</span><span class=p>,</span><span class=s1>&#39;An&#39;</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=nx>an</span><span class=p>.</span><span class=nx>toString</span><span class=p>();</span> <span class=c1>// &#34;Hello,An&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Object</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>an</span><span class=p>);</span> <span class=c1>// &#34;[object Array]&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>这种方法对于所有基本的数据类型都能进行判断</span><span class=err>，</span><span class=nx>即使是</span> <span class=kc>null</span> <span class=nx>和</span> <span class=kc>undefined</span> <span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>Object</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=s1>&#39;An&#39;</span><span class=p>)</span> <span class=c1>// &#34;[object String]&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Object</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=c1>// &#34;[object Number]&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Object</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>Symbol</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span> <span class=c1>// &#34;[object Symbol]&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Object</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=kc>null</span><span class=p>)</span> <span class=c1>// &#34;[object Null]&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Object</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=kc>undefined</span><span class=p>)</span> <span class=c1>// &#34;[object Undefined]&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Object</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=kd>function</span><span class=p>(){})</span> <span class=c1>// &#34;[object Function]&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Object</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span><span class=p>.</span><span class=nx>call</span><span class=p>({</span><span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;An&#39;</span><span class=p>})</span> <span class=c1>// &#34;[object Object]&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Object</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span><span class=p>.</span><span class=nx>call</span><span class=p>()</span> <span class=nx>常用于判断浏览器内置对象时</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>更多实现可见</span> <span class=nx>谈谈</span> <span class=nb>Object</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>2.</span> <span class=k>instanceof</span>
</span></span><span class=line><span class=cl><span class=k>instanceof</span>  <span class=nx>的内部机制是通过判断对象的原型链中是不是能找到类型的</span> <span class=nx>prototype</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>使用</span> <span class=nx>instanceof判断一个对象是否为数组</span><span class=err>，</span><span class=k>instanceof</span> <span class=nx>会判断这个对象的原型链上是否会找到对应的</span> <span class=nb>Array</span> <span class=nx>的原型</span><span class=err>，</span><span class=nx>找到返回</span> <span class=kc>true</span><span class=err>，</span><span class=nx>否则返回</span> <span class=kc>false</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[]</span>  <span class=k>instanceof</span> <span class=nb>Array</span><span class=p>;</span> <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>但</span> <span class=k>instanceof</span> <span class=nx>只能用来判断对象类型</span><span class=err>，</span><span class=nx>原始类型不可以</span><span class=err>。</span><span class=nx>并且所有对象类型</span> <span class=k>instanceof</span> <span class=nb>Object</span> <span class=nx>都是</span> <span class=kc>true</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[]</span>  <span class=k>instanceof</span> <span class=nb>Object</span><span class=p>;</span> <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=mf>3.</span> <span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>功能</span><span class=err>：</span><span class=nx>用来判断对象是否为数组</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>instanceof</span> <span class=nx>与</span> <span class=nx>isArray</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>当检测Array实例时</span><span class=err>，</span><span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span> <span class=nx>优于</span> <span class=k>instanceof</span> <span class=err>，</span><span class=nx>因为</span> <span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span> <span class=nx>可以检测出</span> <span class=nx>iframes</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>iframe</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>createElement</span><span class=p>(</span><span class=s1>&#39;iframe&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nb>document</span><span class=p>.</span><span class=nx>body</span><span class=p>.</span><span class=nx>appendChild</span><span class=p>(</span><span class=nx>iframe</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>xArray</span> <span class=o>=</span> <span class=nb>window</span><span class=p>.</span><span class=nx>frames</span><span class=p>[</span><span class=nb>window</span><span class=p>.</span><span class=nx>frames</span><span class=p>.</span><span class=nx>length</span><span class=o>-</span><span class=mi>1</span><span class=p>].</span><span class=nb>Array</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>arr</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>xArray</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>);</span> <span class=c1>// [1,2,3]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Correctly checking for Array
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span><span class=p>(</span><span class=nx>arr</span><span class=p>);</span>  <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Object</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>arr</span><span class=p>);</span> <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1>// Considered harmful, because doesn&#39;t work though iframes
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>arr</span> <span class=k>instanceof</span> <span class=nb>Array</span><span class=p>;</span> <span class=c1>// false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span><span class=p>()</span> <span class=nx>与</span> <span class=nb>Object</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span><span class=p>.</span><span class=nx>call</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span><span class=p>()</span><span class=nx>是ES5新增的方法</span><span class=err>，</span><span class=nx>当不存在</span> <span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span><span class=p>()</span> <span class=err>，</span><span class=nx>可以用</span> <span class=nb>Object</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span><span class=p>.</span><span class=nx>call</span><span class=p>()</span> <span class=nx>实现</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span> <span class=o>=</span> <span class=kd>function</span><span class=p>(</span><span class=nx>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>Object</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>arg</span><span class=p>)</span> <span class=o>===</span> <span class=s1>&#39;[object Array]&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>instanceof 是判断类型的 prototype 是否出现在对象的原型链中，但是对象的原型可以随意修改，所以这种判断并不准确。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>obj</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=nx>obj</span><span class=p>.</span><span class=nx>__proto__</span> <span class=o>=</span> <span class=nb>Array</span><span class=p>.</span><span class=nx>prototype</span>
</span></span><span class=line><span class=cl><span class=c1>// Object.setPrototypeOf(obj, Array.prototype)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>obj</span> <span class=k>instanceof</span> <span class=nb>Array</span> <span class=c1>// true
</span></span></span></code></pre></td></tr></table></div></div><a href=#10介绍模块化发展历程><h2 id=10介绍模块化发展历程><span class=hanchor arialabel=Anchor># </span>10.介绍模块化发展历程</h2></a><p>可从 IIFE、AMD、CMD、CommonJS、UMD、webpack(require.ensure)、ES Module、`` 这几个角度考虑。</p><p><a href=https://www.processon.com/view/link/5c8409bbe4b02b2ce492286a#map rel=noopener>https://www.processon.com/view/link/5c8409bbe4b02b2ce492286a#map</a></p><p>模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。</p><p><strong>IIFE</strong>： 使用自执行函数来编写模块化，特点：<strong>在一个单独的函数作用域中执行代码，避免变量冲突</strong>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=p>(</span><span class=kd>function</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>data</span><span class=o>:</span><span class=p>[]</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>})()</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>AMD</strong>： 使用 requireJS 来编写模块化，特点：<strong>依赖必须提前声明好</strong>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>define</span><span class=p>(</span><span class=s1>&#39;./index.js&#39;</span><span class=p>,</span><span class=kd>function</span><span class=p>(</span><span class=nx>code</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=c1>// code 就是index.js 返回的内容
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>})</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>CMD</strong>： 使用 seaJS 来编写模块化，特点：<strong>支持动态引入依赖文件</strong>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>define</span><span class=p>(</span><span class=kd>function</span><span class=p>(</span><span class=nx>require</span><span class=p>,</span> <span class=nx>exports</span><span class=p>,</span> <span class=nx>module</span><span class=p>)</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>indexCode</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;./index.js&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>CommonJS</strong>： nodejs 中自带的模块化。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>fs</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;fs&#39;</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>UMD</strong>：兼容 AMD，CommonJS 模块化语法。</p><p><strong>webpack(require.ensure)</strong>：webpack 2.x 版本中的代码分割。</p><p><strong>ES Modules</strong>： ES6 引入的模块化，支持 import 来引入另一个 js 。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>import</span> <span class=nx>a</span> <span class=nx>from</span> <span class=s1>&#39;a&#39;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><a href=#11全局作用域中用-const-和-let-声明的变量不在-window-上那到底在哪里如何去获取><h2 id=11全局作用域中用-const-和-let-声明的变量不在-window-上那到底在哪里如何去获取><span class=hanchor arialabel=Anchor># </span>11.全局作用域中，用 Const 和 Let 声明的变量不在 Window 上，那到底在哪里？如何去获取？</h2></a><p><a href=https://blog.csdn.net/fang_ze_zhang/article/details/83419022 rel=noopener>关于let声明的变量在window里无法获取到的问题</a></p><p>主要还是得好好学学 js 作用域那一块，同时 es5、es6 区别语法等各种坑特别多得注意</p><hr><p>在 ES5 中，顶层对象的属性和全局变量是等价的，var 命令和 function 命令声明的全局变量，自然也是顶层对象。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=o>=</span> <span class=mi>12</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>f</span><span class=p>(){};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nb>window</span><span class=p>.</span><span class=nx>a</span><span class=p>);</span> <span class=c1>// 12
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nb>window</span><span class=p>.</span><span class=nx>f</span><span class=p>);</span> <span class=c1>// f(){}
</span></span></span></code></pre></td></tr></table></div></div><p>但 ES6 规定，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，但 let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>aa</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>bb</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nb>window</span><span class=p>.</span><span class=nx>aa</span><span class=p>);</span> <span class=c1>// undefined
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nb>window</span><span class=p>.</span><span class=nx>bb</span><span class=p>);</span> <span class=c1>// undefined
</span></span></span></code></pre></td></tr></table></div></div><p>在哪里？怎么获取？通过在设置断点，看看浏览器是怎么处理的：</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/blogs/%e9%9d%a2%e8%af%95/JavaScript/20210405162006.png width=auto alt=letandconst></p><p>通过上图也可以看到，在全局作用域中，用 let 和 const 声明的全局变量并没有在全局对象中，只是一个块级作用域（Script）中</p><p>怎么获取？在定义变量的块级作用域中就能获取啊，既然不属于顶层对象，那就不加 window（global）呗。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>aa</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>bb</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>aa</span><span class=p>);</span> <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>bb</span><span class=p>);</span> <span class=c1>// 2
</span></span></span></code></pre></td></tr></table></div></div><a href=#12使用-sort-对数组-3-15-8-29-102-22-进行排序输出结果><h2 id=12使用-sort-对数组-3-15-8-29-102-22-进行排序输出结果><span class=hanchor arialabel=Anchor># </span>12.使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果</h2></a><p><code>sort</code> 函数，可以接收一个函数，返回值是比较两个数的相对顺序的值</p><ol><li>默认没有函数 是按照 <code>UTF-16</code> 排序的，对于字母数字 你可以利用 <code>ASCII</code> 进行记忆</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl> <span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>15</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>29</span><span class=p>,</span> <span class=mi>102</span><span class=p>,</span> <span class=mi>22</span><span class=p>].</span><span class=nx>sort</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// [102, 15, 22, 29, 3, 8]
</span></span></span></code></pre></td></tr></table></div></div><ol><li>带函数的比较</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl> <span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>15</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>29</span><span class=p>,</span> <span class=mi>102</span><span class=p>,</span> <span class=mi>22</span><span class=p>].</span><span class=nx>sort</span><span class=p>((</span><span class=nx>a</span><span class=p>,</span><span class=nx>b</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span><span class=k>return</span> <span class=nx>a</span> <span class=o>-</span> <span class=nx>b</span><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>返回值大于 0 即 a-b > 0 ， a 和 b 交换位置</li><li>返回值大于 0 即 a-b &lt; 0 ， a 和 b 位置不变</li><li>返回值等于 0 即 a-b = 0 ， a 和 b 位置不变</li></ul><blockquote><p>对于函数体返回 <code>b-a</code> 可以类比上面的返回值进行交换位置</p></blockquote><a href=#13-js-javascript-demo-functioncall-javascript-demo-functionapply><h2 id=13-js-javascript-demo-functioncall-javascript-demo-functionapply><span class=hanchor arialabel=Anchor># </span>13. JS **JavaScript Demo: Function.call() **JavaScript Demo: Function.apply()</h2></a><p><code>call()</code> 方法接受的是<strong>一个参数列表</strong>，而 <code>apply()</code> 方法接受的是<strong>一个包含多个参数的数组</strong>。</p><a href=#14输出以下代码的执行结果并解释为什么><h2 id=14输出以下代码的执行结果并解释为什么><span class=hanchor arialabel=Anchor># </span>14.输出以下代码的执行结果并解释为什么</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=o>=</span> <span class=p>{</span><span class=nx>n</span><span class=o>:</span> <span class=mi>1</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>b</span> <span class=o>=</span> <span class=nx>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>.</span><span class=nx>x</span> <span class=o>=</span> <span class=nx>a</span> <span class=o>=</span> <span class=p>{</span><span class=nx>n</span><span class=o>:</span> <span class=mi>2</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>a</span><span class=p>.</span><span class=nx>x</span><span class=p>)</span> 	
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>b</span><span class=p>.</span><span class=nx>x</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>结果: undefined {n:2}</p><p>首先，a 和 b 同时引用了{n:2}对象，接着执行到 a.x = a = {n：2}语句，尽管赋值是从右到左的没错，但是.的优先级比=要高，所以这里首先执行 a.x，相当于为 a（或者 b）所指向的{n:1}对象新增了一个属性 x，即此时对象将变为{n:1;x:undefined}。之后按正常情况，从右到左进行赋值，此时执行 a ={n:2}的时候，a 的引用改变，指向了新对象{n：2},而 b 依然指向的是旧对象。之后执行 a.x = {n：2}的时候，并不会重新解析一遍 a，而是沿用最初解析 a.x 时候的 a，也即旧对象，故此时旧对象的 x 的值为{n：2}，旧对象为 {n:1;x:{n：2}}，它被 b 引用着。 后面输出 a.x 的时候，又要解析 a 了，此时的 a 是指向新对象的 a，而这个新对象是没有 x 属性的，故访问时输出 undefined；而访问 b.x 的时候，将输出旧对象的 x 的值，即{n:2}。</p><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/blogs/%e9%9d%a2%e8%af%95/JavaScript/20210405162007.png width=auto alt=image></p><a href=#15-数组里-10-万个数据取第一个元素和第-99999-个元素时间相差多少><h2 id=15-数组里-10-万个数据取第一个元素和第-99999-个元素时间相差多少><span class=hanchor arialabel=Anchor># </span>15. 数组里 10 万个数据，取第一个元素和第 99999 个元素时间相差多少</h2></a><p>js 中数组元素的存储方式并不是连续的，而是哈希映射关系。哈希映射关系，可以通过键名 key，直接计算出值存储的位置，所以查找起来很快。推荐一下这篇文章：
<a href=https://juejin.im/entry/59ae664d518825244d207196 rel=noopener>深究 JavaScript 数组</a></p><a href=#16输出以下代码运行结果><h2 id=16输出以下代码运行结果><span class=hanchor arialabel=Anchor># </span>16.输出以下代码运行结果</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// example 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>a</span><span class=o>=</span><span class=p>{},</span> <span class=nx>b</span><span class=o>=</span><span class=s1>&#39;123&#39;</span><span class=p>,</span> <span class=nx>c</span><span class=o>=</span><span class=mi>123</span><span class=p>;</span>  
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>[</span><span class=nx>b</span><span class=p>]</span><span class=o>=</span><span class=s1>&#39;b&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>[</span><span class=nx>c</span><span class=p>]</span><span class=o>=</span><span class=s1>&#39;c&#39;</span><span class=p>;</span>  
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>a</span><span class=p>[</span><span class=nx>b</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>---------------------</span>
</span></span><span class=line><span class=cl><span class=c1>// example 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>a</span><span class=o>=</span><span class=p>{},</span> <span class=nx>b</span><span class=o>=</span><span class=nx>Symbol</span><span class=p>(</span><span class=s1>&#39;123&#39;</span><span class=p>),</span> <span class=nx>c</span><span class=o>=</span><span class=nx>Symbol</span><span class=p>(</span><span class=s1>&#39;123&#39;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>[</span><span class=nx>b</span><span class=p>]</span><span class=o>=</span><span class=s1>&#39;b&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>[</span><span class=nx>c</span><span class=p>]</span><span class=o>=</span><span class=s1>&#39;c&#39;</span><span class=p>;</span>  
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>a</span><span class=p>[</span><span class=nx>b</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>---------------------</span>
</span></span><span class=line><span class=cl><span class=c1>// example 3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>a</span><span class=o>=</span><span class=p>{},</span> <span class=nx>b</span><span class=o>=</span><span class=p>{</span><span class=nx>key</span><span class=o>:</span><span class=s1>&#39;123&#39;</span><span class=p>},</span> <span class=nx>c</span><span class=o>=</span><span class=p>{</span><span class=nx>key</span><span class=o>:</span><span class=s1>&#39;456&#39;</span><span class=p>};</span>  
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>[</span><span class=nx>b</span><span class=p>]</span><span class=o>=</span><span class=s1>&#39;b&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>[</span><span class=nx>c</span><span class=p>]</span><span class=o>=</span><span class=s1>&#39;c&#39;</span><span class=p>;</span>  
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>a</span><span class=p>[</span><span class=nx>b</span><span class=p>]);</span>
</span></span></code></pre></td></tr></table></div></div><p>这题考察的是对象的键名的转换。</p><ul><li>对象的键名只能是字符串和 Symbol 类型。</li><li>其他类型的键名会被转换成字符串类型。</li><li>对象转字符串默认会调用 toString 方法。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// example 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>a</span><span class=o>=</span><span class=p>{},</span> <span class=nx>b</span><span class=o>=</span><span class=s1>&#39;123&#39;</span><span class=p>,</span> <span class=nx>c</span><span class=o>=</span><span class=mi>123</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>[</span><span class=nx>b</span><span class=p>]</span><span class=o>=</span><span class=s1>&#39;b&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// c 的键名会被转换成字符串&#39;123&#39;，这里会把 b 覆盖掉。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span><span class=p>[</span><span class=nx>c</span><span class=p>]</span><span class=o>=</span><span class=s1>&#39;c&#39;</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输出 c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>a</span><span class=p>[</span><span class=nx>b</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=c1>// example 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>a</span><span class=o>=</span><span class=p>{},</span> <span class=nx>b</span><span class=o>=</span><span class=nx>Symbol</span><span class=p>(</span><span class=s1>&#39;123&#39;</span><span class=p>),</span> <span class=nx>c</span><span class=o>=</span><span class=nx>Symbol</span><span class=p>(</span><span class=s1>&#39;123&#39;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// b 是 Symbol 类型，不需要转换。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span><span class=p>[</span><span class=nx>b</span><span class=p>]</span><span class=o>=</span><span class=s1>&#39;b&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// c 是 Symbol 类型，不需要转换。任何一个 Symbol 类型的值都是不相等的，所以不会覆盖掉 b。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span><span class=p>[</span><span class=nx>c</span><span class=p>]</span><span class=o>=</span><span class=s1>&#39;c&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输出 b
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>a</span><span class=p>[</span><span class=nx>b</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=c1>// example 3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>a</span><span class=o>=</span><span class=p>{},</span> <span class=nx>b</span><span class=o>=</span><span class=p>{</span><span class=nx>key</span><span class=o>:</span><span class=s1>&#39;123&#39;</span><span class=p>},</span> <span class=nx>c</span><span class=o>=</span><span class=p>{</span><span class=nx>key</span><span class=o>:</span><span class=s1>&#39;456&#39;</span><span class=p>};</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// b 不是字符串也不是 Symbol 类型，需要转换成字符串。
</span></span></span><span class=line><span class=cl><span class=c1>// 对象类型会调用 toString 方法转换成字符串 [object Object]。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span><span class=p>[</span><span class=nx>b</span><span class=p>]</span><span class=o>=</span><span class=s1>&#39;b&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// c 不是字符串也不是 Symbol 类型，需要转换成字符串。
</span></span></span><span class=line><span class=cl><span class=c1>// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span><span class=p>[</span><span class=nx>c</span><span class=p>]</span><span class=o>=</span><span class=s1>&#39;c&#39;</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输出 c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>a</span><span class=p>[</span><span class=nx>b</span><span class=p>]);</span>
</span></span></code></pre></td></tr></table></div></div><p>前面说的很清楚了，除了 Symbol，如果想要不被覆盖 可以使用 ES6 提供的 Map</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span><span class=o>=</span><span class=k>new</span> <span class=nx>Map</span><span class=p>(),</span> <span class=nx>b</span><span class=o>=</span><span class=s1>&#39;123&#39;</span><span class=p>,</span> <span class=nx>c</span><span class=o>=</span><span class=mi>123</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>.</span><span class=nx>set</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span><span class=s1>&#39;b&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>.</span><span class=nx>set</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span><span class=s1>&#39;c&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=nx>b</span><span class=p>);</span>  <span class=c1>// &#39;b&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=nx>c</span><span class=p>);</span>  <span class=c1>// &#39;c&#39;
</span></span></span></code></pre></td></tr></table></div></div><a href=#17varlet-和-const-区别的实现原理是什么><h2 id=17varlet-和-const-区别的实现原理是什么><span class=hanchor arialabel=Anchor># </span>17.var、let 和 Const 区别的实现原理是什么</h2></a><ul><li>var：遇到有 var 的作用域，<strong>在任何语句执行前都已经完成了声明和初始化</strong>，也就是变量提升而且拿到 undefined 的原因由来</li><li>function： 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高</li><li>let：解析器进入一个块级作用域，发现 let 关键字，变量只是先完成<strong>声明</strong>，并没有到<strong>初始化</strong>那一步。此时如果在此作用域提前访问，则报错 xx is not defined，这就是暂时性死区的由来。等到解析到有 let 那一行的时候，才会进入<strong>初始化</strong>阶段。如果 let 的那一行是赋值操作，则初始化和赋值同时进行</li><li>const、class 都是同 let 一样的道理</li></ul><p>比如解析如下代码步骤：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=c1>// 没用的第一行
</span></span></span><span class=line><span class=cl><span class=c1>// 没用的第二行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span> <span class=c1>// 如果此时访问a报错 a is not defined
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span> <span class=nx>a</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>步骤：</p><ol><li>发现作用域有 let a，先注册个 a，仅仅注册</li><li>没用的第一行</li><li>没用的第二行</li><li>a is not defined，暂时性死区的表现</li><li>假设前面那行不报错，a 初始化为 undefined</li><li>a 赋值为 1</li></ol><p>对比于 var，let、const 只是解耦了声明和初始化的过程，var 是在任何语句执行前都已经完成了声明和初始化，let、const 仅仅是在任何语句执行前只完成了声明</p><a href=#18asyncawait-如何通过同步的方式实现异步><h2 id=18asyncawait-如何通过同步的方式实现异步><span class=hanchor arialabel=Anchor># </span>18.Async/Await 如何通过同步的方式实现异步</h2></a><p>看了第一个回答，讲的挺深入底层的，但我现在还不太看得懂，先占个坑。</p><p><a href=https://muyiy.cn/question/async/9.html rel=noopener>网址</a></p><a href=#19输出运行结果><h2 id=19输出运行结果><span class=hanchor arialabel=Anchor># </span>19.输出运行结果</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nx>Foo</span><span class=p>.</span><span class=nx>a</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>this</span><span class=p>.</span><span class=nx>a</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>Foo</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>a</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>Foo</span><span class=p>.</span><span class=nx>a</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>Foo</span><span class=p>.</span><span class=nx>a</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>obj</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>obj</span><span class=p>.</span><span class=nx>a</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>Foo</span><span class=p>.</span><span class=nx>a</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><p>结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Foo</span><span class=p>.</span><span class=nx>a</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>a</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 以上只是 Foo 的构建方法，没有产生实例，此刻也没有执行
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>Foo</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>a</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 现在在 Foo 上挂载了原型方法 a ，方法输出值为 3
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>Foo</span><span class=p>.</span><span class=nx>a</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 现在在 Foo 上挂载了直接方法 a ，输出值为 4
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>Foo</span><span class=p>.</span><span class=nx>a</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>// 立刻执行了 Foo 上的 a 方法，也就是刚刚定义的，所以
</span></span></span><span class=line><span class=cl><span class=c1>// # 输出 4
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>obj</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=cm>/* 这里调用了 Foo 的构建方法。Foo 的构建方法主要做了两件事：
</span></span></span><span class=line><span class=cl><span class=cm>1. 将全局的 Foo 上的直接方法 a 替换为一个输出 1 的方法。
</span></span></span><span class=line><span class=cl><span class=cm>2. 在新对象上挂载直接方法 a ，输出值为 2。
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>obj</span><span class=p>.</span><span class=nx>a</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>// 因为有直接方法 a ，不需要去访问原型链，所以使用的是构建方法里所定义的 this.a，
</span></span></span><span class=line><span class=cl><span class=c1>// # 输出 2
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>Foo</span><span class=p>.</span><span class=nx>a</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>// 构建方法里已经替换了全局 Foo 上的 a 方法，所以
</span></span></span><span class=line><span class=cl><span class=c1>// # 输出 1
</span></span></span></code></pre></td></tr></table></div></div><p>同理</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>getName</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span> <span class=nx>alert</span> <span class=p>(</span><span class=mi>1</span><span class=p>);</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>Foo</span><span class=p>.</span><span class=nx>getName</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span> <span class=nx>alert</span> <span class=p>(</span><span class=mi>2</span><span class=p>);};</span>
</span></span><span class=line><span class=cl><span class=nx>Foo</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>getName</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span> <span class=nx>alert</span> <span class=p>(</span><span class=mi>3</span><span class=p>);};</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>getName</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span> <span class=nx>alert</span> <span class=p>(</span><span class=mi>4</span><span class=p>);};</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>getName</span><span class=p>()</span> <span class=p>{</span> <span class=nx>alert</span> <span class=p>(</span><span class=mi>5</span><span class=p>);}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1>//请写出以下输出结果：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>Foo</span><span class=p>.</span><span class=nx>getName</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>getName</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>Foo</span><span class=p>().</span><span class=nx>getName</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>getName</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>new</span> <span class=nx>Foo</span><span class=p>.</span><span class=nx>getName</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>new</span> <span class=nx>Foo</span><span class=p>().</span><span class=nx>getName</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>new</span> <span class=k>new</span> <span class=nx>Foo</span><span class=p>().</span><span class=nx>getName</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><p>先看此题的上半部分做了什么，首先定义了一个叫 Foo 的函数，之后为 Foo 创建了一个叫 getName 的静态属性存储了一个匿名函数，之后为 Foo 的原型对象新创建了一个叫 getName 的匿名函数。之后又通过函数变量表达式创建了一个 getName 的函数，最后再声明一个叫 getName 函数。</p><p>第一问的 Foo.getName 自然是访问 Foo 函数上存储的静态属性，答案自然是 2，这里就不需要解释太多的，一般来说第一问对于稍微懂 JS 基础的同学来说应该是没问题的,当然我们可以用下面的代码来回顾一下基础，先加深一下了解</p><ol><li><p>Foo.getName();</p><p>自然是访问 Foo 函数上存储的静态属性，答案自然是 2，这里就不需要解释太多的，一般来说第一问对于稍微懂 JS 基础的同学来说应该是没问题的,当然我们可以用下面的代码来回顾一下基础，先加深一下了解</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>User</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>name</span> <span class=o>=</span> <span class=nx>name</span><span class=p>;</span> <span class=c1>//私有属性
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=nx>name</span><span class=p>;</span> <span class=c1>//公有属性
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kd>function</span> <span class=nx>getName</span><span class=p>()</span> <span class=p>{</span> <span class=c1>//私有方法
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>User</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>getName</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span> <span class=c1>//公有方法
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>User</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=s1>&#39;Wscats&#39;</span><span class=p>;</span> <span class=c1>//静态属性
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>User</span><span class=p>.</span><span class=nx>getName</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span> <span class=c1>//静态方法
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>Wscat</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>User</span><span class=p>(</span><span class=s1>&#39;Wscats&#39;</span><span class=p>);</span> <span class=c1>//实例化
</span></span></span></code></pre></td></tr></table></div></div><p>注意下面这几点：</p><ul><li>调用公有方法，公有属性，我们必需先实例化对象，也就是用 new 操作符实化对象，就可构造函数实例化对象的方法和属性，并且公有方法是不能调用私有方法和静态方法的</li><li>静态方法和静态属性就是我们无需实例化就可以调用</li><li>而对象的私有方法和属性,外部是不可以访问的</li></ul></li><li><p>getName();</p><p>既然是直接调用那么就是访问当前上文作用域内的叫 getName 的函数，所以这里应该直接把关注点放在 4 和 5 上，跟 1 2 3 都没什么关系。当然后来我问了我的几个同事他们大多数回答了 5。此处其实有两个坑，一是变量声明提升，二是函数表达式和函数声明的区别。</p><p>我们来看看为什么，可参考 (1) 关于 Javascript 的函数声明和函数表达式 (2) 关于 JavaScript 的变量提升</p><p>在 Javascript 中，定义函数有两种类型</p><p>函数声明</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 函数声明
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>wscat</span><span class=p>(</span><span class=nx>type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>type</span> <span class=o>===</span> <span class=s2>&#34;wscat&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>函数表达式</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 函数表达式
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>oaoafly</span> <span class=o>=</span> <span class=kd>function</span><span class=p>(</span><span class=nx>type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>type</span> <span class=o>===</span> <span class=s2>&#34;oaoafly&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>先看下面这个经典问题，在一个程序里面同时用函数声明和函数表达式定义一个名为 getName 的函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>getName</span><span class=p>()</span> <span class=c1>//oaoafly
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>getName</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;wscat&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>getName</span><span class=p>()</span> <span class=c1>//wscat
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>getName</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;oaoafly&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>getName</span><span class=p>()</span> <span class=c1>//wscat
</span></span></span></code></pre></td></tr></table></div></div><p>上面的代码看起来很类似，感觉也没什么太大差别。但实际上，Javascript 函数上的一个“陷阱”就体现在 Javascript 两种类型的函数定义上。</p><ul><li>JavaScript 解释器中存在一种变量声明被提升的机制，也就是说函数声明会被提升到作用域的最前面，即使写代码的时候是写在最后面，也还是会被提升至最前面。</li><li>而用函数表达式创建的函数是在运行时进行赋值，且要等到表达式赋值完成后才能调用</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>getName</span> <span class=c1>//变量被提升，此时为undefined
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>getName</span><span class=p>()</span> <span class=c1>//oaoafly 函数被提升 这里受函数声明的影响，虽然函数声明在最后可以被提升到最前面了
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>getName</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;wscat&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=c1>//函数表达式此时才开始覆盖函数声明的定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>getName</span><span class=p>()</span> <span class=c1>//wscat
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>getName</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;oaoafly&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>getName</span><span class=p>()</span> <span class=c1>//wscat 这里就执行了函数表达式的值
</span></span></span></code></pre></td></tr></table></div></div><p>所以可以分解为这两个简单的问题来看清楚区别的本质</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>getName</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>getName</span><span class=p>)</span> <span class=c1>//undefined
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>getName</span><span class=p>()</span> <span class=c1>//Uncaught TypeError: getName is not a function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>getName</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;wscat&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>getName</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>getName</span><span class=p>)</span> <span class=c1>//function getName() {console.log(&#39;oaoafly&#39;)}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>getName</span><span class=p>()</span> <span class=c1>//oaoafly
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>getName</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;oaoafly&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这个区别看似微不足道，但在某些情况下确实是一个难以察觉并且“致命“的陷阱。出现这个陷阱的本质原因体现在这两种类型在函数提升和运行时机（解析时/运行时）上的差异。</p><p>当然我们给一个总结：Javascript 中函数声明和函数表达式是存在区别的，函数声明在 JS 解析时进行函数提升，因此在同一个作用域内，不管函数声明在哪里定义，该函数都可以进行调用。而函数表达式的值是在 JS 运行时确定，并且在表达式赋值完成后，该函数才能调用。</p><p>所以第二问的答案就是 4，5 的函数声明被 4 的函数表达式覆盖了</p></li><li><p>Foo().getName();</p><p>先执行了 Foo 函数，然后调用 Foo 函数的返回值对象的 getName 属性函数。</p><p>Foo 函数的第一句 <code>getName = function () { alert (1); };</code> 是一句函数赋值语句，注意它没有 var 声明，所以先向当前 Foo 函数作用域内寻找 getName 变量，没有。再向当前函数作用域上层，即外层作用域内寻找是否含有 getName 变量，找到了，也就是第二问中的 alert(4) 函数，将此变量的值赋值为 <code>function(){alert(1)}</code>。</p><p>此处实际上是将外层作用域内的 getName 函数修改了。</p><blockquote><p>注意：此处若依然没有找到会一直向上查找到 window 对象，若 window 对象中也没有 getName 属性，就在 window 对象中创建一个 getName 变量。</p></blockquote><p>之后 Foo 函数的返回值是 this，而 JS 的 this 问题已经有非常多的文章介绍，这里不再多说。</p><p>简单的讲，this 的指向是由所在函数的调用方式决定的。而此处的直接调用方式，this 指向 window 对象。</p><p>遂 Foo 函数返回的是 window 对象，相当于执行 <code>window.getName()</code>，而 window 中的 getName 已经被修改为 alert(1)，所以最终会输出 1<br>此处考察了两个知识点，一个是变量作用域问题，一个是 this 指向问题<br>我们可以利用下面代码来回顾下这两个知识点:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>name</span> <span class=o>=</span> <span class=s2>&#34;Wscats&#34;</span><span class=p>;</span> <span class=c1>//全局变量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>window</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=s2>&#34;Wscats&#34;</span><span class=p>;</span> <span class=c1>//全局变量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>getName</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>name</span> <span class=o>=</span> <span class=s2>&#34;Oaoafly&#34;</span><span class=p>;</span> <span class=c1>//去掉var变成了全局变量
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kd>var</span> <span class=nx>privateName</span> <span class=o>=</span> <span class=s2>&#34;Stacsw&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>);</span> <span class=c1>//window
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=nx>privateName</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>getPrivate</span> <span class=o>=</span> <span class=nx>getName</span><span class=p>(</span><span class=s2>&#34;Hello&#34;</span><span class=p>);</span> <span class=c1>//当然传参是局部变量，但函数里面我没有接受这个参数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span> <span class=c1>//Oaoafly
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>getPrivate</span><span class=p>())</span> <span class=c1>//Stacsw
</span></span></span></code></pre></td></tr></table></div></div><p>因为 JS 没有块级作用域，但是函数是能产生一个作用域的，函数内部不同定义值的方法会直接或者间接影响到全局或者局部变量，函数内部的私有变量可以用闭包获取，函数还真的是第一公民呀~</p><p>而关于 this，this 的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定 this 到底指向谁，实际上 this 的最终指向的是那个调用它的对象</p><p>所以第三问中实际上就是 window 在调用**Foo()**函数，所以 this 的指向是 window</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nb>window</span><span class=p>.</span><span class=nx>Foo</span><span class=p>().</span><span class=nx>getName</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>//-&gt;window.getName();
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>getName();</p><p>直接调用 getName 函数，相当于 <code>window.getName()</code>，因为这个变量已经被 Foo 函数执行时修改了，遂结果与第三问相同，为 1，也就是说 Foo 执行后把全局的 getName 函数给重写了一次，所以结果就是 Foo() 执行重写的那个 getName 函数</p></li><li><p>new Foo.getName()</p><p>下面是 JS 运算符的优先级表格，从高到低排列。可参考 MDN 运算符优先级</p><table><thead><tr><th>优先级</th><th>运算类型</th><th>关联性</th><th>运算符</th></tr></thead><tbody><tr><td>19</td><td>圆括号</td><td>n/a</td><td>( … )</td></tr><tr><td>18</td><td>成员访问</td><td>从左到右</td><td>… . …</td></tr><tr><td></td><td>需计算的成员访问</td><td>从左到右</td><td>… [ … ]</td></tr><tr><td></td><td>new (带参数列表)</td><td>n/a new</td><td>… ( … )</td></tr><tr><td>17</td><td>函数调用</td><td>从左到右</td><td>… ( … )</td></tr><tr><td></td><td>new (无参数列表)</td><td>从右到左</td><td>new …</td></tr><tr><td>16</td><td>后置递增 (运算符在后)</td><td>n/a</td><td>… ++</td></tr><tr><td></td><td>后置递减 (运算符在后)</td><td>n/a</td><td>… &ndash;</td></tr><tr><td>15</td><td>逻辑非</td><td>从右到左</td><td>! …</td></tr><tr><td></td><td>按位非</td><td>从右到左</td><td>~ …</td></tr><tr><td></td><td>一元加法</td><td>从右到左</td><td>+ …</td></tr><tr><td></td><td>一元减法</td><td>从右到左</td><td>- …</td></tr><tr><td></td><td>前置递增</td><td>从右到左</td><td>++ …</td></tr><tr><td></td><td>前置递减</td><td>从右到左</td><td>&ndash; …</td></tr><tr><td></td><td>typeof</td><td>从右到左</td><td>typeof …</td></tr><tr><td></td><td>void</td><td>从右到左</td><td>void …</td></tr><tr><td></td><td>delete</td><td>从右到左</td><td>delete …</td></tr><tr><td>14</td><td>乘法</td><td>从左到右</td><td>… * …</td></tr><tr><td></td><td>除法</td><td>从左到右</td><td>… / …</td></tr><tr><td></td><td>取模</td><td>从左到右</td><td>… % …</td></tr><tr><td>13</td><td>加法</td><td>从左到右</td><td>… + …</td></tr><tr><td></td><td>减法</td><td>从左到右</td><td>… - …</td></tr><tr><td>12</td><td>按位左移</td><td>从左到右</td><td>… &#171; …</td></tr><tr><td></td><td>按位右移</td><td>从左到右</td><td>… &#187; …</td></tr><tr><td></td><td>无符号右移</td><td>从左到右</td><td>… &#187;> …</td></tr><tr><td>11</td><td>小于</td><td>从左到右</td><td>… &lt; …</td></tr><tr><td></td><td>小于等于</td><td>从左到右</td><td>… &lt;= …</td></tr><tr><td></td><td>大于</td><td>从左到右</td><td>… > …</td></tr><tr><td></td><td>大于等于</td><td>从左到右</td><td>… >= …</td></tr><tr><td></td><td>in</td><td>从左到右</td><td>… in …</td></tr><tr><td></td><td>instanceof</td><td>从左到右</td><td>… instanceof …</td></tr><tr><td>10</td><td>等号</td><td>从左到右</td><td>… == …</td></tr><tr><td></td><td>非等号</td><td>从左到右</td><td>… != …</td></tr><tr><td></td><td>全等号</td><td>从左到右</td><td>… === …</td></tr><tr><td></td><td>非全等号</td><td>从左到右</td><td>… !== …</td></tr><tr><td>9</td><td>按位与</td><td>从左到右</td><td>… & …</td></tr><tr><td>8</td><td>按位异或</td><td>从左到右</td><td>… ^ …</td></tr><tr><td>7</td><td>按位或</td><td>从左到右</td><td>… 按位或 …</td></tr><tr><td>6</td><td>逻辑与</td><td>从左到右</td><td>… && …</td></tr><tr><td>5</td><td>逻辑或</td><td>从左到右</td><td>… 逻辑或 …</td></tr><tr><td>4</td><td>条件运算符</td><td>从右到左</td><td>… ? … : …</td></tr><tr><td>3</td><td>赋值</td><td>从右到左</td><td>… = …</td></tr><tr><td></td><td></td><td></td><td>… += …</td></tr><tr><td></td><td></td><td></td><td>… -= …</td></tr><tr><td></td><td></td><td></td><td>… *= …</td></tr><tr><td></td><td></td><td></td><td>… /= …</td></tr><tr><td></td><td></td><td></td><td>… %= …</td></tr><tr><td></td><td></td><td></td><td>… &#171;= …</td></tr><tr><td></td><td></td><td></td><td>… &#187;= …</td></tr><tr><td></td><td></td><td></td><td>… &#187;>= …</td></tr><tr><td></td><td></td><td></td><td>… &= …</td></tr><tr><td></td><td></td><td></td><td>… ^= …</td></tr><tr><td></td><td></td><td></td><td>… 或= …</td></tr><tr><td>2</td><td>yield</td><td>从右到左</td><td>yield …</td></tr><tr><td></td><td>yield*</td><td>从右到左</td><td>yield* …</td></tr><tr><td>1</td><td>展开运算符</td><td>n/a</td><td>… …</td></tr><tr><td>0</td><td>逗号</td><td>从左到右</td><td>… , …</td></tr></tbody></table></li></ol><p>这题首先看优先级的第 18 和第 17 都出现关于 new 的优先级，new (带参数列表) 比 new (无参数列表) 高比函数调用高，跟成员访问同级</p><p><code>new Foo.getName();</code> 的优先级是这样的</p><p>相当于是:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>new (Foo.getName)();
</span></span></code></pre></td></tr></table></div></div><ul><li>点的优先级 (18) 比 new 无参数列表 (17) 优先级高</li><li>当点运算完后又因为有个括号 <code>()</code>，此时就是变成 new 有参数列表 (18)，所以直接执行 new，当然也可能有朋友会有疑问为什么遇到 () 不函数调用再 new 呢，那是因为函数调用 (17) 比 new 有参数列表 (18) 优先级低</li></ul><blockquote><p>.成员访问 (18)-> new 有参数列表 (18)</p></blockquote><p>所以这里实际上将 getName 函数作为了构造函数来执行，遂弹出 2。</p><ol start=6><li><p>这一题比上一题的唯一区别就是在 Foo 那里多出了一个括号，这个有括号跟没括号我们在第五问的时候也看出来优先级是有区别的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(new Foo()).getName()
</span></span></code></pre></td></tr></table></div></div><p>那这里又是怎么判断的呢？首先 new 有参数列表 (18) 跟点的优先级 (18) 是同级，同级的话按照从左向右的执行顺序，所以先执行 new 有参数列表 (18) 再执行点的优先级 (18)，最后再函数调用 (17)</p><blockquote><p>new 有参数列表 (18)-> .成员访问 (18)-> () 函数调用 (17)</p></blockquote><p>这里还有一个小知识点，Foo 作为构造函数有返回值，所以这里需要说明下 JS 中的构造函数返回值问题。</p></li></ol><a href=#构造函数的返回值><h3 id=构造函数的返回值><span class=hanchor arialabel=Anchor># </span>构造函数的返回值</h3></a><p>在传统语言中，构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。<br>而在 JS 中构造函数可以有返回值也可以没有。</p><ol><li>没有返回值则按照其他语言一样返回实例化对象。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function Foo(name) {
</span></span><span class=line><span class=cl>this.name = name
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>console.log(new Foo(&#39;wscats&#39;))
</span></span></code></pre></td></tr></table></div></div><ol><li>若有返回值则检查其返回值是否为引用类型。如果是非引用类型，如基本类型（String,Number,Boolean,Null,Undefined）则与无返回值相同，实际返回其实例化对象。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function Foo(name) {
</span></span><span class=line><span class=cl>this.name = name
</span></span><span class=line><span class=cl>return 520
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>console.log(new Foo(&#39;wscats&#39;))
</span></span></code></pre></td></tr></table></div></div><ol><li>若返回值是引用类型，则实际返回值为这个引用类型。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function Foo(name) {
</span></span><span class=line><span class=cl>this.name = name
</span></span><span class=line><span class=cl>return {
</span></span><span class=line><span class=cl>age: 16
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>console.log(new Foo(&#39;wscats&#39;))
</span></span></code></pre></td></tr></table></div></div><p>原题中，由于返回的是 this，而 this 在构造函数中本来就代表当前实例化对象，最终 Foo 函数返回实例化对象。</p><p>之后调用实例化对象的 getName 函数，因为在 Foo 构造函数中没有为实例化对象添加任何属性，当前对象的原型对象 (prototype) 中寻找 getName 函数。</p><p>当然这里再拓展个题外话，如果构造函数和原型链都有相同的方法，如下面的代码，那么默认会拿构造函数的公有方法而不是原型链，这个知识点在原题中没有表现出来，后面改进版我已经加上。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Foo</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=nx>name</span>
</span></span><span class=line><span class=cl><span class=k>this</span><span class=p>.</span><span class=nx>getName</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>name</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>Foo</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=s1>&#39;Oaoafly&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>Foo</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>getName</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=s1>&#39;Oaoafly&#39;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>((</span><span class=k>new</span> <span class=nx>Foo</span><span class=p>(</span><span class=s1>&#39;Wscats&#39;</span><span class=p>)).</span><span class=nx>name</span><span class=p>)</span> <span class=c1>//Wscats
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>((</span><span class=k>new</span> <span class=nx>Foo</span><span class=p>(</span><span class=s1>&#39;Wscats&#39;</span><span class=p>)).</span><span class=nx>getName</span><span class=p>())</span> <span class=c1>//Wscats
</span></span></span></code></pre></td></tr></table></div></div><ol start=7><li><p><code>new new Foo().getName();</code></p><p>同样是运算符优先级问题。做到这一题其实我已经觉得答案没那么重要了，关键只是考察面试者是否真的知道面试官在考察我们什么。<br>最终实际执行为:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>new ((new Foo()).getName)();
</span></span></code></pre></td></tr></table></div></div><blockquote><p>new 有参数列表 (18)-> new 有参数列表 (18)</p></blockquote><p>先初始化 Foo 的实例化对象，然后将其原型上的 getName 函数作为构造函数再次 new，所以最终结果为 3</p></li></ol><p>进阶版</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>this</span><span class=p>.</span><span class=nx>getName</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nx>getName</span><span class=o>:</span> <span class=nx>getName</span> <span class=c1>//这个就是第六问中涉及的构造函数的返回值问题
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span> <span class=c1>//这个就是第六问中涉及到的，JS构造函数公有方法和原型链方法的优先级
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>getName</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=k>this</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>Foo</span><span class=p>.</span><span class=nx>getName</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nx>Foo</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>getName</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>6</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>getName</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>getName</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=c1>//答案：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>Foo</span><span class=p>.</span><span class=nx>getName</span><span class=p>();</span> <span class=c1>//2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>getName</span><span class=p>();</span> <span class=c1>//4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>Foo</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=nx>Foo</span><span class=p>().</span><span class=nx>getName</span><span class=p>();</span> <span class=c1>//1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>getName</span><span class=p>();</span> <span class=c1>//1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>new</span> <span class=nx>Foo</span><span class=p>.</span><span class=nx>getName</span><span class=p>();</span> <span class=c1>//2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>new</span> <span class=nx>Foo</span><span class=p>().</span><span class=nx>getName</span><span class=p>();</span> <span class=c1>//3
</span></span></span><span class=line><span class=cl><span class=c1>//多了一问
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>new</span> <span class=nx>Foo</span><span class=p>().</span><span class=nx>getName</span><span class=p>().</span><span class=nx>getName</span><span class=p>();</span> <span class=c1>//3 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>new</span> <span class=k>new</span> <span class=nx>Foo</span><span class=p>().</span><span class=nx>getName</span><span class=p>();</span> <span class=c1>//3
</span></span></span></code></pre></td></tr></table></div></div><a href=#20写出结果><h2 id=20写出结果><span class=hanchor arialabel=Anchor># </span>20.写出结果</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nb>String</span><span class=p>(</span><span class=s1>&#39;11&#39;</span><span class=p>)</span> <span class=o>==</span> <span class=k>new</span> <span class=nb>String</span><span class=p>(</span><span class=s1>&#39;11&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nb>String</span><span class=p>(</span><span class=s1>&#39;11&#39;</span><span class=p>)</span> <span class=o>===</span> <span class=k>new</span> <span class=nb>String</span><span class=p>(</span><span class=s1>&#39;11&#39;</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>True false</p><p>new String() 返回的是对象</p><p><code><mark></code>的时候，实际运行的是 String(&lsquo;11&rsquo;)</mark> new String(&lsquo;11&rsquo;).toString();</p><p><code>===</code> 不再赘述。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>str1</span> <span class=o>=</span> <span class=nb>String</span><span class=p>(</span><span class=s1>&#39;11&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>str2</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>String</span><span class=p>(</span><span class=s1>&#39;11&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>str1</span> <span class=o>==</span> <span class=nx>str2</span> <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>str1</span> <span class=o>===</span> <span class=nx>str2</span> <span class=c1>// false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typeof</span> <span class=nx>str1</span>  <span class=c1>// &#34;string&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typeof</span> <span class=nx>str2</span> <span class=c1>// &#34;object&#34;
</span></span></span></code></pre></td></tr></table></div></div><a href=#21写出结果><h2 id=21写出结果><span class=hanchor arialabel=Anchor># </span>21.写出结果</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=mi>1</span> <span class=o>+</span> <span class=s2>&#34;1&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mi>2</span> <span class=o>*</span> <span class=s2>&#34;2&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=s2>&#34;a&#34;</span> <span class=o>+</span> <span class=o>+</span> <span class=s2>&#34;b&#34;</span>
</span></span><span class=line><span class=cl><span class=c1>//答案为
</span></span></span><span class=line><span class=cl><span class=c1>//&#39;11&#39;
</span></span></span><span class=line><span class=cl><span class=c1>//4
</span></span></span><span class=line><span class=cl><span class=c1>//&#39;1,22,1&#39;
</span></span></span><span class=line><span class=cl><span class=c1>//&#39;aNaN&#39;
</span></span></span></code></pre></td></tr></table></div></div><ul><li>1 + &ldquo;1&rdquo;</li></ul><p>加性操作符：如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来</p><p>所以值为：“11”</p><ul><li>2 * &ldquo;2&rdquo;</li></ul><p>乘性操作符：如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值</p><ul><li>[1, 2] + [2, 1]</li></ul><p>Javascript 中所有对象基本都是先调用 <code>valueOf</code> 方法，如果不是数值，再调用 <code>toString</code> 方法。</p><p>所以两个数组对象的 toString 方法相加，值为：&ldquo;1,22,1&rdquo;</p><ul><li>&ldquo;a&rdquo; + + &ldquo;b&rdquo;</li></ul><p>后边的“+”将作为一元操作符，如果操作数是字符串，将调用 Number 方法将该操作数转为数值，如果操作数无法转为数值，则为 NaN。</p><p>所以值为：&ldquo;aNaN&rdquo;</p><p>以上均参考：《Javascript 高级程序设计》</p><p><strong>稍稍补充一小下：</strong> 加号作为一元运算符时，其后面的表达式将进行
<a href=http://www.ecma-international.org/ecma-262/6.0/#sec-tonumber rel=noopener>ToNumber(参考es规范)</a> 的抽象操作：</p><ul><li>true -> 1</li><li>false -> 0</li><li>undefined -> NaN</li><li>null -> 0</li><li>’字符串‘ -> 字符串为纯数字时返回转换后的数字（十六进制返回十进制数），否则返回 NaN</li><li>对象 -> 通过
<a href=http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive rel=noopener>ToPrimitive</a> 拿到基本类型值，然后再进行
<a href=http://www.ecma-international.org/ecma-262/6.0/#sec-tonumber rel=noopener>ToNumber</a> 操作</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=o>+</span><span class=kc>true</span>  <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>+</span><span class=kc>false</span> <span class=c1>// 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>+</span><span class=kc>undefined</span> <span class=c1>// NaN
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>+</span><span class=kc>null</span> <span class=c1>// 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>+</span><span class=s1>&#39;b&#39;</span>    <span class=c1>// NaN
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>+</span><span class=s1>&#39;0x10&#39;</span> <span class=c1>// 16
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>+</span><span class=p>{</span><span class=nx>valueOf</span><span class=o>:</span> <span class=p>()=&gt;</span> <span class=mi>5</span><span class=p>}</span> <span class=c1>// 5
</span></span></span></code></pre></td></tr></table></div></div><a href=#22为什么-for-循环嵌套顺序会影响性能><h2 id=22为什么-for-循环嵌套顺序会影响性能><span class=hanchor arialabel=Anchor># </span>22.为什么 For 循环嵌套顺序会影响性能？</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>t1</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Date</span><span class=p>().</span><span class=nx>getTime</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=o>&lt;</span> <span class=mi>1000</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>k</span> <span class=o>&lt;</span> <span class=mi>10000</span><span class=p>;</span> <span class=nx>k</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>t2</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Date</span><span class=p>().</span><span class=nx>getTime</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;first time&#39;</span><span class=p>,</span> <span class=nx>t2</span> <span class=o>-</span> <span class=nx>t1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=mi>10000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=o>&lt;</span> <span class=mi>1000</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>k</span> <span class=o>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=nx>k</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>t3</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Date</span><span class=p>().</span><span class=nx>getTime</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;two time&#39;</span><span class=p>,</span> <span class=nx>t3</span> <span class=o>-</span> <span class=nx>t2</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>想起来之前在书上看到的，let 每个循环都会初始化，所以外层循环次数越大，内层变量初始化次数越多，影响性能。</p><a href=#23输出以下代码执行结果><h2 id=23输出以下代码执行结果><span class=hanchor arialabel=Anchor># </span>23.输出以下代码执行结果</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>wait</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nx>setTimeout</span><span class=p>(</span><span class=nx>resolve</span><span class=p>,</span> <span class=mi>10</span> <span class=o>*</span> <span class=mi>1000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>async</span> <span class=kd>function</span> <span class=nx>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>time</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>x</span> <span class=o>=</span> <span class=nx>wait</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>y</span> <span class=o>=</span> <span class=nx>wait</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>z</span> <span class=o>=</span> <span class=nx>wait</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=kr>await</span> <span class=nx>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kr>await</span> <span class=nx>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kr>await</span> <span class=nx>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>timeEnd</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>main</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><hr><a href=#24理解任务队列-消息队列><h2 id=24理解任务队列-消息队列><span class=hanchor arialabel=Anchor># </span>24.理解任务队列 (消息队列)</h2></a><p>一种是同步任务（synchronous），另一种是异步任务（asynchronous）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl>    <span class=c1>// 请问最后的输出结果是什么？
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;A&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=kc>true</span><span class=p>){</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;B&#34;</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>如果你的回答是 A,恭喜你答对了，因为这是同步任务，程序由上到下执行，遇到 while() 死循环，下面语句就没办法执行。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl>    <span class=c1>// 请问最后的输出结果是什么？
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;A&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>setTimeout</span><span class=p>(</span><span class=kd>function</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    	<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;B&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=kc>true</span><span class=p>){}</span>
</span></span></code></pre></td></tr></table></div></div><p>如果你的答案是 A，恭喜你现在对 js 运行机制已经有个粗浅的认识了！ 题目中的 setTimeout() 就是个异步任务。在所有同步任务执行完之前，任何的异步任务是不会执行的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// new Promise(xx)相当于同步任务, 会立即执行, .then后面的是微任务
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;----------------- start -----------------&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;setTimeout&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;{</span>  <span class=c1>// new Promise(xx)相当于同步任务, 会立即执行, .then后面的是微任务
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kd>var</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>resolve</span><span class=p>();</span>  
</span></span><span class=line><span class=cl><span class=p>}).</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;promise实例成功回调执行&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;----------------- end -----------------&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=o>-----------------</span> <span class=nx>start</span> <span class=o>-----------------</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=o>-----------------</span> <span class=nx>end</span> <span class=o>-----------------</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=nx>promise实例成功回调执行</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=nx>setTimeout</span>
</span></span></code></pre></td></tr></table></div></div><p>new Promise(xx) 相当于同步任务, 会立即执行</p><p>所以: x,y,z 三个任务是几乎同时开始的, 最后的时间依然是 10*1000ms (比这稍微大一点点, 超出部分在 1x1000ms 之内)</p><p><strong>但如果稍稍修改</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>wait</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span>
</span></span><span class=line><span class=cl>		<span class=nx>setTimeout</span><span class=p>(</span><span class=nx>resolve</span><span class=p>,</span> <span class=mi>10</span> <span class=o>*</span> <span class=mi>1000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>async</span> <span class=kd>function</span> <span class=nx>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>console</span><span class=p>.</span><span class=nx>time</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=kr>const</span> <span class=nx>x</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>wait</span><span class=p>();</span> <span class=c1>// 每个都是都执行完才结,包括setTimeout（10*1000）的执行时间
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kr>const</span> <span class=nx>y</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>wait</span><span class=p>();</span> <span class=c1>// 执行顺序 x-&gt;y-&gt;z 同步执行，x 与 setTimeout 属于同步执行
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kr>const</span> <span class=nx>z</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>wait</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=nx>console</span><span class=p>.</span><span class=nx>timeEnd</span><span class=p>();</span> <span class=c1>// default: 30099.47705078125ms
</span></span></span><span class=line><span class=cl><span class=c1></span>	
</span></span><span class=line><span class=cl>	<span class=nx>console</span><span class=p>.</span><span class=nx>time</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=kr>const</span> <span class=nx>x1</span> <span class=o>=</span> <span class=nx>wait</span><span class=p>();</span> <span class=c1>// x1,y1,z1 同时异步执行， 包括setTimeout（10*1000）的执行时间
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kr>const</span> <span class=nx>y1</span> <span class=o>=</span> <span class=nx>wait</span><span class=p>();</span> <span class=c1>// x1 与 setTimeout 属于同步执行
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kr>const</span> <span class=nx>z1</span> <span class=o>=</span> <span class=nx>wait</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=kr>await</span> <span class=nx>x1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kr>await</span> <span class=nx>y1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kr>await</span> <span class=nx>z1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=nx>console</span><span class=p>.</span><span class=nx>timeEnd</span><span class=p>();</span> <span class=c1>// default: 10000.67822265625ms
</span></span></span><span class=line><span class=cl><span class=c1></span>	
</span></span><span class=line><span class=cl>	<span class=nx>console</span><span class=p>.</span><span class=nx>time</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=kr>const</span> <span class=nx>x2</span> <span class=o>=</span> <span class=nx>wait</span><span class=p>();</span> <span class=c1>// x2,y2,z2 同步执行，但是不包括setTimeout（10*1000）的执行时间
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kr>const</span> <span class=nx>y2</span> <span class=o>=</span> <span class=nx>wait</span><span class=p>();</span> <span class=c1>// x2 与 setTimeout 属于异步执行
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kr>const</span> <span class=nx>z2</span> <span class=o>=</span> <span class=nx>wait</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=nx>x2</span><span class=p>,</span><span class=nx>y2</span><span class=p>,</span><span class=nx>z2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=nx>console</span><span class=p>.</span><span class=nx>timeEnd</span><span class=p>();</span> <span class=c1>// default: 0.065185546875ms
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>main</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><a href=#25for-in-和-for-of-的区别><h2 id=25for-in-和-for-of-的区别><span class=hanchor arialabel=Anchor># </span>25.for In 和 for of 的区别</h2></a><p>for..of 适用遍历数/数组对象/字符串/map/set 等拥有迭代器对象的集合.但是不能遍历对象,因为没有迭代器对象.与 forEach() 不同的是，它可以正确响应 break、continue 和 return 语句</p><p>for-of 循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用 for-in 循环（这也是它的本职工作）或内建的 Object.keys() 方法：</p><a href=#26数组扁平化处理实现一个-flatten-方法使得输入一个数组该数组里面的元素也可以是数组该方法会输出一个扁平化的数组><h2 id=26数组扁平化处理实现一个-flatten-方法使得输入一个数组该数组里面的元素也可以是数组该方法会输出一个扁平化的数组><span class=hanchor arialabel=Anchor># </span>26.数组扁平化处理：实现一个 Flatten 方法，使得输入一个数组，该数组里面的元素也可以是数组，该方法会输出一个扁平化的数组</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// Example
</span></span><span class=line><span class=cl>let givenArr = [[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10];
</span></span><span class=line><span class=cl>let outputArr = [1,2,2,3,4,5,5,6,7,8,9,11,12,12,13,14,10]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 实现flatten方法使得
</span></span><span class=line><span class=cl>flatten(givenArr)——&gt;outputArr
</span></span><span class=line><span class=cl>复制代码
</span></span></code></pre></td></tr></table></div></div><p>年轻的我是用递归实现的 QAQ，我的答案</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>flatten</span><span class=p>(</span><span class=nx>arr</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>res</span> <span class=o>=</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kd>var</span> <span class=nx>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=nx>i</span><span class=o>&lt;</span><span class=nx>arr</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span><span class=nx>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span><span class=p>(</span><span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>])){</span>
</span></span><span class=line><span class=cl>            <span class=nx>res</span> <span class=o>=</span> <span class=nx>res</span><span class=p>.</span><span class=nx>concat</span><span class=p>(</span><span class=nx>flatten</span><span class=p>(</span><span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>res</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>其实你还可以这样</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>flatten</span><span class=p>(</span><span class=nx>arr</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>arr</span><span class=p>.</span><span class=nx>reduce</span><span class=p>(</span><span class=kd>function</span><span class=p>(</span><span class=nx>prev</span><span class=p>,</span><span class=nx>item</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>prev</span><span class=p>.</span><span class=nx>concat</span><span class=p>(</span><span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span><span class=p>(</span><span class=nx>item</span><span class=p>)</span><span class=o>?</span><span class=nx>flatten</span><span class=p>(</span><span class=nx>item</span><span class=p>)</span><span class=o>:</span><span class=nx>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>},[]);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>还可以使用 ES6 拓展运算符</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>flatten</span><span class=p>(</span><span class=nx>arr</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=nx>arr</span><span class=p>.</span><span class=nx>some</span><span class=p>(</span><span class=nx>item</span><span class=p>=&gt;</span><span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span><span class=p>(</span><span class=nx>item</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>        <span class=nx>arr</span> <span class=o>=</span> <span class=p>[].</span><span class=nx>concat</span><span class=p>(...</span><span class=nx>arr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>arr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这是李魁昊写的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>let</span> <span class=nx>flatArr</span> <span class=o>=</span> <span class=p>(</span><span class=nx>arr</span><span class=p>)</span> <span class=p>=&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nx>arr</span><span class=p>.</span><span class=nx>reduce</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nx>acc</span><span class=p>,</span> <span class=nx>value</span><span class=p>,</span> <span class=nx>index</span><span class=p>,</span> <span class=nx>arr</span><span class=p>)</span> <span class=p>=&gt;</span>
</span></span><span class=line><span class=cl>      <span class=nx>acc</span><span class=p>.</span><span class=nx>concat</span><span class=p>(</span><span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span> <span class=o>?</span> <span class=nx>flatArr</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span> <span class=o>:</span> <span class=nx>value</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>[]</span>
</span></span><span class=line><span class=cl>  <span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><a href=#26asyncawait-和-promise><h2 id=26asyncawait-和-promise><span class=hanchor arialabel=Anchor># </span>26.Async/await 和 Promise</h2></a><p>Async/await 是 generator 和 Promise 的语法糖，但仅仅是语法糖吗？ 它们两个的性能有没有区别呢， 又或者 promise.then() 和 await 同为微任务，但是它们的执行顺序是怎样的呢？</p><p>Async/Await 与 Promise 最大区别在于：await b() 会暂停所在的 async 函数的执行；而 Promise.then(b) 将 b 函数加入回调链中之后，会继续执行当前函数。对于堆栈来说，这个不同点非常关键。</p><p>当一个 Promise 链抛出一个未处理的错误时，无论我们使用 await b() 还是 Promise.then(b)，JavaScript 引擎都需要打印错误信息及其堆栈。对于 JavaScript 引擎来说，两者获取堆栈的方式是不同的。</p><a href=#promisethen><h3 id=promisethen><span class=hanchor arialabel=Anchor># </span>Promise.then()</h3></a><p>观察下面代码, 假设 b() 返回一个 promise</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>const a = () =&gt; {
</span></span><span class=line><span class=cl>    b().then(() =&gt; c())
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>复制代码
</span></span></code></pre></td></tr></table></div></div><p>当调用 a() 函数时，这些事情同步发生，b() 函数产生一个 promise 对象，调用 then 方法，Promise 会在将来的某个时刻 resolve，也就是把 then 里的回调函数添加到回调链。(如果这一块不太明白，可以仔细学习 promise，或者读一读 promise 源码并尝试写一写，相信你更通透)，这样，a() 函数就执行完了，在这个过程中，a() 函数并不会暂停，因此在异步函数 resolve 的时候，a() 的作用域已经不存在了，那要如何生成包含 a() 的堆栈信息呢？ 为了解决这个问题，JavaScripts 引擎要做一些额外的工作；它会及时记录并保存堆栈信息。对于 V8 引擎来说，这些堆栈信息随着 Promise 在 Promise 链中传递，这样 c() 函数在需要的时候也能获取堆栈信息。但是这无疑造成了额外的开销，会降低性能；保存堆栈信息会占用额外的内存。</p><a href=#await><h3 id=await><span class=hanchor arialabel=Anchor># </span>Await</h3></a><p>我们可以用 Async/await 来实现一下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>const a = () =&gt; {
</span></span><span class=line><span class=cl>    await b()
</span></span><span class=line><span class=cl>    c()
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>复制代码
</span></span></code></pre></td></tr></table></div></div><p>使用 await 的时候，无需存储堆栈信息，因为存储 b() 到 a() 的指针的足够了。当 b() 函数执行的时候，a() 函数被暂停了，因此 a() 函数的作用域还在内存可以访问。如果 b() 抛出一个错误，堆栈通过指针迅速生成。如果 c() 函数抛出一个错误，堆栈信息也可以像同步函数一样生成，因为 c() 是在 a() 中执行的。不论是 b() 还是 c()，我们都不需要去存储堆栈信息，因为堆栈信息可以在需要的时候立即生成。而存储指针，显然比存储堆栈更加节省内存</p><a href=#结论><h3 id=结论><span class=hanchor arialabel=Anchor># </span>结论</h3></a><p>很多 ECMAScript 语法特性看起来都只是些语法糖，其实并非如此，至少 Async/await 绝不仅仅是语法糖 为了让 JavaScript 引擎处理堆栈的方式性能更高，请尽量使用 Async/await，而不是直接使用 Promise。</p><a href=#27commonjs-和-es6-模块化的区别以及如何解决让-commonjs-导出的模块也能改变其内部变量><h2 id=27commonjs-和-es6-模块化的区别以及如何解决让-commonjs-导出的模块也能改变其内部变量><span class=hanchor arialabel=Anchor># </span>27.CommonJS 和 ES6 模块化的区别以及如何解决让 CommonJS 导出的模块也能改变其内部变量</h2></a><a href=#es6-模块化><h3 id=es6-模块化><span class=hanchor arialabel=Anchor># </span>ES6 模块化</h3></a><p>1.export<br>export 可以输出变量、函数和类，切记不可直接输出值，否则会报错<br>2.export default<br>一个模块只能有一个默认输出，因此 export default 命令只能使用一次。所以，import 命令后面才不用加大括号，因为只可能唯一对应 export default 命令<br>3.import<br>import 命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块对外接口的名称相同。如果想为输入的变量重新取一个名字，import 命令要使用 as 关键字，将输入的变量重命名。</p><p><code>import {sum} from 'index.js'; import {sum,age,name} from 'index.js'; import {sum as hg, age as nl, name as xm} from 'index.js';</code></p><p>import 只会导入一次，无论你引入多少次<br>有提升效果，import 会自动提升到顶部，首先执行<br>import 命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。如果脚本加载了变量，对其重新赋值就会报错，因为变量是一个只读的接口。但是，如果是一个对象，改写对象的属性是允许的。（对象只能改变值但不能改变引用）<br>由于 import 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。<br>import 后面的 from 指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js 后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉<br>JavaScript 引擎该模块的位置。<br>循环加载时，ES6 模块是动态引用。只要两个模块之间存在某个引用，代码就能够执行。</p><a href=#commonjs><h3 id=commonjs><span class=hanchor arialabel=Anchor># </span>CommonJs</h3></a><p>1.module.exports<br>2.require<br>CommonJs 模块的特点</p><p>所有代码都运行在模块作用域，不会污染全局作用域。<br>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。<br>模块加载的顺序，按照其在代码中出现的顺序。<br>CommonJs 规范加载模块是同步的，即只有加载完成，才能执行后面的操作<br>CommonJs 模块的加载机制是，输入的是被输出的值的拷贝，即，一旦输出一个值，模块内部的变化影响不到这个值 (关于这一条详细看下方举例 1⃣️)<br>对于基本数据类型，属于复制。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值。对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块。<br>当使用 require 命令加载某个模块时，就会运行整个模块的代码。<br>循环加载时，属于加载时执行。即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被 " 循环加载 &ldquo;，就只输出已经执行的部分，还未执行的部分不会输出。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// lib.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>counter</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>incCounter</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>counter</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>module</span><span class=p>.</span><span class=nx>exports</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>counter</span><span class=o>:</span> <span class=nx>counter</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>incCounter</span><span class=o>:</span> <span class=nx>incCounter</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// main.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>mod</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;./lib&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>mod</span><span class=p>.</span><span class=nx>counter</span><span class=p>);</span>  <span class=c1>// 3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>mod</span><span class=p>.</span><span class=nx>incCounter</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>mod</span><span class=p>.</span><span class=nx>counter</span><span class=p>);</span> <span class=c1>// 3
</span></span></span></code></pre></td></tr></table></div></div><p>经过事实的检验我们可以得出，在 CommonJs 中，输入的是被输出的值的拷贝。<br>上面代码说明，lib.js 模块加载以后，它的内部变化就影响不到输出的 mod.counter 了。这是因为 mod.counter 是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。<br>那 commonJs 怎么办呢 当然有！</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>counter</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>incCounter</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>counter</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>module</span><span class=p>.</span><span class=nx>exports</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>get</span> <span class=nx>counter</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>counter</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nx>incCounter</span><span class=o>:</span> <span class=nx>incCounter</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>再看 ES6 模块化</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// lib.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>export</span> <span class=kd>let</span> <span class=nx>counter</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=kd>function</span> <span class=nx>incCounter</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>counter</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1>// main.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>import</span> <span class=p>{</span> <span class=nx>counter</span><span class=p>,</span> <span class=nx>incCounter</span> <span class=p>}</span> <span class=nx>from</span> <span class=s1>&#39;./lib&#39;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>从上面我们看出，CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。而 ES6 模块是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</p><p>另外 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><h2 id=28webpack-中-loader-和-plugin-的区别是什么httpsgithubcomadvanced-frontenddaily-interview-questionissues308>28.
<a href=https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/308# rel=noopener>webpack 中 loader 和 plugin 的区别是什么</a></h2><a href=#主要区别><h4 id=主要区别><span class=hanchor arialabel=Anchor># </span>主要区别</h4></a><p>loader 用于加载某些资源文件。 因为 webpack 本身只能打包 commonjs 规范的 js 文件，对于其他资源例如 css，图片，或者其他的语法集，比如 jsx， coffee，是没有办法加载的。 这就需要对应的 loader 将资源转化，加载进来。从字面意思也能看出，loader 是用于加载的，它作用于一个个文件上。</p><p>plugin 用于扩展 webpack 的功能。它直接作用于 webpack，扩展了它的功能。当然 loader 也时变相的扩展了 webpack ，但是它只专注于转化文件（transform）这一个领域。而 plugin 的功能更加的丰富，而不仅局限于资源的加载。</p><a href=#29手写-callapplybind-实现及详解><h2 id=29手写-callapplybind-实现及详解><span class=hanchor arialabel=Anchor># </span>29.手写 call、apply、bind 实现及详解</h2></a><p>apply 接收两个参数，第一个参数为函数上下文 this，第二个参数为函数参数只不过是通过一个数组的形式传入的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>allName.apply(obj, [&#39;我是&#39;, &#39;前端&#39;])//我的全名是“我是一个前端” this指向obj
</span></span></code></pre></td></tr></table></div></div><p>call 接收多个参数，第一个为函数上下文也就是 this，后边参数为函数本身的参数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>        let obj = {
</span></span><span class=line><span class=cl>            name: &#34;一个&#34;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        function allName(firstName, lastName) {
</span></span><span class=line><span class=cl>            console.log(this)
</span></span><span class=line><span class=cl>            console.log(`我的全名是“${firstName}${this.name}${lastName}”`)
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        // 很明显此时allName函数是没有name属性的
</span></span><span class=line><span class=cl>        allName(&#39;我是&#39;, &#39;前端&#39;) //我的全名是“我是前端”  this指向window
</span></span><span class=line><span class=cl>        allName.call(obj, &#39;我是&#39;, &#39;前端&#39;) //我的全名是“我是一个前端” this指向ob
</span></span></code></pre></td></tr></table></div></div><p><img src=https://cdn.jsdelivr.net/gh/radoapx/rax-picbed/PicGo/blogs/%e9%9d%a2%e8%af%95/JavaScript/20210405162008.webp width=auto alt=image.png></p><p>bind 接收多个参数，第一个是 bind 返回值<em>返回值是一个函数</em>上下文的 this，不会立即执行。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>        let obj = {
</span></span><span class=line><span class=cl>            name: &#34;一个&#34;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        function allName(firstName, lastName, flag) {
</span></span><span class=line><span class=cl>            console.log(this)
</span></span><span class=line><span class=cl>            console.log(`我的全名是&#34;${firstName}${this.name}${lastName}&#34;我的座右铭是&#34;${flag}&#34;`)
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        allName.bind(obj) //不会执行
</span></span><span class=line><span class=cl>        let fn = allName.bind(obj)
</span></span><span class=line><span class=cl>        fn(&#39;我是&#39;, &#39;前端&#39;, &#39;好好学习天天向上&#39;)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        // 也可以这样用，参数可以分开传。bind后的函数参数默认排列在原函数参数后边
</span></span><span class=line><span class=cl>        fn = allName.bind(obj, &#34;你是&#34;)
</span></span><span class=line><span class=cl>        fn(&#39;前端&#39;, &#39;好好学习天天向上&#39;)
</span></span><span class=line><span class=cl>复制代码
</span></span></code></pre></td></tr></table></div></div><p>接下来搓搓手实现 call、apply 和 bind</p><a href=#call><h3 id=call><span class=hanchor arialabel=Anchor># </span>Call</h3></a><a href=#定义与使用><h4 id=定义与使用><span class=hanchor arialabel=Anchor># </span>定义与使用</h4></a><blockquote><p>Function.prototype.call():
<a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call rel=noopener>developer.mozilla.org/zh-CN/docs/…</a></p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// Function.prototype.call()样例
</span></span><span class=line><span class=cl>function fun(arg1, arg2) {
</span></span><span class=line><span class=cl>  console.log(this.name)
</span></span><span class=line><span class=cl>  console.log(arg1 + arg2)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>const _this = { name: &#39;YIYING&#39; }
</span></span><span class=line><span class=cl>// 接受的是一个参数列表;方法立即执行
</span></span><span class=line><span class=cl>fun.call(_this, 1, 2)
</span></span><span class=line><span class=cl>复制代码
</span></span><span class=line><span class=cl>// 输出：
</span></span><span class=line><span class=cl>YIYING
</span></span><span class=line><span class=cl>3
</span></span><span class=line><span class=cl>复制代码
</span></span></code></pre></td></tr></table></div></div><a href=#手写实现><h4 id=手写实现><span class=hanchor arialabel=Anchor># </span>手写实现</h4></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/**
</span></span><span class=line><span class=cl> * 自定义call实现
</span></span><span class=line><span class=cl> * @param context   上下文this对象
</span></span><span class=line><span class=cl> * @param args      动态参数
</span></span><span class=line><span class=cl> */
</span></span><span class=line><span class=cl>Function.prototype.ownCall = function(context, ...args) {
</span></span><span class=line><span class=cl>  context = (typeof context === &#39;object&#39; ? context : window)
</span></span><span class=line><span class=cl>  // 防止覆盖掉原有属性
</span></span><span class=line><span class=cl>  const key = Symbol()
</span></span><span class=line><span class=cl>  // 这里的this为需要执行的方法
</span></span><span class=line><span class=cl>  context[key] = this
</span></span><span class=line><span class=cl>  // 方法执行
</span></span><span class=line><span class=cl>  const result = context[key](...args)
</span></span><span class=line><span class=cl>  delete context[key]
</span></span><span class=line><span class=cl>  return result
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>复制代码
</span></span><span class=line><span class=cl>// 验证样例
</span></span><span class=line><span class=cl>function fun(arg1, arg2) {
</span></span><span class=line><span class=cl>  console.log(this.name)
</span></span><span class=line><span class=cl>  console.log(arg1 + arg2)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>const _this = { name: &#39;YIYING&#39; }
</span></span><span class=line><span class=cl>// 接受的是一个参数列表;方法立即执行
</span></span><span class=line><span class=cl>fun.ownCall(_this, 1, 2)
</span></span><span class=line><span class=cl>复制代码
</span></span><span class=line><span class=cl>// 输出：
</span></span><span class=line><span class=cl>YIYING
</span></span><span class=line><span class=cl>3
</span></span><span class=line><span class=cl>复制代码
</span></span></code></pre></td></tr></table></div></div><a href=#apply><h3 id=apply><span class=hanchor arialabel=Anchor># </span>Apply</h3></a><a href=#定义与使用-1><h4 id=定义与使用-1><span class=hanchor arialabel=Anchor># </span>定义与使用</h4></a><blockquote><p>Function.prototype.apply():
<a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply rel=noopener>developer.mozilla.org/zh-CN/docs/…</a></p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// Function.prototype.apply()样例
</span></span><span class=line><span class=cl>function fun(arg1, arg2) {
</span></span><span class=line><span class=cl>  console.log(this.name)
</span></span><span class=line><span class=cl>  console.log(arg1 + arg2)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>const _this = { name: &#39;YIYING&#39; }
</span></span><span class=line><span class=cl>// 参数为数组;方法立即执行
</span></span><span class=line><span class=cl>fun.apply(_this, [1, 2])
</span></span><span class=line><span class=cl>复制代码
</span></span><span class=line><span class=cl>// 输出：
</span></span><span class=line><span class=cl>YIYING
</span></span><span class=line><span class=cl>3
</span></span><span class=line><span class=cl>复制代码
</span></span></code></pre></td></tr></table></div></div><a href=#手写实现-1><h4 id=手写实现-1><span class=hanchor arialabel=Anchor># </span>手写实现</h4></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 自定义Apply实现
</span></span></span><span class=line><span class=cl><span class=cm> * @param context   上下文this对象
</span></span></span><span class=line><span class=cl><span class=cm> * @param args      参数数组
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=nb>Function</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>ownApply</span> <span class=o>=</span> <span class=kd>function</span><span class=p>(</span><span class=nx>context</span><span class=p>,</span> <span class=nx>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>context</span> <span class=o>=</span> <span class=p>(</span><span class=k>typeof</span> <span class=nx>context</span> <span class=o>===</span> <span class=s1>&#39;object&#39;</span> <span class=o>?</span> <span class=nx>context</span> <span class=o>:</span> <span class=nb>window</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 防止覆盖掉原有属性
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=nx>key</span> <span class=o>=</span> <span class=nx>Symbol</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 这里的this为需要执行的方法
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>context</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span> <span class=o>=</span> <span class=k>this</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 方法执行
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=nx>context</span><span class=p>[</span><span class=nx>key</span><span class=p>](...</span><span class=nx>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>delete</span> <span class=nx>context</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>result</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>复制代码</span>
</span></span><span class=line><span class=cl><span class=c1>// 验证样例
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>fun</span><span class=p>(</span><span class=nx>arg1</span><span class=p>,</span> <span class=nx>arg2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>arg1</span> <span class=o>+</span> <span class=nx>arg2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>_this</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;YIYING&#39;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 参数为数组;方法立即执行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fun</span><span class=p>.</span><span class=nx>ownApply</span><span class=p>(</span><span class=nx>_this</span><span class=p>,</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nx>复制代码</span>
</span></span><span class=line><span class=cl><span class=c1>// 输出：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>YIYING</span>
</span></span><span class=line><span class=cl><span class=mi>3</span>
</span></span></code></pre></td></tr></table></div></div><a href=#bind><h3 id=bind><span class=hanchor arialabel=Anchor># </span>Bind</h3></a><a href=#定义与使用-2><h4 id=定义与使用-2><span class=hanchor arialabel=Anchor># </span>定义与使用</h4></a><blockquote><p>Function.prototype.bind() :
<a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind rel=noopener>developer.mozilla.org/zh-CN/docs/…</a></p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// Function.prototype.bind()样例
</span></span><span class=line><span class=cl>function fun(arg1, arg2) {
</span></span><span class=line><span class=cl>  console.log(this.name)
</span></span><span class=line><span class=cl>  console.log(arg1 + arg2)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>const _this = { name: &#39;YIYING&#39; }
</span></span><span class=line><span class=cl>// 只变更fun中的this指向，返回新function对象
</span></span><span class=line><span class=cl>const newFun = fun.bind(_this)
</span></span><span class=line><span class=cl>newFun(1, 2)
</span></span><span class=line><span class=cl>复制代码
</span></span><span class=line><span class=cl>// 输出：
</span></span><span class=line><span class=cl>YIYING
</span></span><span class=line><span class=cl>3
</span></span><span class=line><span class=cl>复制代码
</span></span></code></pre></td></tr></table></div></div><a href=#手写实现-2><h4 id=手写实现-2><span class=hanchor arialabel=Anchor># </span>手写实现</h4></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/**
</span></span><span class=line><span class=cl> * 自定义bind实现
</span></span><span class=line><span class=cl> * @param context     上下文
</span></span><span class=line><span class=cl> * @returns {Function}
</span></span><span class=line><span class=cl> */
</span></span><span class=line><span class=cl>Function.prototype.ownBind = function(context) {
</span></span><span class=line><span class=cl>  context = (typeof context === &#39;object&#39; ? context : window)
</span></span><span class=line><span class=cl>  return (...args)=&gt;{
</span></span><span class=line><span class=cl>    this.call(context, ...args)
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>复制代码
</span></span><span class=line><span class=cl>// 验证样例
</span></span><span class=line><span class=cl>function fun(arg1, arg2) {
</span></span><span class=line><span class=cl>  console.log(this.name)
</span></span><span class=line><span class=cl>  console.log(arg1 + arg2)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>const _this = { name: &#39;YIYING&#39; }
</span></span><span class=line><span class=cl>// 只变更fun中的this指向，返回新function对象
</span></span><span class=line><span class=cl>const newFun = fun.ownBind(_this)
</span></span><span class=line><span class=cl>newFun(1, 2)
</span></span><span class=line><span class=cl>复制代码
</span></span><span class=line><span class=cl>// 输出：
</span></span><span class=line><span class=cl>YIYING
</span></span><span class=line><span class=cl>3
</span></span></code></pre></td></tr></table></div></div></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/ data-ctx=javascript data-src=/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98 class=internal-link>前端面试题</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://jieye-ericx.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Jieye ericx using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://jieye-ericx.github.io/>Home</a></li><li><a href=https://github.com/jieye-ericx>Github</a></li></ul></footer></div></div></body></html>