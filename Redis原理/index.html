<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="1.数据类型 1 Redis键(key) keys 查看当前库所有key (匹配：keys 1)
exists key判断某个key是否存在
type key 查看你的key是什么类型
del key 删除指定的key数据
unlink key 根据value选择非阻塞删除
 仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。"><meta property="og:title" content="1.数据类型"><meta property="og:description" content="1.数据类型 1 Redis键(key) keys 查看当前库所有key (匹配：keys 1)
exists key判断某个key是否存在
type key 查看你的key是什么类型
del key 删除指定的key数据
unlink key 根据value选择非阻塞删除
 仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。"><meta property="og:type" content="website"><meta property="og:image" content="https://jieye-ericx.github.io/icon.png"><meta property="og:url" content="https://jieye-ericx.github.io/Redis%E5%8E%9F%E7%90%86/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="1.数据类型"><meta name=twitter:description content="1.数据类型 1 Redis键(key) keys 查看当前库所有key (匹配：keys 1)
exists key判断某个key是否存在
type key 查看你的key是什么类型
del key 删除指定的key数据
unlink key 根据value选择非阻塞删除
 仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。"><meta name=twitter:image content="https://jieye-ericx.github.io/icon.png"><title>1.数据类型</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://jieye-ericx.github.io//icon.png><link href=https://jieye-ericx.github.io/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://jieye-ericx.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://jieye-ericx.github.io/js/darkmode.48459b7116d092b4e98d2cab704cad80.min.js></script>
<script src=https://jieye-ericx.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://jieye-ericx.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://jieye-ericx.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://jieye-ericx.github.io/",fetchData=Promise.all([fetch("https://jieye-ericx.github.io/indices/linkIndex.5cb91301b5757313a79594f685463278.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://jieye-ericx.github.io/indices/contentIndex.a9bd2ef199aef20aa1579b5d4022202b.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://jieye-ericx.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://jieye-ericx.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/jieye-ericx.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=jieye-ericx.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://jieye-ericx.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://jieye-ericx.github.io/>jieye の 数字花园</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>1.数据类型</h1><p class=meta>Last updated
Dec 8, 2022</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#1-redis键key>1 Redis键(key)</a></li><li><a href=#2-字符串string>2 字符串(String)</a><ol><li><a href=#命令>命令</a></li><li><a href=#数据结构>数据结构</a></li></ol></li><li><a href=#3-列表list>3 列表List</a><ol><li><a href=#命令-1>命令</a></li><li><a href=#数据结构-1>数据结构</a></li></ol></li><li><a href=#4-set>4 Set</a><ol><li><a href=#命令-2>命令</a></li><li><a href=#数据结构-2>数据结构</a></li></ol></li><li><a href=#5-哈希hash>5 哈希(Hash)</a><ol><li><a href=#命令-3>命令</a></li><li><a href=#数据结构-3>数据结构</a></li></ol></li><li><a href=#6-有序集合zsetsorted-set>6 有序集合Zset(sorted set)</a><ol><li><a href=#命令-4>命令</a></li><li><a href=#数据结构-4>数据结构</a></li></ol></li><li><a href=#7-bitmaps>7 Bitmaps</a><ol><li><a href=#命令-5>命令</a></li><li><a href=#bitmaps-与-set-对比>Bitmaps 与 set 对比</a></li></ol></li><li><a href=#8-hyperloglog>8 HyperLogLog</a></li><li><a href=#9-geospatial>9 Geospatial</a></li></ol><ol><li><a href=#multiexecdiscard>Multi、Exec、discard</a></li></ol></nav></details></aside><a href=#1数据类型><h1 id=1数据类型><span class=hanchor arialabel=Anchor># </span>1.数据类型</h1></a><a href=#1-redis键key><h2 id=1-redis键key><span class=hanchor arialabel=Anchor># </span>1 Redis键(key)</h2></a><p>keys 查看当前库所有key    (匹配：keys 1)<br>exists key判断某个key是否存在<br>type key 查看你的key是什么类型<br>del key 删除指定的key数据<br>unlink key 根据value选择非阻塞删除</p><blockquote><p>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</p></blockquote><p>expire key 10   10秒钟：为给定的key设置过期时间<br>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期<br>select 命令切换数据库<br>dbsize 查看当前数据库的key的数量<br>flushdb 清空当前库<br>flushall 通杀全部库</p><a href=#2-字符串string><h2 id=2-字符串string><span class=hanchor arialabel=Anchor># </span>2 字符串(String)</h2></a><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。<br>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。<br>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M。</p><a href=#命令><h3 id=命令><span class=hanchor arialabel=Anchor># </span>命令</h3></a><p><img src=https://jieye-ericx.github.io//Pasted%20image%2020221208223909.png width=auto alt></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>*NX：当数据库中key不存在时，可以将key-value添加数据库
</span></span><span class=line><span class=cl>*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥
</span></span><span class=line><span class=cl>*EX：key的超时秒数
</span></span><span class=line><span class=cl>*PX：key的超时毫秒数，与EX互斥
</span></span></code></pre></td></tr></table></div></div><ul><li>get   &lt;key> 查询对应键值</li><li>append  &lt;key>&lt;value> 将给定的&lt;value>追加到原值的末尾</li><li>strlen  &lt;key>获得值的长度</li><li>setnx  &lt;key>&lt;value> 只有在 key 不存在时设置 key 的值</li><li>incr &lt;key> 将key中储存的数字值增1,只能对数字值操作，如果为空，新增值为1</li><li>decr  &lt;key>将 key 中储存的数字值减1,只能对数字值操作，如果为空，新增值为-1</li><li>incrby / decrby  &lt;key>&lt;步长>将 key 中储存的数字值增减。自定义步长。</li><li>mset  &lt;key1>&lt;value1>&lt;key2>&lt;value2>… 同时设置一个或多个 key-value对 </li><li>mget  &lt;key1>&lt;key2>&lt;key3>… 同时获取一个或多个 value </li><li>msetnx &lt;key1>&lt;value1>&lt;key2>&lt;value2> … 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</li></ul><blockquote><p>所谓<strong>原子</strong>操作是指不会被线程调度机制打断的操作；<br>这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。<br>（1）在单线程中，能够在单条指令中完成的操作都可以认为是"原子操作"，因为中断只能发生于指令之间。<br>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</p></blockquote><p><strong>Redis单命令的原子性主要得益于Redis的单线程。</strong></p><ul><li>getrange  &lt;key>&lt;起始位置>&lt;结束位置>获得值的范围，类似java中的substring，前包，后包</li><li>setrange  &lt;key>&lt;起始位置>&lt;value> 用&lt;value>覆写&lt;key>所储存的字符串值，从&lt;起始位置>开始(<strong>索引从0开始</strong>)。</li><li>setex  &lt;key>&lt;过期时间>&lt;value> 设置键值的同时，设置过期时间，单位秒。</li><li>getset &lt;key>&lt;value> 以新换旧，设置了新值同时获得旧值。</li></ul><a href=#数据结构><h3 id=数据结构><span class=hanchor arialabel=Anchor># </span>数据结构</h3></a><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于JavaArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221208224851.png width=auto alt><br>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。<strong>当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</strong></p><a href=#3-列表list><h2 id=3-列表list><span class=hanchor arialabel=Anchor># </span>3 列表List</h2></a><p>单键多值:Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221208224951.png width=auto alt></p><a href=#命令-1><h3 id=命令-1><span class=hanchor arialabel=Anchor># </span>命令</h3></a><ul><li>lpush/rpush  &lt;key>&lt;value1>&lt;value2>&lt;value3> …. 从左边/右边插入一个或多个值。</li><li>lpop/rpop  &lt;key>从左边/右边吐出一个值。值在键在，值光键亡。</li><li>rpoplpush  &lt;key1>&lt;key2>从&lt;key1>列表右边吐出一个值，插到&lt;key2>列表左边。</li><li>lrange &lt;key>&lt;start>&lt;stop> 按照索引下标获得元素(从左到右)</li><li>lrange mylist 0 -1   0左边第一个，-1右边第一个，（表示获取所有）</li><li>lindex &lt;key>&lt;index>按照索引下标获得元素(从左到右)</li><li>llen &lt;key>获得列表长度</li><li>linsert &lt;key>  before &lt;value>&lt;newvalue>在&lt;value>的后面插入&lt;newvalue>插入值</li><li>lrem &lt;key>&lt;n>&lt;value>从左边删除n个value(从左到右)</li><li>lset &lt;key>&lt;index>&lt;value>将列表key下标为index的值替换成value</li></ul><a href=#数据结构-1><h3 id=数据结构-1><span class=hanchor arialabel=Anchor># </span>数据结构</h3></a><p>List的数据结构为快速链表quickList。<br>首先在列表<strong>元素较少的情况下会使用一块连续的内存存储</strong>，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。<br>当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221208225524.png width=auto alt><br>Redis将链表和ziplist结合起来组成了quicklist。也就是<strong>将多个ziplist使用双向指针串起来使用</strong>。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><a href=#4-set><h2 id=4-set><span class=hanchor arialabel=Anchor># </span>4 Set</h2></a><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p><p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的<strong>复杂度都是****O(1)</strong>。</p><p>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p><a href=#命令-2><h3 id=命令-2><span class=hanchor arialabel=Anchor># </span>命令</h3></a><ul><li>sadd &lt;key>&lt;value1>&lt;value2> …..<br>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</li><li>smembers &lt;key>取出该集合的所有值。</li><li>sismember &lt;key>&lt;value>判断集合&lt;key>是否为含有该&lt;value>值，有1，没有0</li><li>scard&lt;key>返回该集合的元素个数</li><li>srem &lt;key>&lt;value1>&lt;value2> …. 删除集合中的某个元素。</li><li>spop &lt;key>随机从该集合中吐出一个值。</li><li>srandmember &lt;key>&lt;n>随机从该集合中取出n个值。不会从集合中删除</li><li>smove <source>&lt;destination>value把集合中一个值从一个集合移动到另一个集合</li><li>sinter &lt;key1>&lt;key2>返回两个集合的交集元素。</li><li>sunion &lt;key1>&lt;key2>返回两个集合的并集元素。</li><li>sdiff &lt;key1>&lt;key2>返回两个集合的差集元素(key1中的，不包含 key2中的)</li></ul><a href=#数据结构-2><h3 id=数据结构-2><span class=hanchor arialabel=Anchor># </span>数据结构</h3></a><p>Set数据结构是dict字典，字典是用哈希表实现的。</p><p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p><a href=#5-哈希hash><h2 id=5-哈希hash><span class=hanchor arialabel=Anchor># </span>5 哈希(Hash)</h2></a><p>Redis hash 是一个键值对集合。</p><p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><p>类似Java里面的Map&lt;String,Object><br>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储<br>主要有以下2种存储方式：<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221209001600.png width=auto alt><br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221209001607.png width=auto alt><br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221209001913.png width=auto alt><br><strong>通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题</strong></p><a href=#命令-3><h3 id=命令-3><span class=hanchor arialabel=Anchor># </span>命令</h3></a><ul><li>hset &lt;key>&lt;field>&lt;value>给&lt;key>集合中的  &lt;field>键赋值&lt;value></li><li>hget &lt;key1>&lt;field>从&lt;key1>集合&lt;field>取出 value</li><li>hmset &lt;key1>&lt;field1>&lt;value1>&lt;field2>&lt;value2>… 批量设置hash的值</li><li>hexists&lt;key1>&lt;field>查看哈希表 key 中，给定域 field 是否存在。</li><li>hkeys &lt;key>列出该hash集合的所有field</li><li>hvals &lt;key>列出该hash集合的所有value</li><li>hincrby &lt;key>&lt;field>&lt;increment>为哈希表 key 中的域 field 的值加上增量 1   -1</li><li>hsetnx &lt;key>&lt;field>&lt;value>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在</li></ul><a href=#数据结构-3><h3 id=数据结构-3><span class=hanchor arialabel=Anchor># </span>数据结构</h3></a><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p><a href=#6-有序集合zsetsorted-set><h2 id=6-有序集合zsetsorted-set><span class=hanchor arialabel=Anchor># </span>6 有序集合Zset(sorted set)</h2></a><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p><p>不同之处是有序集合的每个成员都关联了一个**评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了。</p><p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p><p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><a href=#命令-4><h3 id=命令-4><span class=hanchor arialabel=Anchor># </span>命令</h3></a><ul><li>zadd  &lt;key>&lt;score1>&lt;value1>&lt;score2>&lt;value2><br>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</li><li>zrange &lt;key>&lt;start>&lt;stop>  [WITHSCORES]<br>返回有序集 key 中，下标在&lt;start>&lt;stop>之间的元素<br>带WITHSCORES，可以让分数一起和值返回到结果集。</li><li>zrangebyscore key minmax [withscores] [limit offset count]<br>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</li><li>zrevrangebyscore key maxmin [withscores] [limit offset count]<br>同上，改为从大到小排列</li><li>zincrby &lt;key>&lt;increment>&lt;value>      为元素的score加上增量</li><li>zrem  &lt;key>&lt;value>删除该集合下，指定值的元素</li><li>zcount &lt;key>&lt;min>&lt;max>统计该集合，分数区间内的元素个数</li><li>zrank &lt;key>&lt;value>返回该值在集合中的排名，从0开始<br>利用zset实现一个文章访问量的排行榜:<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221209005108.png width=auto alt></li></ul><a href=#数据结构-4><h3 id=数据结构-4><span class=hanchor arialabel=Anchor># </span>数据结构</h3></a><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double>，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。<br>zset底层使用了两个数据结构<br>（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。<br>（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。<br><strong>跳跃表</strong><br>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。<br>对比有序链表和跳跃表，从链表中查询出51：</p><ol><li>有序链表<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221209005250.png width=auto alt><br>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较</li><li>跳跃表<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020221209005310.png width=auto alt><br>从第2层开始，1节点比51节点小，向后比较<br>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层<br>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下<br>在第0层，51节点为要查找的节点，节点被找到，共查找4次<br>从此可以看出跳跃表比有序链表效率要高</li></ol><a href=#7-bitmaps><h2 id=7-bitmaps><span class=hanchor arialabel=Anchor># </span>7 Bitmaps</h2></a><p>现代计算机用二进制（位）作为信息的基础单位，1个字节等于8位，例如“abc”字符串是由3个字节组成，但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、01100010和01100011，如下图<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020230103213511.png width=auto alt><br>合理地使用操作位能够有效地提高内存使用率和开发效率。<br>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p><ol><li>Bitmaps本身不是一种数据类型，实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</li><li>Bitmaps单独提供了一套命令，所以在Redis中使用Bitmaps和使用字符串的方法不太相同。可以把Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1，数组的下标在Bitmaps中叫做偏移量。<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020230103213602.png width=auto alt></li></ol><a href=#命令-5><h3 id=命令-5><span class=hanchor arialabel=Anchor># </span>命令</h3></a><p><code>setbit&lt;key>&lt;offset>&lt;value>设置Bitmaps中某个偏移量的值（0或1）</code><br><code>getbit&lt;key>&lt;offset>获取Bitmaps中某个偏移量的值</code><br>bitcount 统计<strong>字符串</strong>被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的start或end参数，可以让计数只在特定的位上进行。start和end参数的设置，都可以使用负数值：比如-1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。<br><code>bitcount&lt;key>[start end] 统计字符串从start字节到end字节比特值为1的数量</code><br><code>bitop  and(or/not/xor) &lt;destkey> [key…]</code>bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。</p><a href=#bitmaps-与-set-对比><h3 id=bitmaps-与-set-对比><span class=hanchor arialabel=Anchor># </span>Bitmaps 与 set 对比</h3></a><p>假设网站有1亿用户，每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020230103213743.png width=auto alt><br>很明显，这种情况下使用Bitmaps能节省很多的内存空间，尤其是随着时间推移节省的内存还是非常可观的<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020230103213821.png width=auto alt><br>但Bitmaps并不是万金油，假如该网站每天的独立访问用户很少，例如只有10万（大量的僵尸用户），那么两者的对比如下表所示，很显然，这时候使用Bitmaps就不太合适了，因为基本上大部分位都是0。<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020230103214011.png width=auto alt></p><a href=#8-hyperloglog><h2 id=8-hyperloglog><span class=hanchor arialabel=Anchor># </span>8 HyperLogLog</h2></a><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站P（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。<br>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种<strong>求集合中不重复元素个数的问题称为基数问题</strong>。</p><p>解决基数问题有很多种方案：<br>（1）数据存储在MySQL表中，使用distinct count计算不重复个数<br>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理<br>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。<br>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog<br>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。<br>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。<br>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。<br>什么是基数?<br>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。<br><code>pfadd &lt;key>&lt; element> [element …]   添加指定元素到 HyperLogLog 中</code><br><code>pfcount&lt;key> [key …] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可</code><br><code>pfmerge&lt;destkey>&lt;sourcekey> [sourcekey …]  将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</code></p><a href=#9-geospatial><h2 id=9-geospatial><span class=hanchor arialabel=Anchor># </span>9 Geospatial</h2></a><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。<br><code>geoadd&lt;key>&lt; longitude>&lt;latitude>&lt;member> [longitude latitude member…]   添加地理位置（经度，纬度，名称）</code><br>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。<br>有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。<br>当坐标位置超出指定范围时，该命令将会返回一个错误。已经添加的数据，是无法再次往里面添加的。<br><code>geopos  &lt;key>&lt;member> [member…]  获得指定地区的坐标值</code><br><code>geodist&lt;key>&lt;member1>&lt;member2>  [m|km|ft|mi ]  获取两个位置之间的直线距离</code><br><code>georadius&lt;key>&lt; longitude>&lt;latitude>radius  m|km|ft|mi   以给定的经纬度为中心，找出某一半径内的元素</code></p><a href=#2发布和订阅><h1 id=2发布和订阅><span class=hanchor arialabel=Anchor># </span>2.发布和订阅</h1></a><a href=#3事务><h1 id=3事务><span class=hanchor arialabel=Anchor># </span>3.事务</h1></a><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>Redis事务的主要作用就是串联多个命令防止别的命令插队。</p><a href=#multiexecdiscard><h2 id=multiexecdiscard><span class=hanchor arialabel=Anchor># </span>Multi、Exec、discard</h2></a><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。</p><p>组队的过程中可以通过discard来放弃组队。<br><img src=https://jieye-ericx.github.io//Pasted%20image%2020230104010837.png width=auto alt><br><img src=https://jieye-ericx.github.io//Pasted%20image%2020230104010928.png width=auto alt><br><img src=https://jieye-ericx.github.io//Pasted%20image%2020230104011414.png width=auto alt><br><strong>事务的错误处理</strong><br>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%83%A8%E7%BD%B2%E8%BF%90%E7%BB%B4/ data-ctx=Redis原理 data-src=/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%83%A8%E7%BD%B2%E8%BF%90%E7%BB%B4 class=internal-link>数据库、部署、运维</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://jieye-ericx.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Jieye ericx using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://jieye-ericx.github.io/>Home</a></li><li><a href=https://github.com/jieye-ericx>Github</a></li></ul></footer></div></div></body></html>